\section{Important Principals}\label{principalsInto}

This section provides an insight into what we need to know in order to solve any problems.

It will be broken up into several sections: the first section ``Introduction to Embedded Systems'' will attempt to define what an embedded systems is, specifying unique characteristics. The second section ``Problem description and requirements'' will identify and discuss security problems, codifying these into a set of requirements. The third section ``Common Attacks'' gives a deeper analysis of attacks used to exploit the problems identified in the second section. The fourth section ``Control Flow Integrity'' introduces us to the notion of control flow integrity (CFI) and examines, from a high level, existing implementations for providing CFI. The fifth section ``Data Flow Integrity'' discusses a data-focusses parallel of CFI. The sixth section ``Existing Solutions'' will identify, discuss and analyse existing solutions and compare them to the requirements attained in the second section. Finally the conclusion will provide a brief summation of the previous sections.

\section{Introduction to Embedded Systems}\label{introEmbeddedSystems}

In this section we will define embedded systems, their uses, understand their key properties or criteria and describe some common implementations.


\subsection{A Definition of Embedded Systems}\label{defineEmbeddedSystems}

Embedded systems are small-form, low power computer systems.

From Embedded Systems Design (Arnold S Berger):
VS a PC:
\begin{itemize}
\item Dedicated to specific task (PCS are generic computing platforms) - A change of task will usually require redesigning an entire system
\item Supported by a wide array of processors and processor architectures
\item Usually cost sensitive
\item Real-time constraints - if has an OS will be RTOS
\item Implications of software failure far more serious than desktop systems (due to their usage)
\item Often have power constrains
\item Often operate in extreme conditions
\item Far fewer system resources
\item Often store object code in ROM
\item Require specialized tools and efficiently design methods
\item Often have dedicated debugging circuitry.
\end{itemize}




\subsection{Uses of Embedded Systems}\label{usesEmbeddedSystems}

Embedded systems are ideal for applications where the computer systems has one role - for example in traffic lights, where the flow of traffic needs to be monitored and the timing of the light sequence needs to be controlled.

The low power consumption of embedded systems makes them ideal for use in medical devices which can only have small batteries such as insulin injection pumps, or as part of a collection of sensors which are served by a low power bus.

The small-form (and corresponding low-weight) means they are a good candidate for use in aeronautics, such as sensor controllers on aircraft or flight computers in missiles.

Consumer IoT also makes use of embedded systems, exploiting their low-cost, footprint and power consumption to add smart functions to what have historically been simple devices such as kettles or fridges.

\subsection{Key Properties and Criteria of an Embedded System}\label{propertiesEmbeddedSystems}
An embedded system could have a small form factor, low computing power (in comparison to full computer systems such as PCs), low power consumption and resistant to hostile environments.

\subsection{Common Implementations of Embedded Systems}\label{implementationsEmbeddedSystems}
A large number of manufactures has an interest in embedded systems. A big player is ARM with their Cortex-M Series of CPUs, these are commonly used in applications such as...

Another angle are field programmable gate arrays (FPGAs) which are essentially software defined circuits. These can be set up in a variety of ways, but in modern applications they often utilise soft-core processors - where FPGA code is used to define a processor (for example following the RISC-V instruction set).

System on Chips (SoCs) are a good example of an embedded system - here everything is on a chip.

\section{Problem Description, Assumptions and Requirements}

Instructions can be skipped, replaced or be re-ordered. Malicious code can be injected or return-oriented programming can make use of existing code simply by redirecting return addresses. 

Skipping instructions can be used to bypass checks.

Replacing instructions can be used to extract data or pass checks etc.

Re-ordering instructions can be used to bypass cryptographic protections (similar to ECB vulnerabilities) to achieve the attackers goals.

Attackers goals could be: changing program flow, ...

Assumptions could include: attacker having direct access to memory, not internal registers. They cannot break cryptographic protections.

Requirements: 
\begin{itemize}
	\item An attacker cannot change the sequential order of instructions.
	\item An attacker cannot change the execution order of blocks
	\item An attacker cannot re-order instructions
	\item An attacker cannot skip instructions
	\item An attacker cannot subvert control flow to existing code (libc...)
\end{itemize}

\section{Common Attacks}

Physical attacks - power ...

Return to lib-c

Return oriented programming

\section{Control Flow Integrity}

Fine grained, course grained.

Flow down to low level - sequential
Basic blocks

Control flow graphs

Shadow return address tables

Program counter

\section{Data Flow Integrity}

Data flow integrity is a measure used to ensure that data only flows in the correct direction from authorised callers. This can be used to ensure only the correct caller has changed an important variable - for example one which a decision is based on (e.g. if...), this can also be used to protect the stack.
One example of this maintains a table for each piece of data accessed with the address of last accessor. If the last accessor is not within the legal list a security failure exists and an exception is thrown.

\section{Existing Solutions}

Software - Microsoft (talked about in some sort of paper).
Other software implementations

Hardware - program counter, encrypted computing, all of the CFG examples

Additional notable - NX bit, canaries

Dynamic taint analysis - detect control-data and non-control-data attacks. No need for source code. But false positives, high overhead and require hardware support.

Problems:
PUFs
CFG generation
Checking code being altered

Compare to objectives

\section{Conclusion}
