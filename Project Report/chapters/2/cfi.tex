\section{Introduction}
\section{Control Flow Integrity}
\subsection{Introduction}
A Control-Flow Integrity (CFI) security policy is one which states that software execution must follow a path of a Control-Flow Graph (CFG).
\subsection{Control Flow Graphs}
Abadi et al. \cite{Abadi2005} introduced CFI as a method to protect the secure execution of software, using static analysis of a application binary to create a Control Flow Graph (CFG). Only control flow transfers within the CFG are permitted.

Clerq and Verbauwhede \cite{DeClercq2017} posed CFGs as part of a solution for tracking instructions causing control flow transfers, however Lee et al. \cite{Lee2019} note that they do not focus on sequential transitions. They argue that the method used in \cite{DeClercq2017} (where forward edges are described as control flow transfers caused by jumps and calls, and backward edges are described as those caused by returns) is disadvantageous as by considering all jumps and calls equally there is a loss in distinction between jumps to register-determined and instruction-determined locations. They state that when implementing a scheme, instruction-dependant transitions are simpler to process than instruction-independent transitions. This is described in reference to \cite{Lee2016}. SEP \cite{Lee2019} and SOFIA \cite{DeClercq2017b} go one step further where the integrity of each instruction is protected/.
\ifnotesincluded
\furtherwork{What are sequential transitions vs control flow transfers?}
\fi

\subsection{Introduction to CFGs}
Adabi et al. \cite{Abadi2005} state that CFGs can be defined by analysis-type methods or explicit policies. Examples of analysis-type methods include source-code analysis, binary analysis or execution profiling. An example of an explicit security policy method is writing as security automata as seen in \cite{Erlingsson2004}. \furtherwork{What is this???}


CFGs have been used to provide protection against soft faults (single-event upsets) using software based methods \cite{Oh2002} \cite{Sharma2012} \cite{Venkatasubramanian2003}. 
The solution put forward by Adabi et al. \cite{Abadi2005} restricts control flow through in-lined labels and checks. The CFG is embedded through a set of static, intermediate bit patterns in program code. The problem with this is that they are evaluated at the destinations of all branches and jumps but not at the sources. These fail to prevent jumps into middle of functions (e.g. ones which bypass security checks such as access control)

The method described in \cite{Abadi2005} ensures that whenever an instruction transfers control, it targets a valid destination as determined by the CFG (ahead of time). When the destination is determined at runtime this must go through a dynamic check. Dynamic checks are enabled through the the use of static analysis and machine-code rewriting forming an instrumentation process. Machine-code is rewritten using modern tools for binary instrumentation in order to overcome the resulting new memory addresses which are the result of the rewriting process\cite{Edwards2001} \cite{Srivastava1994}. Control-flow analysis techniques are described in \cite{AhoAlfredV.2014C:pt} \cite{Atkinson} \cite{Wagner2002} which run at compile time. A list of tools used in \cite{Abadi2005} is: Vulcan \cite{Edwards2001}, \cite{AhoAlfredV.2014C:pt}, \cite{Feng2003} \cite{Gopalakrishna2005}, \cite{Wagner2002}.

\subsection{Software-based CFI}

An excellent survey on software-based CFI is provided by \cite{Burow}, which provides a detailed insight into the technical properties of a number of software-based CFI solutions.

Generating CFG from static analysis is troublesome and often an over-approximation is used which is not fully precise \cite{Carlini2015} \cite{Kinder2012}, again \cite{Burow} classifies the precision of computing CFG using different static analysis techniques.

Problems: Unintended branches \cite{Kayaalp2014} - the majority of gadgets in a program consists of unintended branches. 

Seems similar: \cite{Mao2010}

Branch limitation is an alternative to CFG \cite{He2017} \cite{Corporation2017}.
Another alternative is Code Pointer Integrity described in \cite{Security2017} and implemented in \cite{Kuznetsov:204783} \cite{Mashtizadeh2014} \cite{Szekeres2013}.

Generalised path signature analysis \cite{Mahmood1988} while \cite{Werner2016} implemented in Arm Cortex-M3.
 