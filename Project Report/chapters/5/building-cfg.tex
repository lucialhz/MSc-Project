\section{Building CFGs}

\subsection{The problem behind building CFGs}

C-FLAT \cite{Abera2016} notes that efficiently computing a generic program's CFG, and accompanying exploration of all possible execution paths is an open problem. However it is also noted that static embedded application software is typically far simpler and therefore possible to reasonably compute a CFG for. 

\subsection{Existing tools}

\subsubsection{LLVM}

LLVM provides various methods of building CFGs which could be of use, for example:

\url{https://llvm.org/docs/Passes.html#dot-cfg-print-cfg-of-function-to-dot-file},
\url{https://llvm.org/docs/Passes.html#simplifycfg-simplify-the-cfg},
\url{https://llvm.org/docs/Passes.html#view-cfg-view-cfg-of-function}

I understand that this may not be a simple procedure and will need further investigation.

The dot format is highly used in CFG but I'm not sure if it will map well with what we receive while monitoring it.

\subsubsection{Vulcan}

Vulcan \cite{Edwards2001} is used by \cite{Davi2012} and the seminal work \cite{Abadi2005}. Though it has since been taken out of production by Microsoft.

\subsubsection{Jakstab}

Jakstab \cite{Kinder2008} can also be used to create a dot file containing the CFG of x86 executables, so this may need features adding in order to support embedded systems. The last development activity on this was 31st March 2017. I tested this out but was unable to produce any CFGs from my test programs (written in C Sharp. My lack of understanding of windows executables. 

\subsubsection{Others}

Kinder \cite{Kinder2012} has been trying to improve on this where the CFG is under approximated.

In C-FLAT \cite{Abera2016} the authors create their own analysis tool to achieve their branch-based requirements rather than create CFGs. They also use Capstone disassembly engine \footnote{\url{http://www.capstone-engine.org/}} however this is more for use as dissasembling code rather than CFG building.

LiteHAX \cite{Dessouky2018} uses the 'angr' \footnote{\url{http://angr.io/}} \cite{Shoshitaishvili2016} framework to generate the CFG outputting a networkx DiGraph. This could be good one as it is still under active development. The output of this process would need to be compatible with the dynamic attestation. angr offers two types of computation methods - CFGFast (a static CFG) and CFGEmulated (a dynamic CFG). LiteHax is worth another read as it seems to be quite thorough.

IDA Pro. 

\subsubsection{Do we need this?}
\cite{Nguyen2013} Talks of Control Flow Graph construction and uses Jakstab \cite{Kinder2008} for comparison. 

\furtherwork{"Jakstab translates machine code to a low level intermediate language on the fly as it performs data flow analysis on the growing control flow graph. Data flow information is used to resolve branch targets and discover new code locations. Other analyses can either be implemented in Jakstab to run together with the main control flow reconstruction to improve precision of the disassembly, or they can work on the resulting preprocessed control flow graph."}

In his dissertation \cite{Kinder2010} the author of Jakstab goes into more detail about everything...

Jakstab creates a 'dot' extension file. \href{https://en.wikipedia.org/wiki/DOT_(graph_description_language)} describes DOT as a graph description language which can be viewed with such tools as 

neo4j is a graphical database which could be an ideal method of storing the resultant CFGs. neo4j uses cypher as its description language - I have been unable to find a method of converting the resultant dot files to neo4j.