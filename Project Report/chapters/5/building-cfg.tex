\section{Building CFGs}

\subsection{The problem behind building CFGs}

C-FLAT \cite{Abera2016} notes that efficiently computing a generic program's CFG, and accompanying exploration of all possible execution paths is an open problem. However it is also noted that static embedded application software is typically far simpler and therefore possible to reasonably compute a CFG for, although the proof for this still remains to be seen.

\subsection{Existing tools}

\subsubsection{LLVM}

LLVM provides various methods of building CFGs which could be of use, for example:

\url{https://llvm.org/docs/Passes.html#dot-cfg-print-cfg-of-function-to-dot-file},\\
\url{https://llvm.org/docs/Passes.html#simplifycfg-simplify-the-cfg},\\
\url{https://llvm.org/docs/Passes.html#view-cfg-view-cfg-of-function}

Building CFGs in LLVM is not simple and is not a main feature of LLVM. The dot format is widely used in representing CFGs and further research is required to find whether it can be made to be compatible with control-flow tracing.

\subsubsection{Vulcan}

Vulcan \cite{Edwards2001} is used by \cite{Davi2012} and the seminal work \cite{Abadi2005}. Though it has since been taken out of production by Microsoft and is currently unavailable.

\subsubsection{Jakstab}

Jakstab \cite{Kinder2008},\cite{Kinder2010} can also be used to create a dot file containing the CFG of x86 executables, so this may need features adding in order to support embedded systems, it was successfully used in \cite{Nguyen2013} to construct CFGs. The last development activity on this was 31st March 2017. The tool's author has been trying to improve on this where they aim for the CFG to be under approximated \cite{Kinder2012} rather than over approximated (which can lead to vulnerabilities in resultant implementations).

\subsubsection{Others}

In C-FLAT \cite{Abera2016} the authors create their own analysis tool to achieve their branch-based requirements rather than create CFGs. They also use Capstone disassembly engine \footnote{\url{http://www.capstone-engine.org/}} however this is more for use as dissasembling code rather than CFG building.

LiteHAX \cite{Dessouky2018} uses the `angr' \footnote{\url{http://angr.io/}} \cite{Shoshitaishvili2016} framework to generate the CFG outputting a networkx DiGraph. This could be good one as it is still under active development. The output of this process would need to be compatible with the dynamic attestation. angr offers two types of computation methods - CFGFast (a static CFG) and CFGEmulated (a dynamic CFG). LiteHax is worth another read as it seems to be quite thorough.

IDA Pro is a popular tool for reverse-engineering which is able to create CFGs, however due to its high licence cost we have been unable to evaluate its suitability. The high cost also prohibits its utilisation as part of the tool chain.