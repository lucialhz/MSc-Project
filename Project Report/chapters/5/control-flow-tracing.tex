\section{Tracing Control-Flow}

\subsection{Using existing hardware}

Recording of every executed instruction is infeasible as the overhead added would be too large if no additional hardware is included, as each instruction processed would require a corresponding context switch and further processing. If each instruction is hashed in real time the computational overhead would increase or if each instruction is recorded in storage prior to processing the memory\slash storage\slash IO capacity would see a significant overhead increase. The use of basic blocks allows us to deal with multiple instructions at a time, and therefore reduce the potential overhead dramatically.

CFG granularity can be broken down into three levels \cite{Abera2016}:
\begin{enumerate}
	\item{Entire functions}
	\item{Basic Blocks ending in a direct branch (this would cover most ROP attacks)}
	\item{Basic Blocks ending in any branch instruction, this would provide the highest level of detail}
\end{enumerate}

To achieve the best coverage for the solution level 3 (Basic Blocks ending in any branch instruction) would be the optimum granularity to aim for.

We can build up a hash of the flow by taking the ID of the source node and hashing that with the previous hash. At the start ($ID_1$) the previous hash would be replaced with zero or a nonce. With the resulting chain appearing as: 
$H_1 = H(ID_1,0)$ (or $H_1 = H(ID_1,nonce)$), $H_2 = H(ID_2,H_1)$ ... $H_n = H(ID_n,H_{n-1})$.

The solution would implement a dedicated method in the secure world where a save is triggered. This will enable software authors an opportunity to save at key points - for example after a key decision is made. Hashes could also be stored along with variables used if we are able to implement that.

BLAKE-2 \footnote{\url{https://blake2.net}} has been suggested as a lightweight hash function, however this is only one such potential candidate.

\subsubsection*{Challenges of CFG tracking}

Loops are a considerable issue when it comes to tracking control flow, as the number of possible paths could be overwhelming, especially if the loops contain branch instructions or function calls.

To overcome the problems presented by loops, C-FLAT \cite{Abera2016} begins with treating loops as sub-programs. Where each run of a loop has a hash derived from it, and the total number of each time that hash was calculated is stored (therefore storing the number of times that exact sequence occurs). The result of this is the growth of the stored audit (as each loop will need to be referenced separately), when tested by C-FLAT was 1527 bytes for a path containing 16 loop invocations and 18 unique loop paths (this could probably be calculated at compile time, with a warning presented to the developer). Another path containing 12 loop invocations and 14 unique paths resulted in a 1179 byte result. Another second study (which is not as well documented by the paper) produced a maximum result of 490 bytes. The previous hash is also included to show where the was called from. 

Return call matching is used where call and return edges are indexed during static analysis, so only valid routes are authorised. Break statements need to be dealt with in a special manner as they are an additional place where a loop can exit. Section 4.2 of C-FLAT \cite{Abera2016} describes this in detail.

\subsubsection*{Instrumentation}

Branches are identified, with direct jump addresses stored in a branch table then replaced with the address of the trampoline assembly code which, when executing, triggers the measurement engine to be add the source address and destination address to the hash chain before redirecting the program counter to the corresponding entry on the branch table.

\subsubsection*{Trampolines}

A trampoline enables redirecting execution to a single piece of simple and secure code without needing to add too many instructions during instrumentation. A trampoline can carry out a number of functions but in C-FLAT \cite{Abera2016} it manages the return address register as well as the register holding the destination address in indirect branches. 

\subsubsection*{Hardware-assisted}

A co-processor designed specifically for the purpose of providing audit of control-flow would offload the heavy lifting and therefore have a negligible impact on normal operation. Examples of designs which could be tailored to provide auditing are provided in \cite{DeClercq2017}. A hardware-assisted solution could keep track of instructions executed (in the form of a hash), to add further granularity.