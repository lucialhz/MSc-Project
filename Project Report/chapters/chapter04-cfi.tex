\section{Introduction}
\section{Control Flow Integrity}
\subsection{Introduction}
Control-Flow Integrity (CFI) security policy states that software execution must follow a path of a Control-Flow Graph (CFG).
\subsection{Control Flow Graphs}
Abadi et al. \cite{Abadi2005}introduced CFG as a method to protect code, using static analysis of a application binary to create Control Flow Graph (CFG). Only control flow transfers within the CFG are permitted.

Clerq and Verbauwhede \cite{DeClercq2017} posed CFGs as a solution for instructions causing control flow transfers. Lee et al. \cite{Lee2019} note that they do not focus on sequential transitions. They argue that the method used in \cite{DeClercq2017} (where forward edges are described as control flow transfers caused by jumps and calls and backward edges are described as those caused by returns) is disadvantageous as by considering all jumps and calls equally there is a loss in distinction between jumps to register-determined and instruction-determined locations, and they state that when implementing a scheme instruction-dependant transitions are simpler to process than instruction-independent transitions. This is described in reference to \cite{Lee2016}.
\ifnotesincluded
\furtherwork{What are sequential transitions vs control flow transfers?}
\fi
\subsection{Others?}
\cite{Abadi2005} Describes jump labelling. 

\cite{DeClercq2017} Describes Shadow Call Stacks

\cite{DeClercq2017a} Describes SOFIA 

\subsection{Introduction to CFGs}
\cite{Abadi2005} states that CFGs can be defined by analysis-type methods or explicit policies. Examples of analysis-type methods include source-code analysis, binary, analysis binary analysis or execution profiling. An example of an explicit security policy method is writing as security automatat \cite{Erlingsson2004}.


CFGs have been used to provide protection against soft faults (single-event upsets) using software based methods \cite{Oh2002} \cite{Sharma2012} \cite{Venkatasubramanian2003}. 
\cite{Abadi2005} restricts control flow through inlined labels and checks. The CFG is embedded through a set of static, immdeidate bit patterns in program code. The problem with this is that they are evaluated at the destimations of all branches and jumps but not at the sources. These fail to prevent jumps into middle of functions (e.g. ones which bypass seucrity checks such as access control)

The method descibed in \cite{Abadi2005} ensures that whenever a machine-code instruction instruction transfers control, it targets a valid destination as determined by the CFG (ahead of time). When the destination is determined at runtime this must go through a dynamic check.

Static checks in \cite{Abadi2005} are made by rewriting machine code using modern tools for binary instrumentation to get around the resulting new memory addresses \cite{Edwards2001} \cite{Srivastava1994}.

Dynamic checks are a little more complex. \furtherwork{If this need to be understood then lets do that at a later time.} 

Instrumentation codes are used.\furtherwork{If this need to be understood then look up instrumentation codes.} 

Standard control flow analysis techniques exist \cite{AhoAlfredV.2014C:pt} \cite{Atkinson} \cite{Wagner2002} which run at compile time. Unique IDs could be created at run-time. \furtherwork{Could this be useful to bind hardware to software?}.

Tools used: Vulcan \cite{Edwards2001}, Techniquies from programming languages and intrustion detection literatures \cite{AhoAlfredV.2014C:pt} \cite{Feng2003} \cite{Gopalakrishna2005} \cite{Wagner2002}. Measured overhead on SPEC computation benchmarks http://www.spec.org/cpu2017/.

\subsection{Hardware-based CFI}

\cite{DeClercq2017} includes a reference to \cite{Burow} , a survey for software-based CFI.

Generating CFG from static analysis is troublesome and often an over-approximation is used which is not fully precise \cite{Carlini2015} \cite{Kinder2012}, again \cite{Burow} classifies the precision of computing CFG using differenct static analysis techniques.

Problems: Unintended branches \cite{Kayaalp2014} - the majority of gadgets in a program consists of unintended branches. 

Seems similar: \cite{Mao2010}

Branch limitation is an alternative to CFG \cite{He2017} \cite{Corporation2017}.
Another alternative is Code Pointer Integrity described in \cite{Security2017} and implemented in \cite{Kuznetsov:204783} \cite{Mashtizadeh2014} \cite{Szekeres2013}.

Generalised path signature analysis \cite{Mahmood1988} while \cite{Werner2016} implemented in Arm Cortex-M3.

\subsection{Software-based CFI}
\cite{Burow} Performs a survey

\subsection{Building Control Flow Graphs}
\cite{Nguyen2013} Talks of Control Flow Graph construction and uses Jakstab\cite{Kinder2008} for comparison. 

\furtherwork{"Jakstab translates machine code to a low level intermediate language on the fly as it performs data flow analysis on the growing control flow graph. Data flow information is used to resolve branch targets and discover new code locations. Other analyses can either be implemented in Jakstab to run together with the main control flow reconstruction to improve precision of the disassembly, or they can work on the resulting preprocessed control flow graph."}

In his dissertation \cite{Kinder2010} the author of Jakstab goes into more detail about everything...

Jakstab creates a 'dot' extension file. \href{https://en.wikipedia.org/wiki/DOT_(graph_description_language)} describes DOT as a graph description language which can be viewed with such tools as 

neo4j is a graphical database which could be an ideal method of storing the resultant CFGs. neo4j uses cypher as its description language - I have been unable to find a method of converting the resultant dot files to neo4j.
 