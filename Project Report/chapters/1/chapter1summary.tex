\section{Chapter Summary}
Control-flow is the way in which a program transitions between its instructions, being directed by programming mechanisms such as conditional statements, loops and functions. A useful method of breaking an application down is to look at sections where instructions execute sequentially from beginning to end, where there is no opportunity for execution to be diverted elsewhere within the program (for example, through a function call or \verb|switch-case| statement). These sequences of instructions are called ``basic blocks'' (BBLs) and are separated by branches, the different kinds of branches have been described in this chapter (with each type of branch having well-understood attacks designed to exploit them).

A control-flow graph (CFG) is a graphical representation of all of the legitimate transitions between BBLs within an application. In graph theory terms, BBLs are represented as vertices and transitions are represented as edges. A further detail to note is that CFGs are in fact digraphs, where the edges have a direction associated with them. Control-flow within an executing application is only valid when all execution follows the application's CFG, so a violation of a CFG represents a violation to the legitimate control-flow of the application, known as control-flow integrity (CFI).

Hardware and software attacks have been tailored to provide attackers with methods of violating CFI. Hardware attacks are extremely powerful, and represent a dangerous threat to the CFI of embedded systems. While hardware attacks are a threat, they also typically require expensive equipment, specialist technical skills and cannot be carried out en-masse. Software attacks on the other hand, while still requiring specialist technical skills, can be achieved using personal computers and scripts containing the exploit, can be repetitively used against a number of targets and can be sold on to other attackers with similar objectives. It is therefore reasonable to direct efforts of defence towards software attacks, albeit that the threat of advanced technical attacks on hardware should not be ignored (particularly for critical devices which are situated in unsecure environments.

The problem this project aims to address is that of auditing control-flow integrity. Control-flow integrity and attestation of control-flow are well-explored in existing literature, yet there is somewhat of a gap in relation to audit records.  Providing audit records would enable us to apply these principles to devices without the requirement to have a live connection with a verifier or without the introduction of computational overheads due to checks put in place to ensure run-time CFI.