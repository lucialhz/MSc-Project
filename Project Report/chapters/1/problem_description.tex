\section{Problem Description}
\subsection{Introduction}

CFI has long been an issue, with examples of attacks including return oriented programming, stack overflows and hardware-based attacks \furtherwork{link to attacks sections}. Several means of defence have been designed to address some or all of the problematic results \furtherwork{link to lit review and comparisons}. These include:

\subsubsection{Prevention}
Where violation of the control-flow integrity is prevented before it occurs. Methods include:
\begin{itemize}
	\item Read $\oplus$ Write memory, which prevents the execution of data memory and the overwriting of memory containing executable instructions.
	\item Encrypted instructions, which enforce decryption based on a particular order of instructions following the application CFG.
\end{itemize}

\subsubsection{Detection}
Where processes are put in place to detect a violation of control-flow integrity and act upon detection, in this instance the intention is to catch the violation before too much damage has been done.
\begin{itemize}
	\item Stack canaries, which detect ROP attempts therefore preventing violation of CFI.
	\item Shadow stacks, which aid in preventing return-oriented programming by detecting ROP attempts and assist in preventing violation of CFI
	\item Software-based CFI, which adds checking of calling IDs between each basic block to ensure they are permitted within the CFG. This was first discussed by Adabi et. al \cite{Abadi2005} and has been subject to a large number of further research elsewhere.
\end{itemize}

\subsubsection{Attestation}
Where a third party (verifier) receives a report, which could only have come from the device (prover), stating either that the control-flow integrity has not been violated or describing the taken control-flow therefore allowing the verifier to compare against the CFG to be sure that control-flow integrity has been maintained. Example methods include:
\begin{itemize}
	\item Basic-block IDs hashed to create hash chain representation of the control-flow path taken.
	\item Instructions intercepted by secondary hardware monitor to take flow measurements, comparing to the valid instructions as described by the CFG.
\end{itemize}

\subsection{Auditing control-flow}
CFI prevention and detection has proven to lead to a high computational overhead, while attestation requires an always-on connection. What if we can store the control flow of an application on a hard disk, which can be retrieved later? This could be useful to prove to a third party that a disputed result of a computation is correct (or at least the steps taken during the computation was correct), or keeping a record of the control-flow taken during a vitally important operation has been carried out.

Keeping audit records of control-flow could also be useful for spot-checking inaccessible devices which have no internet connection, such as ICS components or medical devices which can only be communicated with during medical check-ups.

So, while we would not provide immediate detection or real-time attestation, the contents of the audit file can be compared with the CFG for an application at a later time. This could also be useful for reducing computing requirements as comparisons could be appropriately scheduled for the efficient use of processor time rather than being performed on an ad-hoc basis as required by some attestation methods.
