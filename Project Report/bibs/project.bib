@article{Kleber2015a,
author = {Kleber, Stephan and Unterstein, Florian and Matousek, Matthias and Kargl, Frank and Slomka, Frank and Hiller, Matthias},
doi = {http://dx.doi.org/10.18725/OPARU-3255},
file = {:C$\backslash$:/Users/Luke/Downloads/vts{\_}9855{\_}15016 (1).pdf:pdf},
journal = {Workshop on Trustworthy Manufacturing and Utilization of Secure Devices, TRUDEVICE 2015},
number = {2},
pages = {1--5},
title = {{Design of the Secure Execution PUF-based Processor ( SEPP )}},
year = {2015}
}
@inproceedings{Lee2017,
address = {New York, New York, USA},
author = {Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem},
booktitle = {Proceedings of the 12th International Conference on Availability, Reliability and Security - ARES '17},
doi = {10.1145/3098954.3103158},
file = {:C$\backslash$:/Users/Luke/Downloads/provisioning{\_}software{\_}with{\_}hardware{\_}software{\_}binding{\_}open{\_}access (1).pdf:pdf},
isbn = {9781450352574},
pages = {1--9},
publisher = {ACM Press},
title = {{Provisioning Software with Hardware-Software Binding}},
url = {http://dl.acm.org/citation.cfm?doid=3098954.3103158},
year = {2017}
}
@book{GebotysCatherineH2010Sied,
address = {New York ; London},
author = {Gebotys, Catherine H},
isbn = {144191529x},
keywords = {Computer security,Embedded computer systems -- Se},
publisher = {Springer},
series = {Embedded systems},
title = {{Security in embedded devices}},
year = {2010}
}
@article{Chang2002,
abstract = {Protection of software code against illegitimate modifications by its users is a pressing issue to many software developers. Many software-based mechanisms for protecting program code are too weak (e.g., they have single points of failure) or too expensive to apply (e.g., they incur heavy runtime performance penalty to the protected programs). In this paper, we present and explore a methodology that we believe can protect program integrity in a more tamper-resilient and flexible manner. Our approach is based on a distributed scheme, in which protection and tamper-resistance of program code is achieved, not by a single security module, but by a network of (smaller) security units that work together in the program. These security units, or guards, can be programmed to do certain tasks (checksumming the program code is one example) and a network of them can reinforce the protection of each other by creating mutual-protection. We have implemented a system for automating the process of installing guards into Win32 executables. It is because our system operates on binaries that we are able to apply our protection mechanism to EXEs and DLLs. Experimental results show that memory space and runtime performance impacts incurred by guards can be kept very low (as explained later in the paper).},
author = {Chang, Hoi and Atallah, Mikhail J.},
doi = {10.1007/3-540-47870-1_10},
file = {:C$\backslash$:/Users/Luke/Downloads/Chang-Atallah2002{\_}Chapter{\_}ProtectingSoftwareCodeByGuards.pdf:pdf},
isbn = {3540436774},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {160--175},
title = {{Protecting software code by guards}},
volume = {2320},
year = {2002}
}
@article{Ott2018,
author = {Ott, Karl and Mahapatra, Rabi},
doi = {10.1109/DASC/PiCom/DataCom/CyberSciTec.2018.00101},
file = {:C$\backslash$:/Users/Luke/Downloads/08511944.pdf:pdf},
isbn = {9781538675182},
journal = {Proceedings - IEEE 16th International Conference on Dependable, Autonomic and Secure Computing, IEEE 16th International Conference on Pervasive Intelligence and Computing, IEEE 4th International Conference on Big Data Intelligence and Computing and IEEE 3},
keywords = {Embedded Systems,Hardware Performance Counters,Security},
pages = {528--535},
publisher = {IEEE},
title = {{Hardware performance counters for embedded software anomaly detection}},
year = {2018}
}
@article{Suh,
author = {Suh, G Edward and Clarke, Dwaine and Gassend, Blaise and Dijk, Marten Van and Devadas, Srinivas},
doi = {10.1145/782814.782838},
file = {:C$\backslash$:/Users/Luke/Downloads/aegis-retro.pdf:pdf},
isbn = {1581137338},
issn = {02105187},
keywords = {certified execution,secure processors,software licensing},
title = {{AEGIS : Architecture for Tamper-Evident and Tamper-Resistant Processing}}
}
@article{Chen2007,
abstract = {[1] Y. Chen, R. Venkatesan, M. Cary, R. Pang, S. Sinha, and M. H. Jakubowski, “Oblivious Hashing : A Stealthy Software Integrity Verification Primitive,” in 5th International Workshop on Information Hiding, 2002, pp. 400–414.},
author = {Chen, Yuqun and Sinha, Saurabh and Venkatesan, Ramarathnam and Pang, Ruoming and Jakubowski, Mariusz H. and Cary, Matthew},
doi = {10.1007/3-540-36415-3_26},
file = {:C$\backslash$:/Users/Luke/Downloads/chen02oh.pdf:pdf},
pages = {400--414},
title = {{Oblivious Hashing: A Stealthy Software Integrity Verification Primitive}},
year = {2007}
}
@article{ARM2009,
abstract = {This document provides an overview of the ARM TrustZone technology and how this can provide a practical level of security through careful System-on-a-Chip (SoC) configuration and software design.$\backslash$nARM TrustZone technology includes the ARM Security Extensions to the processor, the security signals added to the AMBA{\textregistered}3 bus infrastructure, and a number of pieces of peripheral Intellectual Property (IP) which can be used to build security on top of the$\backslash$nprocessor architecture and system architecture.},
author = {ARM},
file = {:C$\backslash$:/Users/Luke/Downloads/PRD29-GENC-009492C{\_}trustzone{\_}security{\_}whitepaper.pdf:pdf},
journal = {Manual},
pages = {108},
title = {{Building a Secure System using TrustZone Technology}},
year = {2009}
}
@article{Jacob2007,
abstract = {Executing binaries without interference by an outside adversary has been an ongoing duel between protection methods and at- tacks. Recently, an efficient kernel-patch attack has been pre- sented against commonly used self-checking code techniques that use checksumming ahead of execution. While methods based on self-modifying code can defend against this attack, such techniques depend on low-level architectural details and may not be practical in the long run. An alternative defense is to use oblivious hashing (OH). Instead of checking code integrity prior to execution, OH can verify untampered runtime behavior continuously. However, earlier OH approaches have some weaknesses, particularly with binary code: Physical instruction bytes cannot be easily checked during execution, and an attacker may be able to detect and remove OH checks, since OH alone does not provide tamper-resistance or obfuscation. In our approach, we deliberately overlap a program's basic blocks so that they share instruction bytes. This increases tamper- resistance implicitly because malicious modifications affect mul- tiple instructions simultaneously. Also, our scheme facilitates explicit anti-tampering checks via injection of OH instructions overlapped with target code, enabling OH that can verify in- tegrity of both runtime state and executing instructions. Thus, our method addresses anti-checksum attacks without resorting to self-modifying code, and also extends OH to verify physical code, not only program state. In addition, overlapping facilitates resis- tance against disassembly and decompilation. Our approach works on processor architectures and byte-codes that support variable- length instructions. To our knowledge, this is the first technique that blends tamper-resistance into architecture and therefore sig- nificantly improves robustness of binaries.},
author = {Jacob, Matthias and Jakubowski, Mariusz H and Venkatesan, Ramarathnam},
doi = {10.1145/1288869.1288887},
file = {:C$\backslash$:/Users/Luke/Downloads/jacob07overlap (1).pdf:pdf},
isbn = {978-1-59593-857-2},
journal = {Proceedings of the 9th Workshop on Multimedia {\&} Security},
keywords = {anti-disassembly,integrity checking,obfuscation,oblivious hashing,overlapped code,tamper-resistance},
pages = {129--140},
title = {{Towards Integral Binary Execution: Implementing Oblivious Hashing Using Overlapped Instruction Encodings}},
url = {http://doi.acm.org/10.1145/1288869.1288887},
year = {2007}
}
@article{TCG2007,
author = {TCG},
file = {:C$\backslash$:/Users/Luke/Downloads/TCG{\_}1{\_}4{\_}Architecture{\_}Overview.pdf:pdf},
number = {August},
title = {{TCG TCG Specification Architecture Overview Specification Revision 1.4 2 nd}},
url = {https://trustedcomputinggroup.org/wp-content/uploads/TCG{\_}1{\_}4{\_}Architecture{\_}Overview.pdf},
year = {2007}
}
@article{Owusu2013,
abstract = {We present OASIS, a CPU instruction set extension for ex- ternally verifiable initiation, execution, and termination of an isolated execution environment with a trusted computing base consisting solely of the CPU. OASIS leverages the hard- ware components available on commodity CPUs to achieve a low-cost, low-overhead design.},
author = {Owusu, Emmanuel and Guajardo, Jorge and Mccune, Jonathan M. and Newsome, Jim and Perrig, Adrian and Vasudevan, Amit},
doi = {10.1145/2508859.2516678},
file = {:C$\backslash$:/Users/Luke/Downloads/owusu{\_}oasis{\_}ccs13.pdf:pdf},
isbn = {9781450324779},
issn = {15437221},
journal = {Proceedings of the 2013 ACM SIGSAC conference on Computer and communications security (CCS'13)},
keywords = {instruction set extension,remote attestation,secure execution},
number = {i},
pages = {13--24},
title = {{OASIS: On Achieving a Sanctuary for Integrity and Secrecy on Untrusted Platforms}},
year = {2013}
}
@article{Fletcher2012,
abstract = {This paper considers encrypted computation where the user specifies encrypted inputs to an untrusted program, and the server computes on those encrypted inputs. To this end we propose a secure processor architecture, called Ascend, that guarantees privacy of data when arbitrary programs use the data running in a cloud-like environment (e.g., an untrusted server running an untrusted software stack). The key idea to guarantee privacy is obfuscated instruction execution; Ascend does not disclose what instruction is being run at any given time, be it an arithmetic instruction or a memory instruction. Periodic accesses to external instruction and data memory are performed through an Oblivious RAM (ORAM) interface to prevent leakage through memory access patterns. We evaluate the processor architecture on SPEC benchmarks running on encrypted data and quantify overheads.},
author = {Fletcher, Christopher W. and van Dijk, Marten and Devadas, Srinivas},
doi = {10.1145/2382536.2382540},
file = {:C$\backslash$:/Users/Luke/Downloads/ascend-stc12.pdf:pdf},
isbn = {9781450316620},
keywords = {encrypted computation,secure processors},
pages = {3},
title = {{A secure processor architecture for encrypted computation on untrusted programs}},
year = {2012}
}
@article{Suh2005,
abstract = {Secure processors enable new applications by ensuring private and authentic program execution even in the face of physical attack. In this paper, we present the AEGIS secure processor architecture, and evaluate its RTL implementation on FPGAs. By using physical random functions, we propose a new way of reliably protecting and sharing secrets that is more secure than existing solutions based on non-volatile memory. Our architecture gives applications the flexibility of trusting and protecting only a portion of a given process, unlike prior proposals which require a process to be protected in entirety. We also put forward a specific model of how secure applications can be programmed in a high-level language and compiled to run on our system. Finally, we evaluate a fully functional FPGA implementation of our processor, assess the implementation tradeoffs, compare performance, and demonstrate the benefits of partially protecting a program.},
author = {Suh, G. Edward and O'Donnell, Charles W. and Sachdev, Ishan and Devadas, Srinivas},
doi = {10.1145/1080695.1069974},
file = {:C$\backslash$:/Users/Luke/Downloads/01431543.pdf:pdf},
issn = {01635964},
journal = {ACM SIGARCH Computer Architecture News},
number = {2},
pages = {25--36},
title = {{Design and Implementation of the AEGIS Single-Chip Secure Processor Using Physical Random Functions}},
volume = {33},
year = {2005}
}
@article{Dijk2013,
abstract = {This paper investigates secure ways to interact with tamper-resistant hardware leaking a strictly bounded amount of information. Architectural support for the interaction mechanisms is studied and performance implications are evaluated. The interaction mechanisms are built on top of a recently-proposed secure processor Ascend[ascend-stc12]. Ascend is chosen because unlike other tamper-resistant hardware systems, Ascend completely obfuscates pin traffic through the use of Oblivious RAM (ORAM) and periodic ORAM accesses. However, the original Ascend proposal, with the exception of main memory, can only communicate with the outside world at the beginning or end of program execution; no intermediate information transfer is allowed. Our system, Stream-Ascend, is an extension of Ascend that enables intermediate interaction with the outside world. Stream-Ascend significantly improves the generality and efficiency of Ascend in supporting many applications that fit into a streaming model, while maintaining the same security level.Simulation results show that with smart scheduling algorithms, the performance overhead of Stream-Ascend relative to an insecure and idealized baseline processor is only 24.5{\%}, 0.7{\%}, and 3.9{\%} for a set of streaming benchmarks in a large dataset processing application. Stream-Ascend is able to achieve a very high security level with small overheads for a large class of applications. {\textcopyright} 2013 ACM.},
author = {van Dijk, Marten and Yu, Xiangyao and Ren, Ling and Fletcher, Christopher W. and Devadas, Srinivas},
doi = {10.1145/2517488.2517498},
file = {:C$\backslash$:/Users/Luke/Downloads/p23-yu.pdf:pdf},
isbn = {9781450324908},
keywords = {ascend,interaction,pin traffic,tamper-resistant hardware},
pages = {23--34},
title = {{Generalized external interaction with tamper-resistant hardware with bounded information leakage}},
year = {2013}
}
@article{Yang2003,
abstract = {Due to the widespread software piracy and virus attacks, significant efforts have been made to improve security for computer systems. For stand-alone computers, a key observation is that other than the processor, any component is vulnerable to security attacks. Recently, an execution only memory (XOM) architecture has been proposed to support copy and tamper resistant software by D. Lie et al. (2000), D. Lie et al. (2003) and T. Gilmont et al. (1999). In this design, the program and data are stored in encrypted format outside the CPU boundary. The decryption is carried after they are fetched from memory, and before they are used by the CPU. As a result, the lengthened critical path causes a serious performance degradation. In this paper, we present an innovative technique in which the cryptography computation is shifted off from the memory access critical path. We propose to use a different encryption scheme, namely "one-time pad" encryption, to produce the instructions and data ciphertext. With some additional on-chip storage, cryptography computations are carried in parallel with memory accesses, minimizing performance penalty. We performed experiments to study the trade-off between storage size and performance penalty. Our technique improves the execution speed of the XOM architecture by 34{\%} at maximum},
author = {Yang, Jun and Zhang, Youtao and Gao, Lan},
doi = {10.1109/MICRO.2003.1253209},
file = {:C$\backslash$:/Users/Luke/Downloads/p351-yang.pdf:pdf},
isbn = {076952043X},
issn = {10724451},
journal = {Proceedings of the Annual International Symposium on Microarchitecture, MICRO},
keywords = {Central Processing Unit,Computer architecture,Computer crime,Computer security,Concurrent computing,Cryptography,Data security,Degradation,Immune system,Memory architecture},
pages = {351--360},
title = {{Fast secure processor for inhibiting software piracy and tampering}},
volume = {2003-Janua},
year = {2003}
}
@article{Khiyal2010,
author = {Khiyal, Malik Sikandar Hayat and Khan, Aihab and Amjad, Sehrish and Khalil, M. Shahid},
file = {:C$\backslash$:/Users/Luke/Downloads/Evaluating{\_}Effectiveness{\_}of{\_}Tamper-Proofing{\_}on{\_}Dyn.pdf:pdf},
journal = {CoRR},
number = {July 2014},
title = {{Evaluating Effectiveness of Tamper Proofing on Dynamic Graph Software Watermarks}},
volume = {abs/1001.1},
year = {2010}
}
@article{Fritz,
author = {Fritz, Jason and Bonato, Michael and French, David and Scally, Larry},
file = {:C$\backslash$:/Users/Luke/Downloads/A{\_}Reconfigurable{\_}Advanced{\_}Tamper{\_}Resistant{\_}Embedde.pdf:pdf},
title = {{A Reconfigurable Advanced Tamper Resistant Embedded Processing Platform Anti-Tamper Technologies}}
}
@article{Al-Wosabi2015,
abstract = {Embedded systems (ES) become available anywhere and anytime as an established part of our daily routine. Developers of these systems face significant challenges in code and information security. Whereas, software tampering is one of these challenges, code integrity detection is one of the main approaches used to defeat it. Checking code integrity achieves tamper proofing by method of identification of unauthorized alteration to recognize any tampered code is executed or tampered data are used. Our research objective is to propose an applicable framework for tampering detection in ES and this paper introduces the exploratory outcomes so far.},
author = {Al-Wosabi, Abdo Ali Abdullah and Shukur, Zarina and Ibrahim, Muhammad Azwan},
doi = {10.1109/ICEEI.2015.7352507},
file = {:C$\backslash$:/Users/Luke/Downloads/07352507.pdf:pdf},
isbn = {9781467373197},
journal = {Proceedings - 5th International Conference on Electrical Engineering and Informatics: Bridging the Knowledge between Academic, Industry, and Community, ICEEI 2015},
keywords = {Embedded Systems,Software Integrity,Software Tampering,Tampering Detection},
number = {January 2016},
pages = {259--264},
title = {{Framework for software tampering detection in embedded systems}},
year = {2015}
}
@article{Khelladi2008,
author = {Khelladi, Lyes and Challal, Yacine and Bouabdallah, Abdelmadjid and Badache, Nadjib},
doi = {10.1504/ijics.2008.018515},
file = {:C$\backslash$:/Users/Luke/Downloads/E2S.pdf:pdf},
issn = {1744-1765},
journal = {International Journal of Information and Computer Security},
number = {2},
pages = {140},
title = {{On security issues in embedded systems: challenges and solutions}},
volume = {2},
year = {2008}
}
@book{AhoAlfredV.2014C:pt,
annote = {Chapter 9 for Data-Flow Analysis},
author = {Aho, Alfred V},
edition = {Second edi},
isbn = {9781292024349},
keywords = {Compilers (Computer programs)},
series = {Pearson custom library},
title = {{Compilers : principles, techniques, and tools.}},
year = {2014}
}
@article{Ahmadvand2019,
abstract = {Tampering with software by man-at-the-end (MATE) attackers is an attack that can lead to security circumvention, privacy violation, reputation damage, and revenue loss. In this model, adversaries are end users who have full control over software as well as its execution environment. This full control enables them to tamper with programs to their benefit and to the detriment of software vendors or other end users. Software integrity protection research seeks for means to mitigate those attacks. Since the seminal work of Aucsmith, a great deal of research effort has been devoted to fight MATE attacks, and many protection schemes were designed by both academia and industry. Advances in trusted hardware, such as TPM and Intel SGX, have also enabled researchers to utilize such technologies for additional protection. Despite the introduction of various protection schemes, there is no comprehensive comparison study that points out advantages and disadvantages of different schemes. Constraints of different schemes and their applicability in various industrial settings have not been studied. More importantly, except for some partial classifications, to the best of our knowledge, there is no taxonomy of integrity protection techniques. These limitations have left practitioners in doubt about effectiveness and applicability of such schemes to their infrastructure. In this work, we propose a taxonomy that captures protection processes by encompassing system, defense and attack perspectives. Later, we carry out a survey and map reviewed papers on our taxonomy. Finally, we correlate different dimensions of the taxonomy and discuss observations along with research gaps in the field.},
author = {Ahmadvand, Mohsen and Pretschner, Alexander and Kelbert, Florian},
doi = {10.1016/bs.adcom.2017.12.007},
file = {:C$\backslash$:/Users/Luke/Downloads/aic18.pdf:pdf},
isbn = {9780128151211},
issn = {00652458},
journal = {Advances in Computers},
keywords = {Integrity protection,Software monetization,Software protection,Tamper-proofing,Taxonomy},
pages = {413--486},
title = {{A Taxonomy of Software Integrity Protection Techniques}},
volume = {112},
year = {2019}
}
@article{Al-Kuwaiti2009,
abstract = {Abstract— Nowadays, there is a wide variety of network benchmarking tools, giving researchers and network administrators many choices to work with. However, this variety tends to difficult the selection process of the appropriate tool. Furthermore, sometimes users are forced to try several tools in order to find the one that calculates a given gauge, so they have to learn how to manipulate different tools and how to interpret obtained results. This paper offers a compilation of currently used network benchmarking tools, with the intention of guiding the selection of one tool over others, by outlining their main features, strengths and weaknesses. Index},
author = {Al-Kuwaiti, M. and Kyriakopoulos, N. and Hussein, S.},
doi = {10.1109/SURV.2009.090208},
file = {:C$\backslash$:/Users/Luke/Downloads/AcomparativeanalysisMAK-NK-SHIEEESurveys2009.pdf:pdf},
issn = {1553877X},
journal = {IEEE Communications Surveys and Tutorials},
keywords = {Dependability,Fault-tolerance,Reliability,Security,Survivability},
number = {2},
pages = {106--124},
title = {{A comparative analysis of network dependability, fault-tolerance, reliability, security, and survivability}},
volume = {11},
year = {2009}
}
@article{Al-Kuwaiti2006,
abstract = {A number of qualitative and quantitative terms are used to describe the performance of what has come to be known as information systems, networks or infrastructures. However, some of these terms either have overlapping meanings or contain ambiguities in their definitions presenting problems to those who attempt a rigorous evaluation of the performance of such systems. The phenomenon arises because the wide range of disciplines covered by the term information technology have developed their own distinct terminologies. This paper presents a systematic approach for determining common and complementary characteristics of five widely-used concepts, dependability, fault-tolerance, reliability, security, and survivability. The approach consists of comparing definitions, attributes, and evaluation measures for each of the five concepts and developing corresponding relations. Removing redundancies and clarifying ambiguities will help the mapping of broad user-specified requirements into objective performance parameters for analyzing and designing information infrastructures},
author = {Al-Kuwaiti, M. and Kyriakopoulos, N. and Hussein, S.},
doi = {10.1109/ICCES.2006.320462},
file = {:C$\backslash$:/Users/Luke/Downloads/Network{\_}Dependability{\_}Fault-tolerance{\_}Reliability{\_}.pdf:pdf},
isbn = {1424402719},
journal = {2006 International Conference on Computer Engineering and Systems, ICCES'06},
number = {December},
pages = {282--287},
title = {{Network dependability, fault-tolerance, reliability, security, survivability: A framework for comparative analysis}},
year = {2006}
}
@article{Blum1995,
author = {Blum, Manuel},
doi = {10.1145/200836.200880},
file = {:C$\backslash$:/Users/Luke/Downloads/p86-blum.pdf:pdf},
journal = {Journal of the ACM},
number = {1},
pages = {269--291},
title = {{Designing programs that check their work}},
url = {http://portal.acm.org/citation.cfm?id=73015},
volume = {42},
year = {1995}
}
@article{Ergun2000,
abstract = {On Labor Day weekend, the highway patrol sets up spot-checks at random points on the freeways with the intention of deterring a large fraction of motorists from driving incorrectly. We explore a very similar idea in the context of program checking to ascertain with minimal overhead that a program output is reasonably correct. Our model of spot-checking requires that the spot-checker must run asymptotically much faster than the combined length of the input and output. We then show that the spot-checking model can be applied to problems in a wide range of areas, including problems regarding graphs, sets, and algebra. In particular, we present spot-checkers for sorting, convex hull, element distinctness, set containment, set equality, total orders, and correctness of group and field operations. All of our spot-checkers are very simple to state and rely on testing that the input and/or output have certain simple properties that depend on very few bits. Our results also give property tests as defined by Rubinfeld and Sudan (1996, SIAM J. Comput. 25, 252-271), Rubinfeld (1994, 'Proc. 35th Foundations of Computer Science,' pp. 288-299), and Goldreich et al. (1998, J. Assoc. Comput. Mach. 45, 653-750).},
author = {Erg{\"{u}}n, Funda and Kannan, Sampath and Kumar, S. Ravi and Rubinfeld, Ronitt and Viswanathan, Mahesh},
doi = {10.1006/jcss.1999.1692},
file = {:C$\backslash$:/Users/Luke/Downloads/EKKRV-spot-checkers.pdf:pdf},
issn = {00220000},
journal = {Journal of Computer and System Sciences},
number = {3},
pages = {717--751},
title = {{Spot-checkers}},
volume = {60},
year = {2000}
}
@article{Rubinfeld1992,
abstract = {We introduce the model of batch checking, which allows one to check the result of a program on many inputs at once. We show that one can batch check programs for linear functions with very little overhead in the running time. {\textcopyright} 1992.},
author = {Rubinfeld, Ronitt},
doi = {10.1016/0020-0190(92)90093-B},
file = {:C$\backslash$:/Users/Luke/Downloads/1-s2.0-002001909290093B-main.pdf:pdf},
issn = {00200190},
journal = {Information Processing Letters},
keywords = {Design of algorithms,program correctness},
number = {2},
pages = {77--80},
title = {{Batch checking with applications to linear functions}},
volume = {42},
year = {1992}
}
@article{USENIXAssociation.2003,
author = {{USENIX Association.}, Andrei and Zaddach, Jonas and Francillon, Aur{\'{e}}lien and Balzarotti, Davide},
file = {:C$\backslash$:/Users/Luke/Downloads/sec14-paper-costin (1).pdf:pdf},
isbn = {9781931971157},
pages = {256},
title = {{Proceedings of the seventeenth Large Installation Systems Administration Conference (LISA XVII) : October 26-31, 2003 San Diego, CA, USA}},
year = {2003}
}
@article{Hada2007,
abstract = {In this paper, we investigate the gap between auxiliary-input zero-knowledge (AIZK) and blackbox-simulation zero-knowledge (BSZK). It is an interestingop en problem whether or not there exists a protocol which achieves AIZK, but not BSZK. We show that the existence of such a protocol is closely related to the existence of secure code obfuscators. A code obfuscator is used to convert a code into an equivalent one that is difficult to reverse-engineer. This paper provides security definitions of code obfuscation. By their definitions, it is easy to see that the existence of the gap implies the existence of a cheating verifier such that it is impossible to obfuscate any code of it. Intuitively, this means that it is possible to reverse-engineer any code of such a cheating verifier. Furthermore, we consider the actual behavior of such a cheating verifier. In order to do so, we focus on two special cases in which the gap exists: (1) there exists a constant round public-coin AIZK interactive argument for a language outside of BPP. (2) there exists a 3-round secret-coinAIZK interactive argument for a language outside of BPP. In the former case, we show that it is impossible to securely obfuscate a code of a cheating verifier behaving as a pseudorandom function. A similar result is shown also in the latter case. Our results imply that any construction of constant round public-coin or 3-round secret-coin AIZK arguments for non-trivial languages essentially requires a computational assumption with a reverse-engineering property.},
author = {Hada, Satoshi},
doi = {10.1007/3-540-44448-3_34},
file = {:C$\backslash$:/Users/Luke/Downloads/10.1.1.302.4062.pdf:pdf},
keywords = {code obfuscation,interactive,interactive argument,proof,reverse-engineering,zero-knowledge},
pages = {443--457},
title = {{Zero-Knowledge and Code Obfuscation}},
year = {2007}
}
@article{Guin2014,
abstract = {As the electronic component supply chain grows more complex due to globalization, with parts coming from a diverse set of suppliers, counterfeit electronics have become a major challenge that calls for immediate solutions. Currently, there are a few standards and programs available that address the testing for such counterfeit parts. However, not enough research has yet addressed the detection and avoidance of all counterfeit partsVrecycled, remarked, overproduced, cloned, out-of-spec/defective, and forged documentationVcurrently infiltrating the electronic component supply chain. Even if they work initially, all these parts may have reduced lifetime and pose reliability risks. In this tutorial, we will provide a review of some of the existing counterfeit detection and avoidance methods. We will also discuss the challenges ahead for implementing these methods, as well as the development of new detection and avoidance mechanisms.},
author = {Guin, Ujjwal and Dimase, Daniel and Tehranipoor, Mohammad},
doi = {10.1007/s10836-013-5430-8},
file = {:C$\backslash$:/Users/Luke/Downloads/JETTASurvey1 (1).pdf:pdf},
issn = {15730727},
journal = {Journal of Electronic Testing: Theory and Applications (JETTA)},
keywords = {Counterfeit ICs,Counterfeit detection and avoidance,Electronic component supply chain},
number = {1},
pages = {9--23},
title = {{Counterfeit integrated circuits: Detection, avoidance, and the challenges ahead}},
volume = {30},
year = {2014}
}
@article{Alkhalifa1999,
abstract = {This paper evaluates the concurrent error detection capabilities$\backslash$nof system-level checks, using fault and error injection. The checks$\backslash$ncomprise application and system level mechanisms to detect control flow$\backslash$nerrors. We propose Enhanced Control-Flow Checking Using Assertions$\backslash$n(ECCA). In ECCA, branch-free intervals (BFI) in a given high or$\backslash$nintermediate level program are identified and the entry and exit points$\backslash$nof the intervals are determined. BFls are then grouped into blocks, the$\backslash$nsize of which is determined through a performance/overhead analysis. The$\backslash$nblocks are then fortified with preinserted assertions. For the high$\backslash$nlevel ECCA, we describe an implementation of ECCA through a preprocessor$\backslash$nthat will automatically insert the necessary assertions into the$\backslash$nprogram. Then, we describe the intermediate implementation possible$\backslash$nthrough modifications made on gee to make it ECCA capable. The fault$\backslash$ndetection capabilities of the checks are evaluated both analytically and$\backslash$nexperimentally. Fault injection experiments are conducted using FERRARI$\backslash$nto determine the fault coverage of the proposed techniques},
author = {Alkhalifa, Z. and Nair, V. S.S. and Krishnamurthy, N. and Abraham, J. A.},
doi = {10.1109/71.774911},
file = {:C$\backslash$:/Users/Luke/Downloads/00774911.pdf:pdf},
issn = {10459219},
journal = {IEEE Transactions on Parallel and Distributed Systems},
number = {6},
pages = {627--641},
title = {{Design and evaluation of system-level checks for on-line control flow error detection}},
volume = {10},
year = {1999}
}
@article{G.G.LiversidgeJ.F.BishopD.A.Czekai1980,
author = {{G.G. Liversidge  J.F. Bishop, D.A. Czekai}, K C Cundy},
doi = {US005485919A},
file = {:C$\backslash$:/Users/Luke/Downloads/US5892899.pdf:pdf},
isbn = {2222222222},
issn = {2222222222},
number = {19},
pages = {62--66},
title = {{United States Patent (19) 54}},
volume = {96},
year = {1980}
}
@article{Naccache2007,
abstract = {This paper introduces a method for tracking different copies of functionally equivalent algorithms containing identification$\backslash$nmarks known to the attacker. Unlike all previous solutions, the new technique does not rely on any marking assumption and$\backslash$nleads to a situation where each copy is either traceable or so severely damaged that it becomes impossible to store in polynomial$\backslash$nspace or run in polynomial time.$\backslash$n$\backslash$nAlthough RSA-related, the construction is particularly applicable to confidential block-ciphers such as SkipJack, RC4, GOST$\backslash$n2814789, GSM A5, COMP128, TIA CAVE or other proprietary executables distributed to potentially distrusted users.},
author = {Naccache, David and Shamir, Adi and Stern, Julien P.},
doi = {10.1007/3-540-49162-7_14},
file = {:C$\backslash$:/Users/Luke/Downloads/download.pdf:pdf},
number = {August 2004},
pages = {188--196},
title = {{How to Copyright a Function?}},
year = {2007}
}
@article{Oh2002,
abstract = {This paper presents a new signature monitoring technique, CFCSS$\backslash$n(control flow checking by software signatures); CFCSS is a pure software$\backslash$nmethod that checks the control flow of a program using assigned$\backslash$nsignatures. An algorithm assigns a unique signature to each node in the$\backslash$nprogram graph and adds instructions for error detection. Signatures are$\backslash$nembedded in the program during compilation time using the constant field$\backslash$nof the instructions and compared with run-time signatures when the$\backslash$nprogram is executed. Another algorithm reduces the code size and$\backslash$nexecution time overhead caused by checking instructions in CFCSS. A$\backslash$n"branching fault injection experiment" was performed with benchmark$\backslash$nprograms. Without CFCSS, an average of 33.7 {\%} of the injected branching$\backslash$nfaults produced undetected incorrect outputs; however, with CFCSS, only$\backslash$n3.1 {\%} of branching faults produced undetected incorrect outputs. Thus it$\backslash$nis possible to increase error detection coverage for control flow errors$\backslash$nby an order of magnitude using CFCSS. The distinctive advantage of CFCSS$\backslash$nover previous signature monitoring techniques is that CFCSS is a pure$\backslash$nsoftware method, i.e., it needs no dedicated hardware such as a watchdog$\backslash$nprocessor for control flow checking. A watchdog task in multitasking$\backslash$nenvironment also needs no extra hardware, but the advantage of CFCSS$\backslash$nover a watchdog task is that CFCSS can be used even when the operating$\backslash$nsystem does not support multitasking},
author = {Oh, Nahmsuk and Shirvani, Philip P. and McCluskey, Edward J.},
doi = {10.1109/24.994926},
file = {:C$\backslash$:/Users/Luke/Downloads/00994926.pdf:pdf},
issn = {00189529},
journal = {IEEE Transactions on Reliability},
keywords = {Assigned signatures,Control flow checking,Fault injection experiments,Signature monitoring,Software error detection},
number = {1},
pages = {111--122},
title = {{Control-flow checking by software signatures}},
volume = {51},
year = {2002}
}
@article{Chen2017,
author = {Chen, Zhi and Shen, Junjie and Nicolau, Alex and Veidenbaum, Alex and Ghalaty, Nahid Farhady and Cammarota, Rosario},
doi = {10.1109/FDTC.2017.10},
file = {:C$\backslash$:/Users/Luke/Downloads/08167711.pdf:pdf},
isbn = {9781538629482},
journal = {Proceedings - 2017 Workshop on Fault Diagnosis and Tolerance in Cryptography, FDTC 2017},
pages = {57--64},
title = {{CAMFAS: A Compiler Approach to Mitigate Fault Attacks via Enhanced SIMDization}},
volume = {2017-Janua},
year = {2017}
}
@phdthesis{Nyberg2018,
author = {Nyberg, Ralph Heinz-erik},
file = {:C$\backslash$:/Users/Luke/Downloads/document (8).pdf:pdf},
school = {Technische Universitat M ¨ unchen},
title = {{New Techniques for Emulating Fault Attacks}},
year = {2018}
}
@article{Yuce2017,
author = {Yuce, Bilgiday and Hsiao, Michael S and Nazhandali, Leyla and Patterson, Cameron D and Yao, Danfeng},
file = {:C$\backslash$:/Users/Luke/Downloads/Yuce{\_}B{\_}D{\_}2018.pdf:pdf},
keywords = {bilgiday yuce,copyright 2018,countermeasures,embedded systems,fault attacks,fault mitigation,fault models,fault simulation},
title = {{Fault Attacks on Embedded Software: New Directions in Modeling, Design, and Mitigation}},
url = {https://vtechworks.lib.vt.edu/bitstream/handle/10919/81824/Yuce{\_}B{\_}D{\_}2018.pdf?sequence=1{\&}isAllowed=y},
year = {2017}
}
@article{Breier2016,
author = {Breier, Jakub},
doi = {10.1109/ARES.2016.4},
file = {:C$\backslash$:/Users/Luke/Downloads/07784607.pdf:pdf},
isbn = {9781509009909},
journal = {Proceedings - 2016 11th International Conference on Availability, Reliability and Security, ARES 2016},
keywords = {Code analysis,Fault attacks,Fault simulator,Instruction set simulator},
pages = {474--479},
publisher = {IEEE},
title = {{On analyzing program behavior under fault injection attacks}},
year = {2016}
}
@article{Yuce2016,
abstract = {Fault attacks are a known serious threat to embedded software security. We propose FAME, a low-cost and flexible approach to defend embedded software against fault attacks. FAME offers a combination of fault detection in hardware and fault response in software. A hardware fault detection unit continuously monitors the system status. When a fault injection is detected, an alarm signal triggers a secure trap mechanism that passes the control to a software trap handler. The trap handler applies a suitable fault response policy, which may include a broad variety of responses such as clearing sensitive data or issuing system-wide alerts. This enables a targeted, fast fault detection as well as an application-dependent, user-defined fault response. FAME requires much lower overhead than traditional countermeasure techniques in software or hardware. We demonstrate a prototype implementation of FAME using a modified LEON3 processor, and we analyze the hardware and software overhead to thwart setup-time violation attacks. The hardware area overhead is 7.4{\%} and 14.2{\%} in the number of LUTs and registers, respectively. The overhead of the software trap handler on top of an AES-128 program is 0.59{\%}--0.71{\%} in footprint and 1.01{\%}--2.35{\%} in performance, depending on the security policy. In contrast, traditional countermeasures that use redundant hardware or software against similar faults have at least double overhead.},
author = {Yuce, Bilgiday and Ghalaty, Nahid F and Deshpande, Chinmay and Patrick, Conor and Nazhandali, Leyla and Schaumont, Patrick},
doi = {10.1145/2948618.2948626},
file = {:C$\backslash$:/Users/Luke/Downloads/a8-yuce.pdf:pdf},
isbn = {978-1-4503-4769-3},
journal = {Proceedings of the Hardware and Architectural Support for Security and Privacy 2016},
keywords = {Embedded Software Security,Fault-attack Aware Microprocessor Extensions},
pages = {8:1----8:8},
title = {{FAME: Fault-attack Aware Microprocessor Extensions for Hardware Fault Detection and Software Fault Response}},
url = {http://doi.acm.org/10.1145/2948618.2948626},
year = {2016}
}
@article{Moro2014a,
abstract = {njection of transient faults can be used as a way to attack embedded systems. On embedded processors such as microcontrollers, several studies showed that such a transient fault injection with glitches or electromagnetic pulses could corrupt either the data loads from the memory or the assembly instructions executed by the circuit. Some countermeasure schemes which rely on temporal redundancy have been proposed to handle this issue. Among them, several schemes add this redundancy at assembly instruction level. In this paper, we perform a practical evaluation for two of those countermeasure schemes by using a pulsed electromagnetic fault injection process on a 32-bit microcontroller. We provide some necessary conditions for an efficient implementation of those countermeasure schemes in practice. We also evaluate their efficiency and highlight their limitations. To the best of our knowledge, no experimental evaluation of the security of such instruction-level countermeasure schemes has been published yet.},
author = {Moro, Nicolas and Heydemann, Karine and Dehbaoui, Amine and Robisson, Bruno and Encrenaz, Emmanuelle},
doi = {10.1109/HST.2014.6855580},
file = {:C$\backslash$:/Users/Luke/Downloads/06855580.pdf:pdf},
isbn = {9781479941148},
journal = {Proceedings of the 2014 IEEE International Symposium on Hardware-Oriented Security and Trust, HOST 2014},
keywords = {assembly,countermeasure,fault injection,instruction skip,microcontroller},
pages = {112--117},
publisher = {IEEE},
title = {{Experimental evaluation of two software countermeasures against fault attacks}},
year = {2014}
}
@article{Holler2015,
abstract = {{\textcopyright} 2015 IEEE.Physical attacks, such as fault attacks, pose a decisive threat for the security of devices in the Internet of Things. An important class of countermeasures for fault attacks is fault tolerant software that is applicable for systems based on COTS hardware. In order to evaluate software countermeasures against fault attacks, fault injection is needed. However, established fault injection approaches require manufactured products or hardware details (e.g. netlists, RTL models), which are not available when using COTS hardware. In this paper, we present a QEMU-based fault injection platform that supports commercial COTS processors that are widely-used in the embedded domain. This framework allows a system-level analysis of software countermeasures by featuring the simulation of high-level hardware faults targeting, for example, memory cells, register cells, or the correct execution of instructions. The framework supports the generation of realistic fault attack scenarios. We illustrate the practicability of the approach by presenting two exemplary use cases.},
author = {Holler, Andrea and Krieg, Armin and Rauter, Tobias and Iber, Johannes and Kreiner, Christian},
doi = {10.1109/DSD.2015.79},
file = {:C$\backslash$:/Users/Luke/Downloads/07302319.pdf:pdf},
isbn = {9781467380355},
journal = {Proceedings - 18th Euromicro Conference on Digital System Design, DSD 2015},
keywords = {COTS,Fault attacks,Fault injection,QEMU,Security},
pages = {530--533},
title = {{QEMU-based fault injection for a system-level analysis of software countermeasures against fault attacks}},
year = {2015}
}
@article{Rauter2015,
abstract = {{\textcopyright} 2015 EDAA. Although software fault prevention techniques improve continually, faults remain in every complex software system. Thus safety-critical embedded systems need mechanisms to tolerate software faults. Typically, these systems use static redundancy to detect hardware faults during operation. However, the reliability of a redundant system not only depends on the reliability of each version, but also on the dissimilarity between them. Thus, researchers have investigated ways to automatically add cost-efficient diversity to software to increase the efficiency of redundancy strategies. One of these automated software diversification methods is diverse compiling, which exploits the diversity introduced by different compilers and different optimization flags. Today, diverse compiling is used to improve the hardware fault tolerance and to avoid common defects from compilers. However, in this paper we show that diverse compiling also enhances the software fault tolerance by increasing the chance of finding defects in the source code of the executed software during runtime. More precisely, the memory is organized differently, when using different compilers and compiler flags. This enhances the chance of detecting memory-related software bugs, such as missing memory initialization, during runtime. Here we experimentally quantify the efficiency of diverse compiling for software fault tolerance and we show that diverse compiling can help to detect up to about 70{\%} of memory-related software bugs.},
author = {Rauter, Tobias and H{\"{o}}ller, Andrea and Kreiner, Christian and Kajtazovic, Nermin and R{\"{o}}mer, Kay},
doi = {10.7873/date.2015.0118},
file = {:C$\backslash$:/Users/Luke/Downloads/p531-holler.pdf:pdf},
isbn = {9783981537048},
pages = {531--536},
title = {{Evaluation of Diverse Compiling for Software-Fault Detection}},
year = {2015}
}
@article{Schuster2017,
abstract = {{\textcopyright} 2017 ACM. Soft errors are a challenging and urging problem in the domain of safety-critical embedded systems. For decades, checking schemes have been investigated and improved to mitigate soft-error effects for the class of control-flow faults, with current industrial standards strongly recommending their use. However, reality looks different: Taking a systems perspective, we implemented four representative Control-Flow Checking (CFC) schemes and put them through their paces in 396 fault-injection campaigns. In contrast to previous work, which typically relied on probability-based vulnerability metrics, we accounted for the influence of memory and time overheads on the fault-space dimensions and applied those in full-scan fault injections. This change in procedure alone severely degraded the perceived effectiveness of CFC. In addition, we expanded the perspective to data-flow faults and their influence on the overall susceptibility, an aspect that so far has been largely ignored. Our results suggest that, without accompanying measures, any improvement regarding control-flow faults is dominated by the increase in data faults caused by the increased attac k surface in terms of memory and runtime overhead. Moreover, CFC performance less depended on the detection capabilities than on general aspects of the concrete binary compilation and execution. In conclusion, incorporating CFC is not as straightforward as often assumed and the vulnerability of systems with hardened control-flow may in many cases even be increased by the schemes themselves.},
author = {Schuster, Simon and Ulbrich, Peter and Stilkerich, Isabella and Dietrich, Christian and Schr{\"{o}}Der-Preikschat, Wolfgang},
doi = {10.1145/3126503},
file = {:C$\backslash$:/Users/Luke/Downloads/a180-schuster.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {5s},
pages = {1--19},
title = {{Demystifying Soft-Error Mitigation by Control-Flow Checking -- A New Perspective on its Effectiveness}},
url = {http://dl.acm.org/citation.cfm?doid=3145508.3126503},
volume = {16},
year = {2017}
}
@article{Moro2014,
abstract = {Fault attacks against embedded circuits enabled to define many new attack paths against secure circuits. Every attack path relies on a specific fault model which defines the type of faults that the attacker can perform. On embedded processors, a fault model consisting in an assembly instruction skip can be very useful for an attacker and has been obtained by using several fault injection means. To avoid this threat, some countermeasure schemes which rely on temporal redundancy have been proposed. Nevertheless, double fault injection in a long enough time interval is practical and can bypass those countermeasure schemes. Some fine-grained countermeasure schemes have also been proposed for specific instructions. However, to the best of our knowledge, no approach that enables to secure a generic assembly program in order to make it fault-tolerant to instruction skip attacks has been formally proven yet. In this paper, we provide a fault-tolerant replacement sequence for almost all the instructions of the Thumb-2 instruction set and provide a formal verification for this fault tolerance. This simple transformation enables to add a reasonably good security level to an embedded program and makes practical fault injection attacks much harder to achieve.},
annote = {Interesting and simple idea, but seems to rely on lots of code duplication (100{\%} - 200{\%} execution / program size overhead)},
archivePrefix = {arXiv},
arxivId = {1402.6461},
author = {Moro, N. and Heydemann, K. and Encrenaz, E. and Robisson, B.},
doi = {10.1007/s13389-014-0077-7},
eprint = {1402.6461},
file = {:C$\backslash$:/Users/Luke/Downloads/2013-679.pdf:pdf},
isbn = {1338901400},
issn = {21908516},
journal = {Journal of Cryptographic Engineering},
keywords = {Countermeasure,Fault attack,Formal verification,Instruction skip,Microcontroller},
number = {3},
pages = {145--156},
title = {{Formal verification of a software countermeasure against instruction skip attacks}},
volume = {4},
year = {2014}
}
@article{Kleber2015,
abstract = {A persistent problem with program execution, despite nu-merous mitigation attempts, is its inherent vulnerability to the injec-tion of malicious code. Equally unsolved is the susceptibility of firmware to reverse engineering, which undermines the manufacturer's code con-fidentiality. We propose an approach that solves both kinds of security problems employing instruction-level code encryption combined with the use of a physical unclonable function (PUF). Our novel Secure Execution PUF-based Processor (SEPP) architecture is designed to minimize the attack surface, as well as performance impact, and requires no significant changes to the development process. This is possible based on a tight integration of a PUF directly into the processor's instruction pipeline. Furthermore, cloud scenarios and distributed embedded systems alike inherently depend on remote execution; our approach supports this, as the secure execution environment needs not to be locally available at the developers site. We implemented an FPGA-based prototype based on the OpenRISC Reference Platform. To assess our results, we performed a security analysis of the processor and evaluated the performance im-pact of the encryption. We show that the attack surface is significantly reduced compared to previous approaches while the performance penalty is at a reasonable factor of about 1.5.},
author = {Kleber, Stephan and Unterstein, Florian and Matousek, Matthias and Kargl, Frank and Slomka, Frank and Hiller, Matthias},
doi = {cr.org/2015/651},
file = {:C$\backslash$:/Users/Luke/Downloads/b20be816f22e1ee171a0260b5f2836f74321 (1).pdf:pdf},
journal = {Cryptology ePrint Archive, Report 2015/651},
keywords = {and matthias hiller 3,encryption,florian unterstein 1,frank kargl 1,frank slomka 2,matthias matousek 1,on,puf-driven instruction level code,stephan kleber 1,ure execution architecture based},
title = {{Secure Execution Architecture based on PUF-driven Instruction Level Code Encryption}},
year = {2015}
}
@article{Theissing2013,
abstract = {Fault tolerant software against fault attacks constitutes an important class of countermeasures for embedded systems. In this work, we implemented and systematically analyzed a comprehensive set of 19 different strategies for software countermeasures with respect to protection effectiveness as well as time and memory efficiency. We evaluated the performance and security of all implementations by fault injections into a microcontroller simulator based on an ARM Cortex-M3. Our results show that some rather simple countermeasures outperform other more sophisticated methods due to their low memory and/or performance overhead. Further, combinations of countermeasures show strong characteristics and can lead to a high fault coverage, while keeping additional resources at a minimum. The results obtained in this study provide developers of secure software for embedded systems with a solid basis to decide on the right type of fault attack countermeasure for their application.},
author = {Theissing, Nikolaus and Merli, Dominik and Smola, Michael and Stumpf, Frederic and Sigl, Georg},
doi = {10.7873/DATE.2013.092},
file = {:C$\backslash$:/Users/Luke/Downloads/06513538.pdf:pdf},
isbn = {9781467350716},
issn = {15301591},
journal = {Design, Automation {\&} Test in Europe Conference {\&} Exhibition (DATE), 2013},
pages = {404--409},
publisher = {IEEE},
title = {{Comprehensive Analysis of Software Countermeasures against Fault Attacks}},
url = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6513538},
year = {2013}
}
@book{Maes2012,
author = {Maes, R},
file = {:C$\backslash$:/Users/Luke/Downloads/7511651339fd505157e016e8a55e44242b2c.pdf:pdf},
isbn = {9789460185618},
keywords = {phd, thesis, dissertation, doctoraat, kuleuven, Ro},
number = {August},
title = {{Physically Unclonable Functions: Constructions, Properties and Applications (Fysisch onkloonbare functies: constructies, eigenschappen en toepassingen)}},
url = {https://lirias.kuleuven.be/handle/123456789/353455},
year = {2012}
}
@article{Drimer2008,
abstract = {Volatile FPGAs, the dominant type of programmable logic devices, are used in space, military, automotive, and consumer electronics applications which require them to operate in a wide range of environments. The continuous growth in both their capability and capacity now requires significant resources to be invested in the designs that are created for them. This has brought increased interest in the security attributes of FPGAs; specifically, how well do they protect the information processed within it, how are designs protected during distribution, and how developers' ownership rights are protected while designs from multiple sources are combined. This survey establishes the foundations for discussing ``FPGA security'', examines a wide range of attacks and defenses along with the current state of industry offerings, and finally, outlines on-going research and latest developments.},
author = {Drimer, Saar},
file = {:C$\backslash$:/Users/Luke/Downloads/fpga{\_}security.pdf:pdf},
journal = {University of Cambridge},
pages = {1--51},
title = {{Volatile FPGA design security – a survey}},
url = {http://www.cl.cam.ac.uk/{~}sd410/papers/fpga{\_}security.pdf},
year = {2008}
}
@inproceedings{Goloubeva2003,
abstract = {Over the last years, an increasing number of safety-critical tasks have been demanded to computer systems. In this paper, a software-based approach for developing safety-critical applications is analyzed. The technique is based on the introduction of additional executable assertions to check the correct execution of the program control flow. By applying the proposed technique, several benchmark applications have been hardened against transient errors. Fault Injection campaigns have been performed to evaluate the fault detection capability of the proposed technique in comparison with state-of-the-art alternative assertion- based methods. Experimental results show that the proposed approach is far more effective than the other considered techniques in terms of fault detection capability, at the cost of a limited increase in memory requirements and in performance overhead.},
author = {Goloubeva, O. and Rebaudengo, M. and {Sonza Reorda}, M. and Violante, M.},
booktitle = {Proceedings. 16th IEEE Symposium on Computer Arithmetic},
doi = {10.1109/DFTVS.2003.1250158},
file = {:C$\backslash$:/Users/Luke/Downloads/01250158.pdf:pdf},
isbn = {0-7695-2042-1},
issn = {0887-2171},
month = {nov},
number = {2},
pages = {581--588},
publisher = {IEEE Comput. Soc},
title = {{Soft-error detection using control flow assertions}},
url = {http://ieeexplore.ieee.org/document/1250158/},
volume = {16},
year = {2003}
}
@inproceedings{Kelly2017,
abstract = {Abstract—Effective software defences against errors created by fault attacks need to anticipate the probable error response of the target micro-controller. The range of errors and their probability of occurrence is referred to as the Fault Model. Software defences are necessarily a compromise between the impact of an error, its likelihood of occurrence, and the cost of the defence in terms of code size and execution time. In this work we first create a fault insertion system and then use it to demonstrate a technique for precisely triggering and capturing individual error responses within a running micro-controller. This enables a more realistic calibration of a micro-controller's fault model. We apply the system to a representative micro-controller and the results show that error insertion is far more predictable than anticipated, and is consistent over a wide range of experimental tolerances. This observation undermines some widely deployed software defences recommended for fault attack protection.},
annote = {Shows that software runtime checking does not necessarity work},
author = {Kelly, Martin S and Mayes, Keith and Walker, John F},
booktitle = {2017 IEEE International Symposium on Hardware Oriented Security and Trust (HOST)},
doi = {10.1109/HST.2017.7951802},
file = {:C$\backslash$:/Users/Luke/Downloads/PID4658763 (1).pdf:pdf},
isbn = {978-1-5386-3929-0},
month = {may},
pages = {79--84},
publisher = {IEEE},
title = {{Characterising a CPU fault attack model via run-time data analysis}},
url = {http://ieeexplore.ieee.org/document/7951802/},
year = {2017}
}
@article{Yuce2016a,
annote = {Breaks software only protections (not including flow analysis)},
author = {Yuce, Bilgiday and Ghalaty, Nahid Farhady and Santapuri, Harika and Deshpande, Chinmay and Patrick, Conor and Schaumont, Patrick},
doi = {10.1109/FDTC.2016.21},
file = {:C$\backslash$:/Users/Luke/Downloads/07774481.pdf:pdf},
isbn = {9781509011087},
journal = {Proceedings - 2016 Workshop on Fault Diagnosis and Tolerance in Cryptography, FDTC 2016},
keywords = {Embedded Software Security,Fault Attacks,Software Countermeasures},
pages = {47--58},
publisher = {IEEE},
title = {{Software Fault Resistance is Futile: Effective Single-Glitch Attacks}},
year = {2016}
}
@article{Collberg2002,
abstract = {We identify three types of attack on the intellectual property contained in software and three corresponding technical defenses. A defense against reverse engineering is obfuscation, a process that renders software unintelligible but still functional. A defense against software piracy is watermarking, a process that makes it possible to determine the origin of software. A defense against tampering is tamper-proofing, so that unauthorized modifications to software (for example, to remove a watermark) will result in nonfunctional code. We briefly survey the available technology for each type of defense.},
annote = {4 Tamper-Proofing is a good section},
author = {Collberg, Christian S. and Thomborson, Clark},
doi = {10.1109/TSE.2002.1027797},
file = {:C$\backslash$:/Users/Luke/Downloads/01027797 (1).pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Intellectual property protection,Obfuscation,Tamper-proofing,Watermarking},
number = {8},
pages = {735--746},
publisher = {IEEE},
title = {{Watermarking, tamper-proofing, and obfuscation - Tools for software protection}},
volume = {28},
year = {2002}
}
@article{Bryant2004,
annote = {No references for "Encryption Wrappers"},
author = {Bryant, Eric D and Atallah, Mikhail J and Stytz, Martin R and Atallah, Mikhail J and Bryant, Eric D and Stytz, Martin R},
file = {:C$\backslash$:/Users/Luke/Downloads/4269b7c378b5a0c955865cf8286896e4bcda (1).pdf:pdf},
journal = {The Journal of Defense Software Engineering},
number = {November},
pages = {12 -- 16},
title = {{A Survey of Anti-Tamper Technologies}},
year = {2004}
}
@inproceedings{Shepherd2016,
abstract = {Notions like security, trust, and privacy are crucial in the digital environment and in the future, with the advent of technologies like the Internet of Things (IoT) and Cyber-Physical Systems (CPS), their importance is only going to increase. Trust has different definitions, some situations rely on real-world relationships between entities while others depend on robust technologies to gain trust after deployment. In this paper we focus on these robust technologies, their evolution in past decades and their scope in the near future. The evolution of robust trust technologies has involved diverse approaches, as a consequence trust is defined, understood and ascertained differently across heterogeneous domains and technologies. In this paper we look at digital trust technologies from the point of view of security and examine how they are making secure computing an attainable reality. The paper also revisits and analyses the Trusted Platform Module (TPM), Secure Elements (SE), Hypervisors and Virtualisation, Intel TXT, Trusted Execution Environments (TEE) like GlobalPlatform TEE, Intel SGX, along with Host Card Emulation, and Encrypted Execution Environment (E3). In our analysis we focus on these technologies and their application to the emerging domains of the IoT and CPS.},
annote = {Breif review into Secure and Trusted Execution, does not mention various other encrypted execution environments. Has a good set of properties},
author = {Shepherd, Carlton and Arfaoui, Ghada and Gurulian, Iakovos and Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem and Sauveron, Damien and Conchon, Emmanuel},
booktitle = {2016 IEEE Trustcom/BigDataSE/ISPA},
doi = {10.1109/TrustCom.2016.0060},
file = {:C$\backslash$:/Users/Luke/Downloads/secure{\_}trusted{\_}execution (1).pdf:pdf},
isbn = {978-1-5090-3205-1},
issn = {2324-9013},
keywords = {Cyber-physical system,Encrypted execution environment,GlobalPlatform,Host card emulation,Intel SGX,Internet of things,Java card,Trust,Trusted computing,Trusted execution environment,Trusted platform module,Trustworthiness},
month = {aug},
pages = {168--177},
publisher = {IEEE},
title = {{Secure and Trusted Execution: Past, Present, and Future - A Critical Review in the Context of the Internet of Things and Cyber-Physical Systems}},
url = {http://ieeexplore.ieee.org/document/7846943/},
year = {2016}
}
@article{Arora2006,
author = {Arora, Divya and Ravi, Srivaths and Raghunathan, Anand and Jha, Niraj K},
doi = {10.1109/TVLSI.2006.887799},
file = {:C$\backslash$:/Users/Luke/Downloads/10.1.1.464.1355 (2).pdf:pdf},
issn = {1063-8210},
journal = {IEEE Transactions on Very Large Scale Integration (VLSI) Systems},
month = {dec},
number = {12},
pages = {1295--1308},
title = {{Hardware-Assisted Run-Time Monitoring for Secure Program Execution on Embedded Processors}},
url = {http://ieeexplore.ieee.org/document/4052340/},
volume = {14},
year = {2006}
}
@article{Wang2016,
abstract = {Critical infrastructure components nowadays use microprocessor-based embedded control systems. It is often infeasible, however, to employ the same level of security measures used in general purpose computing systems, due to the stringent performance and resource constraints of embedded control systems. Furthermore, as software sits atop and relies on the firmware for proper operation, software-level techniques cannot detect malicious behavior of the firmware. In this work, we propose ConFirm, a low-cost technique to detect malicious modifications in the firmware of embedded control systems by measuring the number of low-level hardware events that occur during the execution of the firmware. In order to count these events, ConFirm leverages the Hardware Performance Counters (HPCs), which readily exist in many embedded processors. We evaluate the detection capability and performance overhead of the proposed technique on various types of firmware running on ARM- and PowerPC-based embedded processors. Experimental results demonstrate that ConFirm can detect all the tested modifications with low performance overhead. {\textcopyright} 2015 IEEE.},
annote = {Combination of checkpoint checking and secure boot},
author = {Wang, Xueyang and Konstantinou, Charalambos and Maniatakos, Michail and Karri, Ramesh},
doi = {10.1109/ICCAD.2015.7372617},
file = {:C$\backslash$:/Users/Luke/Downloads/07372617 (2).pdf:pdf},
isbn = {9781467383882},
issn = {1933-7760},
journal = {2015 IEEE/ACM International Conference on Computer-Aided Design, ICCAD 2015},
pages = {544--551},
publisher = {IEEE},
title = {{ConFirm: Detecting firmware modifications in embedded systems using Hardware Performance Counters}},
year = {2016}
}
@inproceedings{Abera2016,
abstract = {Remote attestation is a crucial security service particularly relevant to increasingly popular IoT (and other embedded) devices. It allows a trusted party (verifier) to learn the state of a remote, and potentially malware-infected, device (prover). Most existing approaches are static in nature and only check whether benign software is initially loaded on the prover. However, they are vulnerable to run-time attacks that hijack the application's control or data flow, e.g., via return-oriented programming or data-oriented exploits. As a concrete step towards more comprehensive run-time remote attestation, we present the design and implementation of Control- FLow ATtestation (C-FLAT) that enables remote attestation of an application's control-flow path, without requiring the source code. We describe a full prototype implementation of C-FLAT on Raspberry Pi using its ARM TrustZone hardware security extensions. We evaluate C-FLAT's performance using a real-world embedded (cyber-physical) application, and demonstrate its efficacy against control-flow hijacking attacks.},
address = {New York, New York, USA},
archivePrefix = {arXiv},
arxivId = {1605.07763},
author = {Abera, Tigist and Asokan, N. and Davi, Lucas and Ekberg, Jan-Erik and Nyman, Thomas and Paverd, Andrew and Sadeghi, Ahmad-Reza and Tsudik, Gene},
booktitle = {Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security - CCS'16},
doi = {10.1145/2976749.2978358},
eprint = {1605.07763},
file = {:C$\backslash$:/Users/Luke/Downloads/1605.07763 (1).pdf:pdf},
isbn = {9781450341394},
issn = {15437221},
keywords = {control-flow attacks,embedded system security,remote attestation},
pages = {743--754},
pmid = {23776192},
publisher = {ACM Press},
title = {{C-FLAT: Control-Flow Attestation for Embedded Systems Software}},
url = {http://arxiv.org/abs/1605.07763 http://dl.acm.org/citation.cfm?doid=2976749.2978358},
year = {2016}
}
@incollection{Werner2016,
abstract = {Massively deploying RFID systems while preserving people's privacy and data integrity is a major security challenge of the$\backslash$r coming years. Up to now, it was commonly believed that, due to the very limited computational resources of RFID tags, only$\backslash$r ad hoc methods could be used to address this problem. Unfortunately, not only those methods generally provide a weak level$\backslash$r of security and practicality, but they also require to revise the synopsis of communications between the tag and the reader.$\backslash$r In this paper, we give evidence that highly secure solutions can be used in the RFID environment, without substantially impacting$\backslash$r the current communication protocols, by adequately choosing and combining low-cost cryptographic algorithms. The main ingredients$\backslash$r of our basic scheme are a probabilistic (symmetric or asymmetric) encryption function, e.g. AES, and a coupon-based signature$\backslash$r function, e.g. GPS. We also propose a dedicated method allowing the tag to authenticate the reader, which is of independent$\backslash$r interest. On the whole, this leads to a privacy-preserving protocol well suited for RFID tags, which is very flexible in the$\backslash$r sense that each reader can read and process all and only all the data it is authorized to.},
archivePrefix = {arXiv},
arxivId = {9780201398298},
author = {Werner, Mario and Wenger, Erich and Mangard, Stefan},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-31271-2_10},
eprint = {9780201398298},
file = {:C$\backslash$:/Users/Luke/Downloads/Werner2016{\_}Chapter{\_}ProtectingTheControlFlowOfEmbe (1).pdf:pdf},
isbn = {978-3-642-37287-2},
issn = {03029743},
keywords = {control-flow integrity,countermeasures,fault attacks},
pages = {161--176},
pmid = {4520227},
title = {{Protecting the Control Flow of Embedded Processors against Fault Attacks}},
url = {http://link.springer.com/10.1007/978-3-319-31271-2{\_}10},
volume = {9514},
year = {2016}
}
@article{Simpson2006,
abstract = {Many Field-Programmable Gate Array (FPGA) based systems uti-lize third-party intellectual property (IP) in their development. When they are deployed in non-networked environments, the question raises how this IP can be protected against non-authorized use. We de-scribe an offline authentication scheme for IP modules. The scheme implements mutual authentication of the IP modules and the hard-ware platform, and enables us to provide authentication and integrity assurances to both the system developer and IP provider. Compared to the Trusted Computing Platform's approach to hardware, software authentication, our solution is more lightweight and tightly integrates with existing FPGA security features. We are able to demonstrate an implementation of the authentication scheme that requires a symmet-ric cipher and a Physically Unclonable Function (PUF). In addition to the low hardware requirements, our implementation does not require any on-chip, non-volatile storage.},
author = {Simpson, Eric and Schaumont, Patrick},
file = {:C$\backslash$:/Users/Luke/Downloads/Simpson-Schaumont2006{\_}Chapter{\_}OfflineHardwareSoftwareAuthent (3).pdf:pdf},
journal = {Cryptographic Hardware and Embedded Systems (CHES)},
pages = {1--13},
title = {{Offline HW / SW Authentication for Reconfigurable Platforms}},
year = {2006}
}
@incollection{Kohnhauser2015,
abstract = {Abstract. In recent years, low-end embedded devices have been used increasingly in various scenarios, ranging from consumer electronics to industrial equipment. However, this evolution made embedded devices profitable targets for software piracy and software manipulation. Aggra- vating this situation, low-end embedded devices typically lack secure hardware to effectively protect against such attacks. In this work, we present a novel software protection scheme, which is particularly suited for already deployed low-end embedded devices without secure hardware. Our approach combines techniques based on self-checksumming code with Physically Unclonable Functions (PUFs) to establish a hardware- assisted software protection. In this way, we can tie the execution of a software instance to a specific device and protect its program code against manipulations. We show that our software protection scheme offers a high level of security against static adversaries and demonstrate that dynamic adversaries require considerable resources to perform a successful attack. To explore the feasibility of our solution, we implemented the protection scheme on an ARM-based low-end commodity microcontroller. A further performance evaluation shows that the implemented solution exhibits a fair overhead of ten percent.},
archivePrefix = {arXiv},
arxivId = {arXiv:1506.07739v2},
author = {Kohnh{\"{a}}user, Florian and Schaller, Andr{\'{e}} and Katzenbeisser, Stefan},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-22846-4_1},
eprint = {arXiv:1506.07739v2},
file = {:C$\backslash$:/Users/Luke/Downloads/Kohnh{\"{a}}user2015{\_}Chapter{\_}PUF-BasedSoftwareProtectionFor (1).pdf:pdf},
isbn = {9783319228457},
issn = {16113349},
pages = {3--21},
title = {{PUF-Based Software Protection for Low-End Embedded Devices}},
url = {http://link.springer.com/10.1007/978-3-319-22846-4{\_}1},
volume = {9229},
year = {2015}
}
@article{Gora2010,
abstract = {Software intellectual property (SWIP) is a critical component of increasingly complex field programmable gate arrays (FPGA)-based system-on-chip (SOC) designs. As a result, developers want to ensure that their Software Intellectual Property (SWIP) is protected from being exposed to or tampered with by unauthorized parties. By restricting the execution of SWIP to a single trusted FPGA platform, SWIP binding addresses developers' concerns about maintaining control of their intellectual property and the market position it affords. This work proposes a novel design flow for SWIP binding on a commodity FPGA platform lacking specialized hardcore security facilities. We accomplish this by leveraging the qualities of a Physical Unclonable Function (PUF) and a tight integration of hardware and software security features. A prototype implementation demonstrates our design flow's ability to successfully protect software by encryption using a 128 bit FPGA-unique key extracted from a PUF. Based on this proof of concept, a solution to perform secure remote software updates, a common challenge in embedded systems, is proposed to showcase the practicality and flexibility of the design flow.},
author = {Gora, Michael A. and Maiti, Abhranil and Schaumont, Patrick},
doi = {10.1109/TII.2010.2068303},
file = {:C$\backslash$:/Users/Luke/Downloads/05196217 (2).pdf:pdf},
isbn = {9781424441105},
issn = {15513203},
journal = {IEEE Transactions on Industrial Informatics},
keywords = {Design flow,field programmable gate arrays (FPGA),firmware,intellectual property,physical unclonable function,secure embedded systems,security,software binding},
number = {4},
pages = {719--728},
pmid = {14637044},
publisher = {IEEE},
title = {{A flexible design flow for software IP binding in FPGA}},
volume = {6},
year = {2010}
}
@article{Schaller2014,
abstract = {This paper presents a lightweight anti-counterfeiting solution using intrinsic Physically Unclonable Functions (PUFs), which are already embedded in most commodity hardware platforms. The presented solution is particularly suitable for low-end computing devices without on-board security features. Our anti-counterfeiting approach is based on extracting a unique fingerprint for individual devices exploiting inherent PUF characteristics from the on-chip static random-access memory (SRAM), which in turn allows to bind software to a particular hardware platform. Our solution does not require additional hardware, making it flexible as well as cost efficient. In a first step, we statistically analyze the characteristics of the intrinsic PUF instances found in two device types, both based on a widely used ARM Cortex-M microcontroller. We show that the quality of the PUF characteristics is almost ideal. Subsequently, we propose a security architecture to protect the platform's firmware by using a modified boot loader. In a proof of concept, we embed our solution on a state-of-the-art commodity system-on-a-chip platform equipped with an MCU similar to the ones previously analyzed. {\textcopyright} 2014 Springer International Publishing.},
author = {Schaller, Andr{\'{e}} and Arul, Tolga and {Van Der Leest}, Vincent and Katzenbeisser, Stefan},
doi = {10.1007/978-3-319-08593-7_6},
file = {:C$\backslash$:/Users/Luke/Downloads/Schaller2014{\_}Chapter{\_}LightweightAnti-counterfeiting (2).pdf:pdf},
isbn = {9783319085920},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {83--100},
title = {{Lightweight anti-counterfeiting solution for low-end commodity hardware using inherent PUFs}},
volume = {8564 LNCS},
year = {2014}
}
@inproceedings{Miremadi,
author = {Miremadi, G. and Harlsson, J. and Gunneflo, U. and Torin, J.},
booktitle = {[1992] Digest of Papers. FTCS-22: The Twenty-Second International Symposium on Fault-Tolerant Computing},
doi = {10.1109/FTCS.1992.243568},
file = {:C$\backslash$:/Users/Luke/Downloads/00243568.pdf:pdf},
isbn = {0-8186-2875-8},
pages = {328--335},
publisher = {IEEE},
title = {{Two software techniques for on-line error detection}},
url = {http://ieeexplore.ieee.org/document/243568/}
}
@article{Lee2016,
abstract = {Embedded systems are small scale computing devices that are increasingly located in more of the items we use and own. The number of embedded systems in the world is increasing dramatically as the “internet of things” concept becomes more prevalent in the market. The value of the market for embedded systems is predicted to increase to being worth trillions of dollars by 2020. With great value in the embedded system market, there is a need for preventing unauthorised firmware tampering or product counterfeiting. Here is presen- ted a technique for binding software to hardware instances that uses hardware intrinsic security properties of the devices being protected. The proposed technique provides assurance to manufacturers that only they can perform their hardware and software binding and create their products. Also presen- ted is an FPGA implementation of the described scheme that binds the hardware and software together with only a 6.7{\%} increase in execution time. Thus, making it difficult for an attacker to either counterfeit the device or extract the (software) Intellectual Property. Keywords},
author = {Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem},
doi = {10.1145/2899015.2899029},
file = {:C$\backslash$:/Users/Luke/Downloads/cpss24BindingHardwareAndSoftware{\_}open{\_}access (2).pdf:pdf},
isbn = {9781450342889},
journal = {Proceedings of the 2nd ACM International Workshop on Cyber-Physical System Security - CPSS '16},
keywords = {binding,counterfeiting,firm-,hardware,intrinsic,modification,puf,security,software,ware},
pages = {70--81},
title = {{Binding Hardware and Software to Prevent Firmware Modification and Device Counterfeiting}},
url = {http://dl.acm.org/citation.cfm?doid=2899015.2899029},
year = {2016}
}
@article{Serpanos2018,
abstract = {Embedded systems security is a significant requirement in emerging environments, considering the increasing deployment of embedded systems in several application domains. The large number of deployed embedded systems, their limited resources and their increasing complexity render systems vulnerable to an increasing number of threats. Additionally, the involvement of sensitive, often private, information and the expectation for safe and dependable embedded platforms lead to strong security requirements, even legal ones, which require new technologies for their provision. In this article, we provide an overview of embedded security issues, used methods and technologies, identifying important challenges in this emerging field.},
author = {Serpanos, Dimitrios N. and Voyiatzis, Artemios G.},
doi = {10.1145/2435227.2435262},
file = {:C$\backslash$:/Users/Luke/Downloads/a66-serpanos (1).pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {1s},
pages = {1--10},
title = {{Security challenges in embedded systems}},
volume = {12},
year = {2018}
}
