@incollection{Blomer2010,
abstract = {In this paper we describe several,fault attacks on the Advanced Encryption Standard (AES). First, using optical/eddy current fault induction attacks as recently publicly presented by Skorobogatov, Anderson and Quisquater, Samyde SA,QS, we-present an implementation independent fault attack on AES. This attack is able to determine the complete 128-bit secret key of a sealed tamper-proof smart-card by generating 128 faulty cipher texts. Second, we present several implementation-dependent fault attacks on AES. These attacks rely on the observation that due to the AES's known timing analysis vulnerability (as pointed out by Koeune and Quisquater KQ), any implementation of the AES must ensure a data independent timing behavior for the so called AES's xtime operation. We present fault attacks on AES based on various timing analysis resistant implementations of the xtime-operation. Our strongest attack in this direction uses a very liberal fault model and requires only 256 faulty encryptions to determine a 128-bit key.},
author = {Bl{\"{o}}mer, Johannes and Seifert, Jean-Pierre},
doi = {10.1007/978-3-540-45126-6_12},
file = {:D$\backslash$:/Downloads/Bl{\"{o}}mer-Seifert2003{\_}Chapter{\_}FaultBasedCryptanalysisOfTheAd.pdf:pdf},
keywords = {aes,fault attacks,implementation issues,secure bank-},
pages = {162--181},
title = {{Fault Based Cryptanalysis of the Advanced Encryption Standard (AES)}},
url = {http://link.springer.com/10.1007/978-3-540-45126-6{\_}12},
year = {2003}
}
@article{Al-Kuwaiti2006,
abstract = {A number of qualitative and quantitative terms are used to describe the performance of what has come to be known as information systems, networks or infrastructures. However, some of these terms either have overlapping meanings or contain ambiguities in their definitions presenting problems to those who attempt a rigorous evaluation of the performance of such systems. The phenomenon arises because the wide range of disciplines covered by the term information technology have developed their own distinct terminologies. This paper presents a systematic approach for determining common and complementary characteristics of five widely-used concepts, dependability, fault-tolerance, reliability, security, and survivability. The approach consists of comparing definitions, attributes, and evaluation measures for each of the five concepts and developing corresponding relations. Removing redundancies and clarifying ambiguities will help the mapping of broad user-specified requirements into objective performance parameters for analyzing and designing information infrastructures},
author = {Al-Kuwaiti, M. and Kyriakopoulos, N. and Hussein, S.},
doi = {10.1109/ICCES.2006.320462},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Al-Kuwaiti, Kyriakopoulos, Hussein - 2006 - Network dependability, fault-tolerance, reliability, security, survivability A framework for.pdf:pdf},
isbn = {1424402719},
journal = {2006 International Conference on Computer Engineering and Systems, ICCES'06},
number = {December},
pages = {282--287},
title = {{Network dependability, fault-tolerance, reliability, security, survivability: A framework for comparative analysis}},
year = {2006}
}
@article{Arora2006,
author = {Arora, Divya and Ravi, Srivaths and Raghunathan, Anand and Jha, Niraj K},
doi = {10.1109/TVLSI.2006.887799},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Arora et al. - 2006 - Hardware-Assisted Run-Time Monitoring for Secure Program Execution on Embedded Processors.pdf:pdf},
issn = {1063-8210},
journal = {IEEE Transactions on Very Large Scale Integration (VLSI) Systems},
month = {dec},
number = {12},
pages = {1295--1308},
title = {{Hardware-Assisted Run-Time Monitoring for Secure Program Execution on Embedded Processors}},
url = {http://ieeexplore.ieee.org/document/4052340/},
volume = {14},
year = {2006}
}
@article{Srivastava1994,
abstract = {ATOM (Analysis Tools with OM) is a single framework for building a wide range of customized program analysis tools. It provides the common infrastructure present in all code-instrumenting tools; this is the difficult and time-consuming part. The user simply defines the tool-specific details in instrumentation and analysis routines. Building a basic block counting tool like Pixie with ATOM requires only a page of code.ATOM, using OM link-time technology, organizes the final executable such that the application program and user's analysis routines run in the same address space. Information is directly passed from the application program to the analysis routines through simple procedure calls instead of inter-process communication or files on disk. ATOM takes care that analysis routines do not interfere with the program's execution, and precise information about the program is presented to the analysis routines at all times. ATOM uses no simulation or interpretation.ATOM has been implemented on the Alpha AXP under OSF/1. It is efficient and has been used to build a diverse set of tools for basic block counting, profiling, dynamic memory recording, instruction and data cache simulation, pipeline simulation, evaluating branch prediction, and instruction scheduling.$\backslash$n$\backslash$n},
author = {Srivastava, Amitabh and Eustace, Alan},
doi = {10.1145/773473.178260},
file = {:D$\backslash$:/Downloads/srivastava94atom.pdf:pdf},
isbn = {0-89791-662-X},
issn = {03621340},
journal = {WRL Research Report (ACM SIGPLAN Notices)},
number = {6},
pages = {196--205},
title = {{ATOM: a system for building customized program analysis tools}},
url = {http://dl.acm.org/citation.cfm?id=773473.178260},
volume = {29},
year = {1994}
}
@article{Al-Kuwaiti2009,
abstract = {Abstract— Nowadays, there is a wide variety of network benchmarking tools, giving researchers and network administrators many choices to work with. However, this variety tends to difficult the selection process of the appropriate tool. Furthermore, sometimes users are forced to try several tools in order to find the one that calculates a given gauge, so they have to learn how to manipulate different tools and how to interpret obtained results. This paper offers a compilation of currently used network benchmarking tools, with the intention of guiding the selection of one tool over others, by outlining their main features, strengths and weaknesses. Index},
author = {Al-Kuwaiti, M. and Kyriakopoulos, N. and Hussein, S.},
doi = {10.1109/SURV.2009.090208},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Al-Kuwaiti, Kyriakopoulos, Hussein - 2009 - A comparative analysis of network dependability, fault-tolerance, reliability, security, and.pdf:pdf},
issn = {1553877X},
journal = {IEEE Communications Surveys and Tutorials},
keywords = {Dependability,Fault-tolerance,Reliability,Security,Survivability},
number = {2},
pages = {106--124},
title = {{A comparative analysis of network dependability, fault-tolerance, reliability, security, and survivability}},
volume = {11},
year = {2009}
}
@article{Dijk2013,
abstract = {This paper investigates secure ways to interact with tamper-resistant hardware leaking a strictly bounded amount of information. Architectural support for the interaction mechanisms is studied and performance implications are evaluated. The interaction mechanisms are built on top of a recently-proposed secure processor Ascend[ascend-stc12]. Ascend is chosen because unlike other tamper-resistant hardware systems, Ascend completely obfuscates pin traffic through the use of Oblivious RAM (ORAM) and periodic ORAM accesses. However, the original Ascend proposal, with the exception of main memory, can only communicate with the outside world at the beginning or end of program execution; no intermediate information transfer is allowed. Our system, Stream-Ascend, is an extension of Ascend that enables intermediate interaction with the outside world. Stream-Ascend significantly improves the generality and efficiency of Ascend in supporting many applications that fit into a streaming model, while maintaining the same security level.Simulation results show that with smart scheduling algorithms, the performance overhead of Stream-Ascend relative to an insecure and idealized baseline processor is only 24.5{\%}, 0.7{\%}, and 3.9{\%} for a set of streaming benchmarks in a large dataset processing application. Stream-Ascend is able to achieve a very high security level with small overheads for a large class of applications. {\textcopyright} 2013 ACM.},
author = {van Dijk, Marten and Yu, Xiangyao and Ren, Ling and Fletcher, Christopher W. and Devadas, Srinivas},
doi = {10.1145/2517488.2517498},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Dijk et al. - 2013 - Generalized external interaction with tamper-resistant hardware with bounded information leakage.pdf:pdf},
isbn = {9781450324908},
keywords = {ascend,interaction,pin traffic,tamper-resistant hardware},
pages = {23--34},
title = {{Generalized external interaction with tamper-resistant hardware with bounded information leakage}},
year = {2013}
}
@inproceedings{Kelly2017,
abstract = {Abstract—Effective software defences against errors created by fault attacks need to anticipate the probable error response of the target micro-controller. The range of errors and their probability of occurrence is referred to as the Fault Model. Software defences are necessarily a compromise between the impact of an error, its likelihood of occurrence, and the cost of the defence in terms of code size and execution time. In this work we first create a fault insertion system and then use it to demonstrate a technique for precisely triggering and capturing individual error responses within a running micro-controller. This enables a more realistic calibration of a micro-controller's fault model. We apply the system to a representative micro-controller and the results show that error insertion is far more predictable than anticipated, and is consistent over a wide range of experimental tolerances. This observation undermines some widely deployed software defences recommended for fault attack protection.},
annote = {Shows that software runtime checking does not necessarity work},
author = {Kelly, Martin S and Mayes, Keith and Walker, John F},
booktitle = {2017 IEEE International Symposium on Hardware Oriented Security and Trust (HOST)},
doi = {10.1109/HST.2017.7951802},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kelly, Mayes, Walker - 2017 - Characterising a CPU fault attack model via run-time data analysis.pdf:pdf},
isbn = {978-1-5386-3929-0},
month = {may},
pages = {79--84},
publisher = {IEEE},
title = {{Characterising a CPU fault attack model via run-time data analysis}},
url = {http://ieeexplore.ieee.org/document/7951802/},
year = {2017}
}
@article{Feng2003,
abstract = {{\textcopyright} 2003 IEEE. The call stack of a program execution can be a very good information source for intrusion detection. There is no prior work on dynamically extracting information from the call stack and effectively using it to detect exploits. In this paper we propose a new method to do anomaly detection using call stack information. The basic idea is to extract return addresses from the call stack, and generate an abstract execution path between two program execution points. Experiments show that our method can detect some attacks that cannot be detected by other approaches, while its convergence and false positive performance is comparable to or better than the other approaches. We compare our method with other approaches by analyzing their underlying principles and thus achieve a better characterization of their performance, in particular on what and why attacks will be missed by the various approaches.},
author = {Feng, H. H. and Kolesnikov, O. M. and Fogla, P. and Lee, W. and Gong, Weibo},
doi = {10.1109/SECPRI.2003.1199328},
file = {:D$\backslash$:/Downloads/01199328.pdf:pdf},
isbn = {0769519407},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {62--75},
publisher = {IEEE},
title = {{Anomaly detection using call stack information}},
volume = {2003-Janua},
year = {2003}
}
@article{G.G.LiversidgeJ.F.BishopD.A.Czekai1980,
author = {{G.G. Liversidge  J.F. Bishop, D.A. Czekai}, K C Cundy},
doi = {US005485919A},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/G.G. Liversidge J.F. Bishop, D.A. Czekai - 1980 - United States Patent (19) 54.pdf:pdf},
isbn = {2222222222},
issn = {2222222222},
number = {19},
pages = {62--66},
title = {{United States Patent (19) 54}},
volume = {96},
year = {1980}
}
@incollection{Fang2012,
abstract = {Mobile phone use – and mobile phone piracy – have increased dramatically during the last decade. Because of the profits that can be made, more than four hundred pirated brands of mobile phones are available in China. These pirated phones, referred to as “Shanzhai phones,” are often used by criminals because they are inexpensive and easy to obtain. However, the variety of pirated phones and the absence of documentation hinder the forensic analysis of these phones. This paper provides key details about the storage of the phonebook and call records in popular MediaTek Shanzhai mobile phones. This information can help investigators retrieve deleted call records and assist them in reconstructing the sequence of user activities.},
author = {Fang, Junbin and Jiang, Zoe and Chow, Kam-pui and Yiu, Siu-ming and Hui, Lucas and Zhou, Gang and He, Mengfei and Tang, Yanbin},
doi = {10.1007/978-3-642-33962-2_9},
file = {:D$\backslash$:/Downloads/Fang2012{\_}Chapter{\_}ForensicAnalysisOfPiratedChine.pdf:pdf},
isbn = {978-3-642-33962-2},
keywords = {chinese shanzhai phones,deleted data,forensic analysis,phonebook},
pages = {129--142},
title = {{Forensic Analysis of Pirated Chinese Shanzhai Mobile Phones}},
url = {http://link.springer.com/10.1007/978-3-642-33962-2{\_}9},
year = {2012}
}
@article{Owusu2013,
abstract = {We present OASIS, a CPU instruction set extension for ex- ternally verifiable initiation, execution, and termination of an isolated execution environment with a trusted computing base consisting solely of the CPU. OASIS leverages the hard- ware components available on commodity CPUs to achieve a low-cost, low-overhead design.},
author = {Owusu, Emmanuel and Guajardo, Jorge and Mccune, Jonathan M. and Newsome, Jim and Perrig, Adrian and Vasudevan, Amit},
doi = {10.1145/2508859.2516678},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Owusu et al. - 2013 - OASIS On Achieving a Sanctuary for Integrity and Secrecy on Untrusted Platforms.pdf:pdf},
isbn = {9781450324779},
issn = {15437221},
journal = {Proceedings of the 2013 ACM SIGSAC conference on Computer and communications security (CCS'13)},
keywords = {instruction set extension,remote attestation,secure execution},
number = {i},
pages = {13--24},
title = {{OASIS: On Achieving a Sanctuary for Integrity and Secrecy on Untrusted Platforms}},
year = {2013}
}
@article{Breeuwsma2007,
abstract = {Current forensic tools for examination of embedded systems like mobile phones and PDAs mostly perform data extraction on a logical level and do not consider the type of storage media during data analysis. This paper suggests a low level approach for the forensic examination of flash memories and describes three low-level data acquisition methods for making full memory copies of flash memory devices. Results are presented of a file system study in which USB memory sticks from 45 different make and models were used. For different mobile phones is shown how full memory copies of their flash memories can be made and which steps are needed to translate the extracted data into a format that can be understood by common forensic media analysis tools. Artifacts, caused by flash specific operations like block erasing and wear leveling, are discussed and directions are given for enhanced data recovery and analysis on data originating from flash memory.},
author = {Breeuwsma, Marcel and Jongh, Martien De},
file = {:D$\backslash$:/Downloads/SSDDFJ{\_}V1{\_}1{\_}Breeuwsma{\_}et{\_}al.pdf:pdf},
journal = {Small Scale Digital Device Forensics Journal},
keywords = {embedded systems, flash memory, physical analysis,},
number = {1},
pages = {1--17},
title = {{Forensic data recovery from flash memory}},
volume = {1},
year = {2007}
}
@incollection{Werner2016,
abstract = {Massively deploying RFID systems while preserving people's privacy and data integrity is a major security challenge of the$\backslash$r coming years. Up to now, it was commonly believed that, due to the very limited computational resources of RFID tags, only$\backslash$r ad hoc methods could be used to address this problem. Unfortunately, not only those methods generally provide a weak level$\backslash$r of security and practicality, but they also require to revise the synopsis of communications between the tag and the reader.$\backslash$r In this paper, we give evidence that highly secure solutions can be used in the RFID environment, without substantially impacting$\backslash$r the current communication protocols, by adequately choosing and combining low-cost cryptographic algorithms. The main ingredients$\backslash$r of our basic scheme are a probabilistic (symmetric or asymmetric) encryption function, e.g. AES, and a coupon-based signature$\backslash$r function, e.g. GPS. We also propose a dedicated method allowing the tag to authenticate the reader, which is of independent$\backslash$r interest. On the whole, this leads to a privacy-preserving protocol well suited for RFID tags, which is very flexible in the$\backslash$r sense that each reader can read and process all and only all the data it is authorized to.},
archivePrefix = {arXiv},
arxivId = {9780201398298},
author = {Werner, Mario and Wenger, Erich and Mangard, Stefan},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-31271-2_10},
eprint = {9780201398298},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Werner, Wenger, Mangard - 2016 - Protecting the Control Flow of Embedded Processors against Fault Attacks.pdf:pdf},
isbn = {978-3-642-37287-2},
issn = {03029743},
keywords = {control-flow integrity,countermeasures,fault attacks},
pages = {161--176},
pmid = {4520227},
title = {{Protecting the Control Flow of Embedded Processors against Fault Attacks}},
url = {http://link.springer.com/10.1007/978-3-319-31271-2{\_}10},
volume = {9514},
year = {2016}
}
@article{Kommerling1999,
abstract = {We describe techniques for extracting protected software and data from smartcard processors. This includes manual microprobing, laser cutting, fo- cused ion-beam manipulation, glitch attacks, and power analysis. Many of these methods have already been used to compromise widely-fielded conditional- access systems, and current smartcards offer little protection against them. We give examples of low- cost protection concepts thatmake such attacks con- siderably more difficult.},
author = {K{\"{o}}mmerling, Oliver and Kuhn, Markus G},
file = {:D$\backslash$:/Downloads/sc99-tamper.pdf:pdf},
isbn = {1880446340},
journal = {USENIX Workshop on Smartcard Technology},
pages = {9--20},
title = {{Design Principles for Tamper-Resistant Smartcard Processors}},
year = {1999}
}
@article{Yuce2017,
author = {Yuce, Bilgiday and Hsiao, Michael S and Nazhandali, Leyla and Patterson, Cameron D and Yao, Danfeng},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yuce et al. - 2017 - Fault Attacks on Embedded Software New Directions in Modeling, Design, and Mitigation.pdf:pdf},
keywords = {bilgiday yuce,copyright 2018,countermeasures,embedded systems,fault attacks,fault mitigation,fault models,fault simulation},
title = {{Fault Attacks on Embedded Software: New Directions in Modeling, Design, and Mitigation}},
url = {https://vtechworks.lib.vt.edu/bitstream/handle/10919/81824/Yuce{\_}B{\_}D{\_}2018.pdf?sequence=1{\&}isAllowed=y},
year = {2017}
}
@article{Breier2016,
author = {Breier, Jakub},
doi = {10.1109/ARES.2016.4},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Breier - 2016 - On analyzing program behavior under fault injection attacks.pdf:pdf},
isbn = {9781509009909},
journal = {Proceedings - 2016 11th International Conference on Availability, Reliability and Security, ARES 2016},
keywords = {Code analysis,Fault attacks,Fault simulator,Instruction set simulator},
pages = {474--479},
publisher = {IEEE},
title = {{On analyzing program behavior under fault injection attacks}},
year = {2016}
}
@article{Sharma2012,
author = {Sharma, Ankur},
file = {:D$\backslash$:/Downloads/01402092.pdf:pdf},
isbn = {076952298X},
title = {{SoftWare Implemented Fault Tolerance ( SWIFT )}},
year = {2012}
}
@article{Rubinfeld1992,
abstract = {We introduce the model of batch checking, which allows one to check the result of a program on many inputs at once. We show that one can batch check programs for linear functions with very little overhead in the running time. {\textcopyright} 1992.},
author = {Rubinfeld, Ronitt},
doi = {10.1016/0020-0190(92)90093-B},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Rubinfeld - 1992 - Batch checking with applications to linear functions.pdf:pdf},
issn = {00200190},
journal = {Information Processing Letters},
keywords = {Design of algorithms,program correctness},
number = {2},
pages = {77--80},
title = {{Batch checking with applications to linear functions}},
volume = {42},
year = {1992}
}
@article{Drimer2008,
abstract = {Volatile FPGAs, the dominant type of programmable logic devices, are used in space, military, automotive, and consumer electronics applications which require them to operate in a wide range of environments. The continuous growth in both their capability and capacity now requires significant resources to be invested in the designs that are created for them. This has brought increased interest in the security attributes of FPGAs; specifically, how well do they protect the information processed within it, how are designs protected during distribution, and how developers' ownership rights are protected while designs from multiple sources are combined. This survey establishes the foundations for discussing ``FPGA security'', examines a wide range of attacks and defenses along with the current state of industry offerings, and finally, outlines on-going research and latest developments.},
author = {Drimer, Saar},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Drimer - 2008 - Volatile FPGA design security – a survey.pdf:pdf},
journal = {University of Cambridge},
pages = {1--51},
title = {{Volatile FPGA design security – a survey}},
url = {http://www.cl.cam.ac.uk/{~}sd410/papers/fpga{\_}security.pdf},
year = {2008}
}
@inproceedings{Chielle2015,
abstract = {{\textcopyright} 1963-2012 IEEE. Software-based techniques offer several advantages to increase the reliability of processor-based systems at very low cost, but they cause performance degradation and an increase of the code size. To meet constraints in performance and memory, we propose SETA, a new control-flow software-only technique that uses assertions to detect errors affecting the program flow. SETA is an independent technique, but it was conceived to work together with previously proposed data-flow techniques that aim at reducing performance and memory overheads. Thus, SETA is combined with such data-flow techniques and submitted to a fault injection campaign. Simulation and neutron induced SEE tests show high fault coverage at performance and memory overheads inferior to the state-of-the-art.},
author = {Chielle, Eduardo and Rodrigues, Gennaro S. and Kastensmidt, Fernanda L. and Cuenca-Asensi, Sergio and Tambara, Lucas A. and Rech, Paolo and Quinn, Heather},
booktitle = {IEEE Transactions on Nuclear Science},
doi = {10.1109/TNS.2015.2484842},
issn = {00189499},
number = {6},
title = {{S-SETA: Selective Software-Only Error-Detection Technique Using Assertions}},
volume = {62},
year = {2015}
}
@article{Schaller2014,
abstract = {This paper presents a lightweight anti-counterfeiting solution using intrinsic Physically Unclonable Functions (PUFs), which are already embedded in most commodity hardware platforms. The presented solution is particularly suitable for low-end computing devices without on-board security features. Our anti-counterfeiting approach is based on extracting a unique fingerprint for individual devices exploiting inherent PUF characteristics from the on-chip static random-access memory (SRAM), which in turn allows to bind software to a particular hardware platform. Our solution does not require additional hardware, making it flexible as well as cost efficient. In a first step, we statistically analyze the characteristics of the intrinsic PUF instances found in two device types, both based on a widely used ARM Cortex-M microcontroller. We show that the quality of the PUF characteristics is almost ideal. Subsequently, we propose a security architecture to protect the platform's firmware by using a modified boot loader. In a proof of concept, we embed our solution on a state-of-the-art commodity system-on-a-chip platform equipped with an MCU similar to the ones previously analyzed. {\textcopyright} 2014 Springer International Publishing.},
author = {Schaller, Andr{\'{e}} and Arul, Tolga and {Van Der Leest}, Vincent and Katzenbeisser, Stefan},
doi = {10.1007/978-3-319-08593-7_6},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Schaller et al. - 2014 - Lightweight anti-counterfeiting solution for low-end commodity hardware using inherent PUFs.pdf:pdf},
isbn = {9783319085920},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {83--100},
title = {{Lightweight anti-counterfeiting solution for low-end commodity hardware using inherent PUFs}},
volume = {8564 LNCS},
year = {2014}
}
@book{AhoAlfredV.2014C:pt,
annote = {Chapter 9 for Data-Flow Analysis},
author = {Aho, Alfred V},
edition = {Second edi},
isbn = {9781292024349},
keywords = {Compilers (Computer programs)},
publisher = {Pearson custom library},
title = {{Compilers : principles, techniques, and tools.}},
year = {2014}
}
@article{Asokan2018,
abstract = {Secure firmware update is an important stage in the IoT device life-cycle. Prior techniques, designed for other computational settings, are not readily suitable for IoT devices, since they do not consider idiosyncrasies of a realistic large-scale IoT deployment. This motivates our design of ASSURED, a secure and scalable update framework for IoT. ASSURED includes all stakeholders in a typical IoT update ecosystem, while providing end-to-end security between manufacturers and devices. To demonstrate its feasibility and practicality, ASSURED is instantiated and experimentally evaluated on two commodity hardware platforms. Results show that ASSURED is considerably faster than current update mechanisms in realistic settings.},
archivePrefix = {arXiv},
arxivId = {1807.05002v2},
author = {Asokan, N. and Nyman, Thomas and Rattanavipanon, Norrathep and Sadeghi, Ahmad Reza and Tsudik, Gene},
doi = {10.1109/TCAD.2018.2858422},
eprint = {1807.05002v2},
file = {:D$\backslash$:/Downloads/1807.05002.pdf:pdf},
issn = {02780070},
journal = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
keywords = {Computer security,Internet of Things (IoT),embedded software,embedded systems},
number = {11},
pages = {2290--2300},
title = {{ASSURED: Architecture for secure software update of realistic embedded devices}},
volume = {37},
year = {2018}
}
@article{ARM2009,
abstract = {This document provides an overview of the ARM TrustZone technology and how this can provide a practical level of security through careful System-on-a-Chip (SoC) configuration and software design.$\backslash$nARM TrustZone technology includes the ARM Security Extensions to the processor, the security signals added to the AMBA{\textregistered}3 bus infrastructure, and a number of pieces of peripheral Intellectual Property (IP) which can be used to build security on top of the$\backslash$nprocessor architecture and system architecture.},
author = {ARM},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/ARM - 2009 - Building a Secure System using TrustZone Technology.pdf:pdf},
journal = {Manual},
pages = {108},
title = {{Building a Secure System using TrustZone Technology}},
year = {2009}
}
@article{Gopalakrishna2005,
abstract = {Host-based intrusion detection systems attempt to identify attacks by discovering program behaviors that deviate from expected patterns. While the idea of performing behavior validation on-the-fly and terminating errant tasks as soon as a violation is detected is appealing, existing systems exhibit serious shortcomings in terms of accuracy and/or efficiency. To gain acceptance, a number of technical advances are needed. In this paper we focus on automated, conservative, intrusion detection techniques, i.e. techniques which do not require human intervention and do not suffer from false positives. We present a static analysis algorithm for constructing a flow- and context-sensitive model of a program that allows for efficient online validation. Context-sensitivity is essential to reduce the number of impossible control-flow paths accepted by the intrusion detection system because such paths provide opportunities for attackers to evade detection. An important consideration for on-the-fly intrusion detection is to reduce the performance overhead caused by monitoring. Compared to the existing approaches, our inlined automaton model (JAM) presents a good tradeoff between accuracy and performance. On a 32K line program, the monitoring overhead is negligible. While the space requirements of a naive IAM implementation can be quite high, compaction techniques can be employed to substantially reduce that footprint. {\textcopyright} 2005 IEEE.},
author = {Gopalakrishna, Rajeev and Spafford, Eugene H. and Vitek, Jan},
doi = {10.1109/SP.2005.1},
file = {:D$\backslash$:/Downloads/01425056.pdf:pdf},
isbn = {0769523390},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {18--31},
title = {{Efficient intrusion detection using automaton inlining}},
year = {2005}
}
@article{Yuce2016,
abstract = {Fault attacks are a known serious threat to embedded software security. We propose FAME, a low-cost and flexible approach to defend embedded software against fault attacks. FAME offers a combination of fault detection in hardware and fault response in software. A hardware fault detection unit continuously monitors the system status. When a fault injection is detected, an alarm signal triggers a secure trap mechanism that passes the control to a software trap handler. The trap handler applies a suitable fault response policy, which may include a broad variety of responses such as clearing sensitive data or issuing system-wide alerts. This enables a targeted, fast fault detection as well as an application-dependent, user-defined fault response. FAME requires much lower overhead than traditional countermeasure techniques in software or hardware. We demonstrate a prototype implementation of FAME using a modified LEON3 processor, and we analyze the hardware and software overhead to thwart setup-time violation attacks. The hardware area overhead is 7.4{\%} and 14.2{\%} in the number of LUTs and registers, respectively. The overhead of the software trap handler on top of an AES-128 program is 0.59{\%}--0.71{\%} in footprint and 1.01{\%}--2.35{\%} in performance, depending on the security policy. In contrast, traditional countermeasures that use redundant hardware or software against similar faults have at least double overhead.},
author = {Yuce, Bilgiday and Ghalaty, Nahid F and Deshpande, Chinmay and Patrick, Conor and Nazhandali, Leyla and Schaumont, Patrick},
doi = {10.1145/2948618.2948626},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yuce et al. - 2016 - FAME Fault-attack Aware Microprocessor Extensions for Hardware Fault Detection and Software Fault Response.pdf:pdf},
isbn = {978-1-4503-4769-3},
journal = {Proceedings of the Hardware and Architectural Support for Security and Privacy 2016},
keywords = {Embedded Software Security,Fault-attack Aware Microprocessor Extensions},
pages = {8:1----8:8},
title = {{FAME: Fault-attack Aware Microprocessor Extensions for Hardware Fault Detection and Software Fault Response}},
url = {http://doi.acm.org/10.1145/2948618.2948626},
year = {2016}
}
@article{Yuce2016a,
annote = {Breaks software only protections (not including flow analysis)},
author = {Yuce, Bilgiday and Ghalaty, Nahid Farhady and Santapuri, Harika and Deshpande, Chinmay and Patrick, Conor and Schaumont, Patrick},
doi = {10.1109/FDTC.2016.21},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yuce et al. - 2016 - Software Fault Resistance is Futile Effective Single-Glitch Attacks.pdf:pdf},
isbn = {9781509011087},
journal = {Proceedings - 2016 Workshop on Fault Diagnosis and Tolerance in Cryptography, FDTC 2016},
keywords = {Embedded Software Security,Fault Attacks,Software Countermeasures},
pages = {47--58},
publisher = {IEEE},
title = {{Software Fault Resistance is Futile: Effective Single-Glitch Attacks}},
year = {2016}
}
@article{Nyman2017,
abstract = {Widespread use of memory unsafe programming languages (e.g., C and C++) leaves many systems vulnerable to memory corruption attacks. A variety of defenses have been proposed to mitigate attacks that exploit memory errors to hijack the control flow of the code at run-time, e.g., (fine-grained) randomization or Control Flow Integrity. However, recent work on data-oriented programming (DOP) demonstrated highly expressive (Turing-complete) attacks, even in the presence of these state-of-the-art defenses. Although multiple real-world DOP attacks have been demonstrated, no efficient defenses are yet available. We propose run-time scope enforcement (RSE), a novel approach designed to efficiently mitigate all currently known DOP attacks by enforcing compile-time memory safety constraints (e.g., variable visibility rules) at run-time. We present HardScope, a proof-of-concept implementation of hardware-assisted RSE for the new RISC-V open instruction set architecture. We discuss our systematic empirical evaluation of HardScope which demonstrates that it can mitigate all currently known DOP attacks, and has a real-world performance overhead of 3.2{\%} in embedded benchmarks.},
archivePrefix = {arXiv},
arxivId = {1705.10295},
author = {Nyman, Thomas and Dessouky, Ghada and Zeitouni, Shaza and Lehikoinen, Aaro and Paverd, Andrew and Asokan, N. and Sadeghi, Ahmad-Reza},
eprint = {1705.10295},
file = {:D$\backslash$:/Downloads/1705.10295.pdf:pdf},
title = {{HardScope: Thwarting DOP with Hardware-assisted Run-time Scope Enforcement}},
url = {http://arxiv.org/abs/1705.10295},
year = {2017}
}
@article{Chen2017,
author = {Chen, Zhi and Shen, Junjie and Nicolau, Alex and Veidenbaum, Alex and Ghalaty, Nahid Farhady and Cammarota, Rosario},
doi = {10.1109/FDTC.2017.10},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chen et al. - 2017 - CAMFAS A Compiler Approach to Mitigate Fault Attacks via Enhanced SIMDization.pdf:pdf},
isbn = {9781538629482},
journal = {Proceedings - 2017 Workshop on Fault Diagnosis and Tolerance in Cryptography, FDTC 2017},
pages = {57--64},
title = {{CAMFAS: A Compiler Approach to Mitigate Fault Attacks via Enhanced SIMDization}},
volume = {2017-Janua},
year = {2017}
}
@inproceedings{Eldefrawy2017,
abstract = {Remote Attestation (RA) allows a trusted entity (verifier) to securely measure internal state of a remote untrusted hardware platform (prover). RA can be used to establish a static or dynamic root of trust in embedded and cyber-physical systems. It can also be used as a building block for other security services and primitives, such as software updates and patches, verifiable deletion and memory resetting. There are three major classes of RA designs: hardware-based, software-based, and hybrid, each with its own set of benefits and drawbacks. This paper presents the first hybrid RA design, called HYDRA, that builds upon formally verified software components that ensure memory isolation and protection, as well as enforce access control to memory and other resources. HYDRA obtains these properties by using the formally verified seL4 microkernel. (Until now, this was only attainable with purely hardware-based designs.) Using seL4 requires fewer hardware modifications to the underlying microprocessor. Building upon a formally verified software component increases confidence in security of the overall design of HYDRA and its implementation. We instantiate HYDRA on two commodity hardware platforms and assess the performance and overhead of performing RA on such platforms via experimentation; we show that HYDRA can attest 10MB of memory in less than 500msec when using a Speck-based message authentication code (MAC) to compute a cryptographic checksum over the memory to be attested.},
author = {Eldefrawy, Karim and Rattanavipanon, Norrathep and Tsudik, Gene},
booktitle = {Proceedings - 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks Workshops, DSN-W 2017},
doi = {10.1109/DSN-W.2017.31},
isbn = {9781538622728},
title = {{FUsing Hybrid Remote Attestation with a Formally Verified Microkernel: Lessons Learned}},
year = {2017}
}
@article{Skorobogatov2007,
abstract = {We describe a new class of attacks on secure microcontrollers and smartcards. Illumination of a target transistor causes it to conduct, thereby inducing a transient fault. Such attacks are practical; they do not even require expensive laser equipment. We have carried them out using a flashgun bought second-hand from a camera store for {\$}30 and with an {\$}8 laser pointer. As an illustration of the power of this attack, we developed techniques to set or reset any individual bit of SRAM in a microcontroller. Unless suitable countermeasures are taken, optical probing may also be used to induce errors in cryptographic computations or protocols, and to disrupt the processor's control flow. It thus provides a powerful extension of existing glitching and fault analysis techniques. This vulnerability may pose a big problem for the industry, similar to those resulting from probing attacks in the mid-1990s and power analysis attacks in the late 1990s. We have therefore developed a technology to block these attacks.We use self-timed dual-rail circuit design techniques whereby a logical 1 or 0 is not encoded by a high or low voltage on a single line, but by (HL) or (LH) on a pair of lines. The combination (HH) signals an alarm, which will typically reset the processor. Circuits can be designed so that single- transistor failures do not lead to security failure. This technology may also make power analysis attacks very much harder too.},
author = {Skorobogatov, Sergei P. and Anderson, Ross J.},
doi = {10.1007/3-540-36400-5_2},
file = {:D$\backslash$:/Downloads/Skorobogatov-Anderson2003{\_}Chapter{\_}OpticalFaultInductionAttacks.pdf:pdf},
pages = {2--12},
title = {{Optical Fault Induction Attacks}},
year = {2007}
}
@article{Gora2010,
abstract = {Software intellectual property (SWIP) is a critical component of increasingly complex field programmable gate arrays (FPGA)-based system-on-chip (SOC) designs. As a result, developers want to ensure that their Software Intellectual Property (SWIP) is protected from being exposed to or tampered with by unauthorized parties. By restricting the execution of SWIP to a single trusted FPGA platform, SWIP binding addresses developers' concerns about maintaining control of their intellectual property and the market position it affords. This work proposes a novel design flow for SWIP binding on a commodity FPGA platform lacking specialized hardcore security facilities. We accomplish this by leveraging the qualities of a Physical Unclonable Function (PUF) and a tight integration of hardware and software security features. A prototype implementation demonstrates our design flow's ability to successfully protect software by encryption using a 128 bit FPGA-unique key extracted from a PUF. Based on this proof of concept, a solution to perform secure remote software updates, a common challenge in embedded systems, is proposed to showcase the practicality and flexibility of the design flow.},
author = {Gora, Michael A. and Maiti, Abhranil and Schaumont, Patrick},
doi = {10.1109/TII.2010.2068303},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Gora, Maiti, Schaumont - 2010 - A flexible design flow for software IP binding in FPGA.pdf:pdf},
isbn = {9781424441105},
issn = {15513203},
journal = {IEEE Transactions on Industrial Informatics},
keywords = {Design flow,field programmable gate arrays (FPGA),firmware,intellectual property,physical unclonable function,secure embedded systems,security,software binding},
number = {4},
pages = {719--728},
pmid = {14637044},
publisher = {IEEE},
title = {{A flexible design flow for software IP binding in FPGA}},
volume = {6},
year = {2010}
}
@article{Suh,
author = {Suh, G Edward and Clarke, Dwaine and Gassend, Blaise and Dijk, Marten Van and Devadas, Srinivas},
doi = {10.1145/782814.782838},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Suh et al. - Unknown - AEGIS Architecture for Tamper-Evident and Tamper-Resistant Processing.pdf:pdf},
isbn = {1581137338},
issn = {02105187},
keywords = {certified execution,secure processors,software licensing},
title = {{AEGIS : Architecture for Tamper-Evident and Tamper-Resistant Processing}}
}
@article{DeClercq2017a,
abstract = {Software components are frequently used in cyber-physical systems (CPSes) to control a physical mechanism, such as a valve or brakes on a car. These systems are extremely sensitive to software vulnerabilities, as their exploitation could lead to injury, damage to equipment, or environmental catastrophe. This paper proposes a hardware-based security architecture called SOFIA, which protects software running on microprocessors used in CPSes. SOFIA provides mechanisms to protect software integrity and control flow integrity. This allows the processor to defend against a large number of attacks, including code injection, code reuse, and fault-based attacks on the program counter. In addition, the architecture also defends against software copyright infringement and reverse engineering. All protection mechanisms are enforced in hardware using cryptographic techniques. We are the first to propose a mechanism to enforce control flow integrity at the finest possible granularity using cryptographic techniques. A SOFIA core has been created by implementing the proposed architectural features on a LEON3 microprocessor. The SOFIA core requires that its software conforms to a strict format. To this end, we additionally designed and implemented a software toolchain to compile source code that adheres to the formatting rules. Several benchmarks were compiled with the SOFIA toolchain, and were executed on a SOFIA core running on an FPGA, showing an average total execution time overhead of 106{\%} compared to an unmodified LEON3 core. Our hardware evaluation shows a clock speed reduction of 23.2{\%}.},
author = {de Clercq, Ruan and G{\"{o}}tzfried, Johannes and {\"{U}}bler, David and Maene, Pieter and Verbauwhede, Ingrid},
doi = {10.1016/j.cose.2017.03.013},
issn = {01674048},
journal = {Computers and Security},
title = {{SOFIA: Software and control flow integrity architecture}},
volume = {68},
year = {2017}
}
@article{Fritz,
author = {Fritz, Jason and Bonato, Michael and French, David and Scally, Larry},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Fritz et al. - Unknown - A Reconfigurable Advanced Tamper Resistant Embedded Processing Platform Anti-Tamper Technologies.pdf:pdf},
title = {{A Reconfigurable Advanced Tamper Resistant Embedded Processing Platform Anti-Tamper Technologies}}
}
@article{Yang2003,
abstract = {Due to the widespread software piracy and virus attacks, significant efforts have been made to improve security for computer systems. For stand-alone computers, a key observation is that other than the processor, any component is vulnerable to security attacks. Recently, an execution only memory (XOM) architecture has been proposed to support copy and tamper resistant software by D. Lie et al. (2000), D. Lie et al. (2003) and T. Gilmont et al. (1999). In this design, the program and data are stored in encrypted format outside the CPU boundary. The decryption is carried after they are fetched from memory, and before they are used by the CPU. As a result, the lengthened critical path causes a serious performance degradation. In this paper, we present an innovative technique in which the cryptography computation is shifted off from the memory access critical path. We propose to use a different encryption scheme, namely "one-time pad" encryption, to produce the instructions and data ciphertext. With some additional on-chip storage, cryptography computations are carried in parallel with memory accesses, minimizing performance penalty. We performed experiments to study the trade-off between storage size and performance penalty. Our technique improves the execution speed of the XOM architecture by 34{\%} at maximum},
author = {Yang, Jun and Zhang, Youtao and Gao, Lan},
doi = {10.1109/MICRO.2003.1253209},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yang, Zhang, Gao - 2003 - Fast secure processor for inhibiting software piracy and tampering.pdf:pdf},
isbn = {076952043X},
issn = {10724451},
journal = {Proceedings of the Annual International Symposium on Microarchitecture, MICRO},
keywords = {Central Processing Unit,Computer architecture,Computer crime,Computer security,Concurrent computing,Cryptography,Data security,Degradation,Immune system,Memory architecture},
pages = {351--360},
title = {{Fast secure processor for inhibiting software piracy and tampering}},
volume = {2003-Janua},
year = {2003}
}
@article{Hada2007,
abstract = {In this paper, we investigate the gap between auxiliary-input zero-knowledge (AIZK) and blackbox-simulation zero-knowledge (BSZK). It is an interestingop en problem whether or not there exists a protocol which achieves AIZK, but not BSZK. We show that the existence of such a protocol is closely related to the existence of secure code obfuscators. A code obfuscator is used to convert a code into an equivalent one that is difficult to reverse-engineer. This paper provides security definitions of code obfuscation. By their definitions, it is easy to see that the existence of the gap implies the existence of a cheating verifier such that it is impossible to obfuscate any code of it. Intuitively, this means that it is possible to reverse-engineer any code of such a cheating verifier. Furthermore, we consider the actual behavior of such a cheating verifier. In order to do so, we focus on two special cases in which the gap exists: (1) there exists a constant round public-coin AIZK interactive argument for a language outside of BPP. (2) there exists a 3-round secret-coinAIZK interactive argument for a language outside of BPP. In the former case, we show that it is impossible to securely obfuscate a code of a cheating verifier behaving as a pseudorandom function. A similar result is shown also in the latter case. Our results imply that any construction of constant round public-coin or 3-round secret-coin AIZK arguments for non-trivial languages essentially requires a computational assumption with a reverse-engineering property.},
author = {Hada, Satoshi},
doi = {10.1007/3-540-44448-3_34},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hada - 2007 - Zero-Knowledge and Code Obfuscation.pdf:pdf},
keywords = {code obfuscation,interactive,interactive argument,proof,reverse-engineering,zero-knowledge},
pages = {443--457},
title = {{Zero-Knowledge and Code Obfuscation}},
year = {2007}
}
@article{Oh2002,
abstract = {This paper presents a new signature monitoring technique, CFCSS$\backslash$n(control flow checking by software signatures); CFCSS is a pure software$\backslash$nmethod that checks the control flow of a program using assigned$\backslash$nsignatures. An algorithm assigns a unique signature to each node in the$\backslash$nprogram graph and adds instructions for error detection. Signatures are$\backslash$nembedded in the program during compilation time using the constant field$\backslash$nof the instructions and compared with run-time signatures when the$\backslash$nprogram is executed. Another algorithm reduces the code size and$\backslash$nexecution time overhead caused by checking instructions in CFCSS. A$\backslash$n"branching fault injection experiment" was performed with benchmark$\backslash$nprograms. Without CFCSS, an average of 33.7 {\%} of the injected branching$\backslash$nfaults produced undetected incorrect outputs; however, with CFCSS, only$\backslash$n3.1 {\%} of branching faults produced undetected incorrect outputs. Thus it$\backslash$nis possible to increase error detection coverage for control flow errors$\backslash$nby an order of magnitude using CFCSS. The distinctive advantage of CFCSS$\backslash$nover previous signature monitoring techniques is that CFCSS is a pure$\backslash$nsoftware method, i.e., it needs no dedicated hardware such as a watchdog$\backslash$nprocessor for control flow checking. A watchdog task in multitasking$\backslash$nenvironment also needs no extra hardware, but the advantage of CFCSS$\backslash$nover a watchdog task is that CFCSS can be used even when the operating$\backslash$nsystem does not support multitasking},
author = {Oh, Nahmsuk and Shirvani, Philip P. and McCluskey, Edward J.},
doi = {10.1109/24.994926},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Oh, Shirvani, McCluskey - 2002 - Control-flow checking by software signatures.pdf:pdf},
issn = {00189529},
journal = {IEEE Transactions on Reliability},
keywords = {Assigned signatures,Control flow checking,Fault injection experiments,Signature monitoring,Software error detection},
number = {1},
pages = {111--122},
title = {{Control-flow checking by software signatures}},
volume = {51},
year = {2002}
}
@article{Holler2015,
abstract = {{\textcopyright} 2015 IEEE.Physical attacks, such as fault attacks, pose a decisive threat for the security of devices in the Internet of Things. An important class of countermeasures for fault attacks is fault tolerant software that is applicable for systems based on COTS hardware. In order to evaluate software countermeasures against fault attacks, fault injection is needed. However, established fault injection approaches require manufactured products or hardware details (e.g. netlists, RTL models), which are not available when using COTS hardware. In this paper, we present a QEMU-based fault injection platform that supports commercial COTS processors that are widely-used in the embedded domain. This framework allows a system-level analysis of software countermeasures by featuring the simulation of high-level hardware faults targeting, for example, memory cells, register cells, or the correct execution of instructions. The framework supports the generation of realistic fault attack scenarios. We illustrate the practicability of the approach by presenting two exemplary use cases.},
author = {Holler, Andrea and Krieg, Armin and Rauter, Tobias and Iber, Johannes and Kreiner, Christian},
doi = {10.1109/DSD.2015.79},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Holler et al. - 2015 - QEMU-based fault injection for a system-level analysis of software countermeasures against fault attacks.pdf:pdf},
isbn = {9781467380355},
journal = {Proceedings - 18th Euromicro Conference on Digital System Design, DSD 2015},
keywords = {COTS,Fault attacks,Fault injection,QEMU,Security},
pages = {530--533},
title = {{QEMU-based fault injection for a system-level analysis of software countermeasures against fault attacks}},
year = {2015}
}
@book{MangardStefan2007Paa:,
address = {New York},
author = {Mangard, Stefan},
isbn = {0387308571},
keywords = {Smart cards -- Security measures},
publisher = {Springer},
title = {{Power analysis attacks : revealing the secrets of smart cards}},
year = {2007}
}
@article{Ahmadvand2019,
abstract = {Tampering with software by man-at-the-end (MATE) attackers is an attack that can lead to security circumvention, privacy violation, reputation damage, and revenue loss. In this model, adversaries are end users who have full control over software as well as its execution environment. This full control enables them to tamper with programs to their benefit and to the detriment of software vendors or other end users. Software integrity protection research seeks for means to mitigate those attacks. Since the seminal work of Aucsmith, a great deal of research effort has been devoted to fight MATE attacks, and many protection schemes were designed by both academia and industry. Advances in trusted hardware, such as TPM and Intel SGX, have also enabled researchers to utilize such technologies for additional protection. Despite the introduction of various protection schemes, there is no comprehensive comparison study that points out advantages and disadvantages of different schemes. Constraints of different schemes and their applicability in various industrial settings have not been studied. More importantly, except for some partial classifications, to the best of our knowledge, there is no taxonomy of integrity protection techniques. These limitations have left practitioners in doubt about effectiveness and applicability of such schemes to their infrastructure. In this work, we propose a taxonomy that captures protection processes by encompassing system, defense and attack perspectives. Later, we carry out a survey and map reviewed papers on our taxonomy. Finally, we correlate different dimensions of the taxonomy and discuss observations along with research gaps in the field.},
author = {Ahmadvand, Mohsen and Pretschner, Alexander and Kelbert, Florian},
doi = {10.1016/bs.adcom.2017.12.007},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ahmadvand, Pretschner, Kelbert - 2019 - A Taxonomy of Software Integrity Protection Techniques.pdf:pdf},
isbn = {9780128151211},
issn = {00652458},
journal = {Advances in Computers},
keywords = {Integrity protection,Software monetization,Software protection,Tamper-proofing,Taxonomy},
pages = {413--486},
title = {{A Taxonomy of Software Integrity Protection Techniques}},
volume = {112},
year = {2019}
}
@article{Serpanos2018,
abstract = {Embedded systems security is a significant requirement in emerging environments, considering the increasing deployment of embedded systems in several application domains. The large number of deployed embedded systems, their limited resources and their increasing complexity render systems vulnerable to an increasing number of threats. Additionally, the involvement of sensitive, often private, information and the expectation for safe and dependable embedded platforms lead to strong security requirements, even legal ones, which require new technologies for their provision. In this article, we provide an overview of embedded security issues, used methods and technologies, identifying important challenges in this emerging field.},
author = {Serpanos, Dimitrios N. and Voyiatzis, Artemios G.},
doi = {10.1145/2435227.2435262},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Serpanos, Voyiatzis - 2018 - Security challenges in embedded systems.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {1s},
pages = {1--10},
title = {{Security challenges in embedded systems}},
volume = {12},
year = {2018}
}
@article{Habing1965,
abstract = {High levels of ionization can be created in semiconductor devices by irradiating the devices with short pulses of light. If the light frequency is properly selected, sufficient and relatively uniform energy deposition is obtained which results in ionization rates orders of magnitude above those presently attainable from other sources. It is shown that a pulsed-infrared laser can be used as a relatively simple, inexpensive, and effective means of simulating the effects caused by intense gamma ray sources on semiconductors. Experimental results are presented which show that the transients induced in various types of silicon transistors when exposed to a neodymium laser are essentially identical to those obtained when the transistors are exposed to pulses of 25 MeV electrons from a linear accelerator and 600 kvp flash X-ray machine. Good agreement exists between the peak photocurrents obtained using these three sources over a dose range of 10-1 to 104 rads. Calculations based upon published as well as experimental absorption data for silicon show that energy deposition is very nearly uniform for the wavelength of light obtained from neodymium lasers (1. 06 microns - 1. 17 ev photons). By defocusing the laser light beam, dose rates in excess of 10R12 rads/ sec (silicon) in 40 x 1-99 seconds over an area of 50 cm2 have been obtained from a Q-switched 10 megawatt neodymium laser. This greatly exceeds the maximum dose rate of 1011{\textless} rads/ sec silicon) over approximately 1 c2m attainable from linear accelerators.},
author = {Habing, D. H.},
doi = {10.1109/TNS.1965.4323904},
file = {:D$\backslash$:/Downloads/04323904.pdf:pdf},
issn = {15581578},
journal = {IEEE Transactions on Nuclear Science},
number = {5},
pages = {91--100},
title = {{The use of lasers to simulate radiation-induced transients in semiconductor devices and circuits}},
volume = {12},
year = {1965}
}
@article{Suh2005,
abstract = {Secure processors enable new applications by ensuring private and authentic program execution even in the face of physical attack. In this paper, we present the AEGIS secure processor architecture, and evaluate its RTL implementation on FPGAs. By using physical random functions, we propose a new way of reliably protecting and sharing secrets that is more secure than existing solutions based on non-volatile memory. Our architecture gives applications the flexibility of trusting and protecting only a portion of a given process, unlike prior proposals which require a process to be protected in entirety. We also put forward a specific model of how secure applications can be programmed in a high-level language and compiled to run on our system. Finally, we evaluate a fully functional FPGA implementation of our processor, assess the implementation tradeoffs, compare performance, and demonstrate the benefits of partially protecting a program.},
author = {Suh, G. Edward and O'Donnell, Charles W. and Sachdev, Ishan and Devadas, Srinivas},
doi = {10.1145/1080695.1069974},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Suh et al. - 2005 - Design and Implementation of the AEGIS Single-Chip Secure Processor Using Physical Random Functions.pdf:pdf},
issn = {01635964},
journal = {ACM SIGARCH Computer Architecture News},
number = {2},
pages = {25--36},
title = {{Design and Implementation of the AEGIS Single-Chip Secure Processor Using Physical Random Functions}},
volume = {33},
year = {2005}
}
@incollection{Kohnhauser2015,
abstract = {Abstract. In recent years, low-end embedded devices have been used increasingly in various scenarios, ranging from consumer electronics to industrial equipment. However, this evolution made embedded devices profitable targets for software piracy and software manipulation. Aggra- vating this situation, low-end embedded devices typically lack secure hardware to effectively protect against such attacks. In this work, we present a novel software protection scheme, which is particularly suited for already deployed low-end embedded devices without secure hardware. Our approach combines techniques based on self-checksumming code with Physically Unclonable Functions (PUFs) to establish a hardware- assisted software protection. In this way, we can tie the execution of a software instance to a specific device and protect its program code against manipulations. We show that our software protection scheme offers a high level of security against static adversaries and demonstrate that dynamic adversaries require considerable resources to perform a successful attack. To explore the feasibility of our solution, we implemented the protection scheme on an ARM-based low-end commodity microcontroller. A further performance evaluation shows that the implemented solution exhibits a fair overhead of ten percent.},
archivePrefix = {arXiv},
arxivId = {arXiv:1506.07739v2},
author = {Kohnh{\"{a}}user, Florian and Schaller, Andr{\'{e}} and Katzenbeisser, Stefan},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-22846-4_1},
eprint = {arXiv:1506.07739v2},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kohnh{\"{a}}user, Schaller, Katzenbeisser - 2015 - PUF-Based Software Protection for Low-End Embedded Devices.pdf:pdf},
isbn = {9783319228457},
issn = {16113349},
pages = {3--21},
title = {{PUF-Based Software Protection for Low-End Embedded Devices}},
url = {http://link.springer.com/10.1007/978-3-319-22846-4{\_}1},
volume = {9229},
year = {2015}
}
@article{Khiyal2010,
author = {Khiyal, Malik Sikandar Hayat and Khan, Aihab and Amjad, Sehrish and Khalil, M. Shahid},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Khiyal et al. - 2010 - Evaluating Effectiveness of Tamper Proofing on Dynamic Graph Software Watermarks.pdf:pdf},
journal = {CoRR},
number = {July 2014},
title = {{Evaluating Effectiveness of Tamper Proofing on Dynamic Graph Software Watermarks}},
volume = {abs/1001.1},
year = {2010}
}
@book{GebotysCatherineH2010Sied,
address = {New York ; London},
author = {Gebotys, Catherine H},
isbn = {144191529x},
keywords = {Computer security,Embedded computer systems -- Se},
publisher = {Springer},
series = {Embedded systems},
title = {{Security in embedded devices}},
year = {2010}
}
@article{Khelladi2008,
author = {Khelladi, Lyes and Challal, Yacine and Bouabdallah, Abdelmadjid and Badache, Nadjib},
doi = {10.1504/ijics.2008.018515},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Khelladi et al. - 2008 - On security issues in embedded systems challenges and solutions.pdf:pdf},
issn = {1744-1765},
journal = {International Journal of Information and Computer Security},
number = {2},
pages = {140},
title = {{On security issues in embedded systems: challenges and solutions}},
volume = {2},
year = {2008}
}
@article{Nyman2017a,
abstract = {With the increasing scale of deployment of Internet of Things (IoT), concerns about IoT security have become more urgent. In particular, memory corruption attacks play a predominant role as they allow remote compromise of IoT devices. Control-flow integrity (CFI) is a promising and generic defense technique against these attacks. However, given the nature of IoT deployments, existing protection mechanisms for traditional computing environments (including CFI) need to be adapted to the IoT setting. In this paper, we describe the challenges of enabling CFI on microcontroller (MCU) based IoT devices. We then present CaRE, the first interrupt-aware CFI scheme for low-end MCUs. CaRE uses a novel way of protecting the CFI metadata by leveraging TrustZone-M security extensions introduced in the ARMv8-M architecture. Its binary instrumentation approach preserves the memory layout of the target MCU software, allowing pre-built bare-metal binary code to be protected by CaRE. We describe our implementation on a Cortex-M Prototyping System and demonstrate that CaRE is secure while imposing acceptable performance and memory impact.},
archivePrefix = {arXiv},
arxivId = {arXiv:1706.05715v1},
author = {Nyman, Thomas and Ekberg, Jan Erik and Davi, Lucas and Asokan, N.},
doi = {10.1007/978-3-319-66332-6_12},
eprint = {arXiv:1706.05715v1},
file = {:D$\backslash$:/Downloads/1706.05715.pdf:pdf},
isbn = {9783319663319},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {259--284},
title = {{CFI CaRE: Hardware-Supported Call and, Return Enforcement for Commercial Microcontrollers}},
volume = {10453 LNCS},
year = {2017}
}
@article{Wagner2002,
abstract = {One of the primary challenges in intrusion detection is modelling$\backslash$ntypical application behavior so that we can recognize attacks by$\backslash$ntheir atypical effects without raising too many false alarms. We$\backslash$nshow how static analysis may be used to automatically derive a model$\backslash$nof application behavior. The result is a host-based intrusion detection$\backslash$nsystem with three advantages: a high degree of automation, protection$\backslash$nagainst a broad class of attacks based on corrupted code, and the$\backslash$nelimination of false alarms. We report on our experience with a prototype$\backslash$nimplementation of this technique},
author = {Wagner, D. and Dean, R.},
doi = {10.1109/secpri.2001.924296},
file = {:D$\backslash$:/Downloads/00924296.pdf:pdf},
pages = {156--168},
title = {{Intrusion detection via static analysis}},
year = {2002}
}
@article{Blum1995,
author = {Blum, Manuel},
doi = {10.1145/200836.200880},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Blum - 1995 - Designing programs that check their work.pdf:pdf},
journal = {Journal of the ACM},
number = {1},
pages = {269--291},
title = {{Designing programs that check their work}},
url = {http://portal.acm.org/citation.cfm?id=73015},
volume = {42},
year = {1995}
}
@article{Gandolfi2007,
abstract = {Although the possibility of attacking smart-cards by analyzing their electromagnetic power radiation repeatedly appears in research papers, all accessible references evade the essence of reporting conclusive experiments where actual cryptographic algorithms such as des or rsa were successfully attacked. This work describes electromagnetic experiments conducted on three different cmos chips, featuring different hardware protections and executing a des, an alleged COMP128 and an RSA. In all cases the complete key material was successfully retrieved.},
author = {Gandolfi, Karine and Mourtel, Christophe and Olivier, Francis},
doi = {10.1007/3-540-44709-1_21},
file = {:D$\backslash$:/Downloads/Gandolfi2001{\_}Chapter{\_}ElectromagneticAnalysisConcret.pdf:pdf},
keywords = {dema,dpa,electromagnetic analysis,sema,side channel leakage,smart cards,spa},
pages = {251--261},
title = {{Electromagnetic Analysis: Concrete Results}},
year = {2007}
}
@article{Alkhalifa1999,
abstract = {This paper evaluates the concurrent error detection capabilities$\backslash$nof system-level checks, using fault and error injection. The checks$\backslash$ncomprise application and system level mechanisms to detect control flow$\backslash$nerrors. We propose Enhanced Control-Flow Checking Using Assertions$\backslash$n(ECCA). In ECCA, branch-free intervals (BFI) in a given high or$\backslash$nintermediate level program are identified and the entry and exit points$\backslash$nof the intervals are determined. BFls are then grouped into blocks, the$\backslash$nsize of which is determined through a performance/overhead analysis. The$\backslash$nblocks are then fortified with preinserted assertions. For the high$\backslash$nlevel ECCA, we describe an implementation of ECCA through a preprocessor$\backslash$nthat will automatically insert the necessary assertions into the$\backslash$nprogram. Then, we describe the intermediate implementation possible$\backslash$nthrough modifications made on gee to make it ECCA capable. The fault$\backslash$ndetection capabilities of the checks are evaluated both analytically and$\backslash$nexperimentally. Fault injection experiments are conducted using FERRARI$\backslash$nto determine the fault coverage of the proposed techniques},
author = {Alkhalifa, Z. and Nair, V. S.S. and Krishnamurthy, N. and Abraham, J. A.},
doi = {10.1109/71.774911},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Alkhalifa et al. - 1999 - Design and evaluation of system-level checks for on-line control flow error detection.pdf:pdf},
issn = {10459219},
journal = {IEEE Transactions on Parallel and Distributed Systems},
number = {6},
pages = {627--641},
title = {{Design and evaluation of system-level checks for on-line control flow error detection}},
volume = {10},
year = {1999}
}
@article{Bar-el2006,
author = {Bar-el, Hagai and Choukri, Hamid},
file = {:D$\backslash$:/Downloads/01580506.pdf:pdf},
journal = {Proceedings of the IEEE},
keywords = {fault attacks,glitch attacks,side-channel attacks},
number = {2},
pages = {370--382},
title = {{The Sorcerer ' s Apprenctice ' s Guide to Fault Attacks}},
url = {http://ieeexplore.ieee.org/abstract/document/1580506/{\%}0Ahttp://www.hbarel.com/media/blogs/hagai-on-security/Sorcerers{\_}Apprentice{\_}Guide.pdf},
volume = {94},
year = {2006}
}
@article{Govindavajhala2003,
abstract = {We present an experimental study showing that soft to the JVM error in its address space will allow it to take control of the JVM. All conventional Java and .NET to this a probability of about 70{\%}, and multiple-bit a lower probability. Our is particularly relevant against smart cards or tamper-resistant computers, where the user has physical access (to the outside of the computer) and can use various means {\textless}span faults; we have successfully {\textless}span Fortunately, there are some straightforward defenses against this {\textless}span},
author = {Govindavajhala, S. and Appel, A. W.},
doi = {10.1109/SECPRI.2003.1199334},
file = {:D$\backslash$:/Downloads/01199334.pdf:pdf},
isbn = {0769519407},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {154--165},
publisher = {IEEE},
title = {{Using memory errors to attack a virtual machine}},
volume = {2003-Janua},
year = {2003}
}
@article{Naccache2007,
abstract = {This paper introduces a method for tracking different copies of functionally equivalent algorithms containing identification$\backslash$nmarks known to the attacker. Unlike all previous solutions, the new technique does not rely on any marking assumption and$\backslash$nleads to a situation where each copy is either traceable or so severely damaged that it becomes impossible to store in polynomial$\backslash$nspace or run in polynomial time.$\backslash$n$\backslash$nAlthough RSA-related, the construction is particularly applicable to confidential block-ciphers such as SkipJack, RC4, GOST$\backslash$n2814789, GSM A5, COMP128, TIA CAVE or other proprietary executables distributed to potentially distrusted users.},
author = {Naccache, David and Shamir, Adi and Stern, Julien P.},
doi = {10.1007/3-540-49162-7_14},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Naccache, Shamir, Stern - 2007 - How to Copyright a Function.pdf:pdf},
number = {August 2004},
pages = {188--196},
title = {{How to Copyright a Function?}},
year = {2007}
}
@article{Atkinson,
author = {Atkinson, Darren C and Clara, Santa},
file = {:D$\backslash$:/Downloads/serp-02.pdf:pdf},
journal = {Computer Engineering},
keywords = {pointer analysis,program analysis,software maintenance},
title = {{Call Graph Extraction in the Presence of Function Pointers}}
}
@article{Jacob2007,
abstract = {Executing binaries without interference by an outside adversary has been an ongoing duel between protection methods and at- tacks. Recently, an efficient kernel-patch attack has been pre- sented against commonly used self-checking code techniques that use checksumming ahead of execution. While methods based on self-modifying code can defend against this attack, such techniques depend on low-level architectural details and may not be practical in the long run. An alternative defense is to use oblivious hashing (OH). Instead of checking code integrity prior to execution, OH can verify untampered runtime behavior continuously. However, earlier OH approaches have some weaknesses, particularly with binary code: Physical instruction bytes cannot be easily checked during execution, and an attacker may be able to detect and remove OH checks, since OH alone does not provide tamper-resistance or obfuscation. In our approach, we deliberately overlap a program's basic blocks so that they share instruction bytes. This increases tamper- resistance implicitly because malicious modifications affect mul- tiple instructions simultaneously. Also, our scheme facilitates explicit anti-tampering checks via injection of OH instructions overlapped with target code, enabling OH that can verify in- tegrity of both runtime state and executing instructions. Thus, our method addresses anti-checksum attacks without resorting to self-modifying code, and also extends OH to verify physical code, not only program state. In addition, overlapping facilitates resis- tance against disassembly and decompilation. Our approach works on processor architectures and byte-codes that support variable- length instructions. To our knowledge, this is the first technique that blends tamper-resistance into architecture and therefore sig- nificantly improves robustness of binaries.},
author = {Jacob, Matthias and Jakubowski, Mariusz H and Venkatesan, Ramarathnam},
doi = {10.1145/1288869.1288887},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Jacob, Jakubowski, Venkatesan - 2007 - Towards Integral Binary Execution Implementing Oblivious Hashing Using Overlapped Instruction Enc.pdf:pdf},
isbn = {978-1-59593-857-2},
journal = {Proceedings of the 9th Workshop on Multimedia {\&} Security},
keywords = {anti-disassembly,integrity checking,obfuscation,oblivious hashing,overlapped code,tamper-resistance},
pages = {129--140},
title = {{Towards Integral Binary Execution: Implementing Oblivious Hashing Using Overlapped Instruction Encodings}},
url = {http://doi.acm.org/10.1145/1288869.1288887},
year = {2007}
}
@article{Suzer2011,
abstract = {Traditionally, IC companies were able to protect their IP assets by simply keeping these in safe. However, the new trends such as outsourcing and fabless IC development make the silicon processing and IC development more accessible. Therefore, IC authentication and IP (intellectual property) protection have become real world problems that industry eagerly seeks for efficient solutions. Most of the considerable proposals to these intense problems involve complicated cryptographic schemes and procedures that bring extra burden on system design. Moreover, if the target platform is a constraint environment, this burden is amplified and even the most efficient solutions become infeasible. Therefore, designers tend to use the ad-hoc methods that possibly have serious security risks. In this study, we seek practical solutions for the FPGAs (Field Programmable Gate Array) which represent a relatively small but important subset of hardware IP utilization.},
author = {Suzer, Orhun and Kaya, Gurkan and Donmez, Faruk and Saldamli, Gokay and Yalcin, Mustak E.},
file = {:D$\backslash$:/Downloads/b847255d7a04a49{\_}ek.pdf:pdf},
journal = {2011 7th International Conference on Electrical and Electronics Engineering (ELECO)},
pages = {II--293--II--296},
title = {{A practical authentication method of FPGA designs suitable for mass production}},
year = {2011}
}
@article{Moro2014,
abstract = {Fault attacks against embedded circuits enabled to define many new attack paths against secure circuits. Every attack path relies on a specific fault model which defines the type of faults that the attacker can perform. On embedded processors, a fault model consisting in an assembly instruction skip can be very useful for an attacker and has been obtained by using several fault injection means. To avoid this threat, some countermeasure schemes which rely on temporal redundancy have been proposed. Nevertheless, double fault injection in a long enough time interval is practical and can bypass those countermeasure schemes. Some fine-grained countermeasure schemes have also been proposed for specific instructions. However, to the best of our knowledge, no approach that enables to secure a generic assembly program in order to make it fault-tolerant to instruction skip attacks has been formally proven yet. In this paper, we provide a fault-tolerant replacement sequence for almost all the instructions of the Thumb-2 instruction set and provide a formal verification for this fault tolerance. This simple transformation enables to add a reasonably good security level to an embedded program and makes practical fault injection attacks much harder to achieve.},
annote = {Interesting and simple idea, but seems to rely on lots of code duplication (100{\%} - 200{\%} execution / program size overhead)},
archivePrefix = {arXiv},
arxivId = {1402.6461},
author = {Moro, N. and Heydemann, K. and Encrenaz, E. and Robisson, B.},
doi = {10.1007/s13389-014-0077-7},
eprint = {1402.6461},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Moro et al. - 2014 - Formal verification of a software countermeasure against instruction skip attacks.pdf:pdf},
isbn = {1338901400},
issn = {21908516},
journal = {Journal of Cryptographic Engineering},
keywords = {Countermeasure,Fault attack,Formal verification,Instruction skip,Microcontroller},
number = {3},
pages = {145--156},
title = {{Formal verification of a software countermeasure against instruction skip attacks}},
volume = {4},
year = {2014}
}
@article{Al-Wosabi2015,
abstract = {Embedded systems (ES) become available anywhere and anytime as an established part of our daily routine. Developers of these systems face significant challenges in code and information security. Whereas, software tampering is one of these challenges, code integrity detection is one of the main approaches used to defeat it. Checking code integrity achieves tamper proofing by method of identification of unauthorized alteration to recognize any tampered code is executed or tampered data are used. Our research objective is to propose an applicable framework for tampering detection in ES and this paper introduces the exploratory outcomes so far.},
author = {Al-Wosabi, Abdo Ali Abdullah and Shukur, Zarina and Ibrahim, Muhammad Azwan},
doi = {10.1109/ICEEI.2015.7352507},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Al-Wosabi, Shukur, Ibrahim - 2015 - Framework for software tampering detection in embedded systems.pdf:pdf},
isbn = {9781467373197},
journal = {Proceedings - 5th International Conference on Electrical Engineering and Informatics: Bridging the Knowledge between Academic, Industry, and Community, ICEEI 2015},
keywords = {Embedded Systems,Software Integrity,Software Tampering,Tampering Detection},
number = {January 2016},
pages = {259--264},
title = {{Framework for software tampering detection in embedded systems}},
year = {2015}
}
@article{Fletcher2012,
abstract = {This paper considers encrypted computation where the user specifies encrypted inputs to an untrusted program, and the server computes on those encrypted inputs. To this end we propose a secure processor architecture, called Ascend, that guarantees privacy of data when arbitrary programs use the data running in a cloud-like environment (e.g., an untrusted server running an untrusted software stack). The key idea to guarantee privacy is obfuscated instruction execution; Ascend does not disclose what instruction is being run at any given time, be it an arithmetic instruction or a memory instruction. Periodic accesses to external instruction and data memory are performed through an Oblivious RAM (ORAM) interface to prevent leakage through memory access patterns. We evaluate the processor architecture on SPEC benchmarks running on encrypted data and quantify overheads.},
author = {Fletcher, Christopher W. and van Dijk, Marten and Devadas, Srinivas},
doi = {10.1145/2382536.2382540},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Fletcher, Dijk, Devadas - 2012 - A secure processor architecture for encrypted computation on untrusted programs.pdf:pdf},
isbn = {9781450316620},
keywords = {encrypted computation,secure processors},
pages = {3},
title = {{A secure processor architecture for encrypted computation on untrusted programs}},
year = {2012}
}
@article{Liljestrand2018,
abstract = {Run-time attacks against programs written in memory-unsafe programming languages (e.g., C and C++) remain a prominent threat against computer systems. The prevalence of techniques like return-oriented programming (ROP) in attacking real-world systems has prompted major processor manufacturers to design hardware-based countermeasures against specific classes of run-time attacks. An example is the recently added support for pointer authentication (PA) in the ARMv8-A processor architecture, commonly used in devices like smartphones. PA is a low-cost technique to authenticate pointers so as to resist memory vulnerabilities. It has been shown to enable practical protection against memory vulnerabilities that corrupt return addresses or function pointers. However, so far, PA has received very little attention as a general purpose protection mechanism to harden software against various classes of memory attacks. In this paper, we use PA to build novel defenses against various classes of run-time attacks, including the first PA-based mechanism for data pointer integrity. We present PARTS, an instrumentation framework that integrates our PA-based defenses into the LLVM compiler and the GNU/Linux operating system and show, via systematic evaluation, that PARTS provides better protection than current solutions at a reasonable performance overhead},
archivePrefix = {arXiv},
arxivId = {1811.09189},
author = {Liljestrand, Hans and Nyman, Thomas and Wang, Kui and Perez, Carlos Chinea and Ekberg, Jan-Erik and Asokan, N.},
eprint = {1811.09189},
file = {:D$\backslash$:/Downloads/1811.09189.pdf:pdf},
title = {{PAC it up: Towards Pointer Integrity using ARM Pointer Authentication}},
url = {http://arxiv.org/abs/1811.09189},
year = {2018}
}
@inproceedings{Miremadi,
author = {Miremadi, G. and Harlsson, J. and Gunneflo, U. and Torin, J.},
booktitle = {[1992] Digest of Papers. FTCS-22: The Twenty-Second International Symposium on Fault-Tolerant Computing},
doi = {10.1109/FTCS.1992.243568},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Miremadi et al. - Unknown - Two software techniques for on-line error detection.pdf:pdf},
isbn = {0-8186-2875-8},
pages = {328--335},
publisher = {IEEE},
title = {{Two software techniques for on-line error detection}},
url = {http://ieeexplore.ieee.org/document/243568/}
}
@article{Rauter2015,
abstract = {{\textcopyright} 2015 EDAA. Although software fault prevention techniques improve continually, faults remain in every complex software system. Thus safety-critical embedded systems need mechanisms to tolerate software faults. Typically, these systems use static redundancy to detect hardware faults during operation. However, the reliability of a redundant system not only depends on the reliability of each version, but also on the dissimilarity between them. Thus, researchers have investigated ways to automatically add cost-efficient diversity to software to increase the efficiency of redundancy strategies. One of these automated software diversification methods is diverse compiling, which exploits the diversity introduced by different compilers and different optimization flags. Today, diverse compiling is used to improve the hardware fault tolerance and to avoid common defects from compilers. However, in this paper we show that diverse compiling also enhances the software fault tolerance by increasing the chance of finding defects in the source code of the executed software during runtime. More precisely, the memory is organized differently, when using different compilers and compiler flags. This enhances the chance of detecting memory-related software bugs, such as missing memory initialization, during runtime. Here we experimentally quantify the efficiency of diverse compiling for software fault tolerance and we show that diverse compiling can help to detect up to about 70{\%} of memory-related software bugs.},
author = {Rauter, Tobias and H{\"{o}}ller, Andrea and Kreiner, Christian and Kajtazovic, Nermin and R{\"{o}}mer, Kay},
doi = {10.7873/date.2015.0118},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Rauter et al. - 2015 - Evaluation of Diverse Compiling for Software-Fault Detection.pdf:pdf},
isbn = {9783981537048},
pages = {531--536},
title = {{Evaluation of Diverse Compiling for Software-Fault Detection}},
year = {2015}
}
@article{Wang2016,
abstract = {Critical infrastructure components nowadays use microprocessor-based embedded control systems. It is often infeasible, however, to employ the same level of security measures used in general purpose computing systems, due to the stringent performance and resource constraints of embedded control systems. Furthermore, as software sits atop and relies on the firmware for proper operation, software-level techniques cannot detect malicious behavior of the firmware. In this work, we propose ConFirm, a low-cost technique to detect malicious modifications in the firmware of embedded control systems by measuring the number of low-level hardware events that occur during the execution of the firmware. In order to count these events, ConFirm leverages the Hardware Performance Counters (HPCs), which readily exist in many embedded processors. We evaluate the detection capability and performance overhead of the proposed technique on various types of firmware running on ARM- and PowerPC-based embedded processors. Experimental results demonstrate that ConFirm can detect all the tested modifications with low performance overhead. {\textcopyright} 2015 IEEE.},
annote = {Combination of checkpoint checking and secure boot},
author = {Wang, Xueyang and Konstantinou, Charalambos and Maniatakos, Michail and Karri, Ramesh},
doi = {10.1109/ICCAD.2015.7372617},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Wang et al. - 2016 - ConFirm Detecting firmware modifications in embedded systems using Hardware Performance Counters.pdf:pdf},
isbn = {9781467383882},
issn = {1933-7760},
journal = {2015 IEEE/ACM International Conference on Computer-Aided Design, ICCAD 2015},
pages = {544--551},
publisher = {IEEE},
title = {{ConFirm: Detecting firmware modifications in embedded systems using Hardware Performance Counters}},
year = {2016}
}
@article{Guin2014,
abstract = {As the electronic component supply chain grows more complex due to globalization, with parts coming from a diverse set of suppliers, counterfeit electronics have become a major challenge that calls for immediate solutions. Currently, there are a few standards and programs available that address the testing for such counterfeit parts. However, not enough research has yet addressed the detection and avoidance of all counterfeit partsVrecycled, remarked, overproduced, cloned, out-of-spec/defective, and forged documentationVcurrently infiltrating the electronic component supply chain. Even if they work initially, all these parts may have reduced lifetime and pose reliability risks. In this tutorial, we will provide a review of some of the existing counterfeit detection and avoidance methods. We will also discuss the challenges ahead for implementing these methods, as well as the development of new detection and avoidance mechanisms.},
author = {Guin, Ujjwal and Dimase, Daniel and Tehranipoor, Mohammad},
doi = {10.1007/s10836-013-5430-8},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Guin, Dimase, Tehranipoor - 2014 - Counterfeit integrated circuits Detection, avoidance, and the challenges ahead.pdf:pdf},
issn = {15730727},
journal = {Journal of Electronic Testing: Theory and Applications (JETTA)},
keywords = {Counterfeit ICs,Counterfeit detection and avoidance,Electronic component supply chain},
number = {1},
pages = {9--23},
title = {{Counterfeit integrated circuits: Detection, avoidance, and the challenges ahead}},
volume = {30},
year = {2014}
}
@article{Chang2002,
abstract = {Protection of software code against illegitimate modifications by its users is a pressing issue to many software developers. Many software-based mechanisms for protecting program code are too weak (e.g., they have single points of failure) or too expensive to apply (e.g., they incur heavy runtime performance penalty to the protected programs). In this paper, we present and explore a methodology that we believe can protect program integrity in a more tamper-resilient and flexible manner. Our approach is based on a distributed scheme, in which protection and tamper-resistance of program code is achieved, not by a single security module, but by a network of (smaller) security units that work together in the program. These security units, or guards, can be programmed to do certain tasks (checksumming the program code is one example) and a network of them can reinforce the protection of each other by creating mutual-protection. We have implemented a system for automating the process of installing guards into Win32 executables. It is because our system operates on binaries that we are able to apply our protection mechanism to EXEs and DLLs. Experimental results show that memory space and runtime performance impacts incurred by guards can be kept very low (as explained later in the paper).},
author = {Chang, Hoi and Atallah, Mikhail J.},
doi = {10.1007/3-540-47870-1_10},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chang, Atallah - 2002 - Protecting software code by guards.pdf:pdf},
isbn = {3540436774},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {160--175},
title = {{Protecting software code by guards}},
volume = {2320},
year = {2002}
}
@inproceedings{DiNatale2017,
abstract = {{\textcopyright} 2017 IEEE. Many techniques have been proposed in literature to cope with transient, permanent and malicious faults in computing systems. Among these techniques for reliability improvement and fault tolerance, Control Flow Checking allows covering any fault affecting the part of the storing elements containing the executable program, as well as all the hardware components handling the program itself and its flow. In [1] the authors proposed a low-overhead solution implementing hardware based control flow monitoring technique. They suggested that control flow error detection could be also used as a solution for enhancing the security of a computing system, preventing the insertion of malicious code in an application. In this paper we present a technique to map a malicious program into another one without structure violation and thus bypassing the control flow detection method.},
author = {{Di Natale}, Giorgio and Flottes, Marie Lise and Dupuis, Sophie and Rouzeyre, Bruno},
booktitle = {2017 2nd International Verification and Security Workshop, IVSW 2017},
doi = {10.1109/IVSW.2017.8031544},
isbn = {9781538617083},
title = {{Hacking the Control Flow error detection mechanism}},
year = {2017}
}
@article{SrivastavaA.2004,
abstract = {ATOM (Analysis Tools with OM) is a single framework for building a wide range of customized program analysis tools. It provides the common infrastructure present in all code-instrumenting tools; this is the difficult and time-consuming part. The user simply defines the tool-specific details in instrumentation and analysis routines. Building a basic block counting tool like Pixie with ATOM requires only a page of code. ATOM, using OM link-time technology, organizes the final executable such that the application program and user's analysis routines run in the same address space. Information is directly passed from the application program to the analysis routines through simple procedure calls instead of inter-process communication or files on disk. ATOM takes care that analysis routines do not interfere with the program's execution, and precise information about the program is presented to the analysis routines at all times. ATOM uses no simulation or interpretation. ATOM has been implemented on the Alpha AXP under OSF/1. It is efficient and has been used to build a diverse set of tools for basic block counting, profiling, dynamic memory recording, instruction and data cache simulation, pipeline simulation, evaluating branch prediction, and instruction scheduling.},
author = {{Srivastava A.}, Eustace A},
file = {:D$\backslash$:/Downloads/atom.pdf:pdf},
isbn = {1581136234},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {Algorithms; Block codes; Buffer storage; Computer,Analysis tools with OM (ATOM); Instruction schedu,Computer programming languages},
number = {4},
pages = {530--539},
title = {{ATOM: A system for building customized program analysis tools}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3142675108{\&}partnerID=40{\&}md5=c19e7fb8e2ca6e5c7307bccefee400bb},
volume = {39},
year = {2004}
}
@article{Nyman2015,
abstract = {New types of Trusted Execution Environment (TEE) architectures like TrustLite and Intel Software Guard Extensions (SGX) are emerging. They bring new features that can lead to innovative security and privacy solutions. But each new TEE environment comes with its own set of interfaces and programming paradigms, thus raising the barrier for entry for developers who want to make use of these TEEs. In this paper, we motivate the need for realizing standard TEE interfaces on such emerging TEE architectures and show that this exercise is not straightforward. We report on our on-going work in mapping GlobalPlatform standard interfaces to TrustLite and SGX.},
archivePrefix = {arXiv},
arxivId = {arXiv:1506.07739v2},
author = {Nyman, Thomas and McGillion, Brian and Asokan, N.},
doi = {10.1007/978-3-319-22846-4_4},
eprint = {arXiv:1506.07739v2},
file = {:D$\backslash$:/Downloads/1506.07739.pdf:pdf},
isbn = {9783319228457},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {58--67},
title = {{On making emerging trusted execution environments accessible to developers}},
volume = {9229},
year = {2015}
}
@article{Venkatasubramanian2003,
abstract = {A control flow fault occurs when a processor fetches and executes an incorrect next instruction. Executable assertions, i.e., special instructions that check some invariant properties of a program, provide a powerful and low-cost method for on-line detection of hardware-induced control flow faults. We propose a technique called ACFC (Assertions for Control Flow Checking) that assigns an execution parity to a basic block, and uses the parity bit to detect faults. Using a graph model of a program, we classify control flow faults into skip, re-execute and multi-path faults. We derive some necessary conditions for these faults to manifest themselves as execution parity errors. To force a control flow fault to excite a parity error, the target program is instrumented with additional instructions. Special assertions are inserted to detect such parity errors. We have a developed a preprocessor that takes a C program as input and inserts ACFC assertions automatically. We have implemented a software-based fault injection tool SFIG which takes advantage of the GNU debugger. Fault injection experiments show that ACFC incurs less performance overhead (around 47{\%}) and memory overhead (around 30{\%}) than previous techniques, with no significant loss in fault coverage.},
author = {Venkatasubramanian, Rajesh and Hayes, J. P. and Murray, B. T.},
doi = {10.1109/OLT.2003.1214380},
file = {:D$\backslash$:/Downloads/01214380.pdf:pdf},
isbn = {0769519687},
journal = {Proceedings - 9th IEEE International On-Line Testing Symposium, IOLTS 2003},
keywords = {Automotive engineering,Computer architecture,Costs,Fault detection,Instruments,Laboratories,Performance loss,Registers,Rivers,Testing},
pages = {137--143},
title = {{Low-cost on-line fault detection using control flow assertions}},
year = {2003}
}
@article{USENIXAssociation.2003,
author = {{USENIX Association.}, Andrei and Zaddach, Jonas and Francillon, Aur{\'{e}}lien and Balzarotti, Davide},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/USENIX Association. et al. - 2003 - Proceedings of the seventeenth Large Installation Systems Administration Conference (LISA XVII) Oct.pdf:pdf},
isbn = {9781931971157},
pages = {256},
title = {{Proceedings of the seventeenth Large Installation Systems Administration Conference (LISA XVII) : October 26-31, 2003 San Diego, CA, USA}},
year = {2003}
}
@phdthesis{Nyberg2018,
author = {Nyberg, Ralph Heinz-erik},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Nyberg - 2018 - New Techniques for Emulating Fault Attacks.pdf:pdf},
school = {Technische Universitat M ¨ unchen},
title = {{New Techniques for Emulating Fault Attacks}},
year = {2018}
}
@article{Moro2014a,
abstract = {njection of transient faults can be used as a way to attack embedded systems. On embedded processors such as microcontrollers, several studies showed that such a transient fault injection with glitches or electromagnetic pulses could corrupt either the data loads from the memory or the assembly instructions executed by the circuit. Some countermeasure schemes which rely on temporal redundancy have been proposed to handle this issue. Among them, several schemes add this redundancy at assembly instruction level. In this paper, we perform a practical evaluation for two of those countermeasure schemes by using a pulsed electromagnetic fault injection process on a 32-bit microcontroller. We provide some necessary conditions for an efficient implementation of those countermeasure schemes in practice. We also evaluate their efficiency and highlight their limitations. To the best of our knowledge, no experimental evaluation of the security of such instruction-level countermeasure schemes has been published yet.},
author = {Moro, Nicolas and Heydemann, Karine and Dehbaoui, Amine and Robisson, Bruno and Encrenaz, Emmanuelle},
doi = {10.1109/HST.2014.6855580},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Moro et al. - 2014 - Experimental evaluation of two software countermeasures against fault attacks.pdf:pdf},
isbn = {9781479941148},
journal = {Proceedings of the 2014 IEEE International Symposium on Hardware-Oriented Security and Trust, HOST 2014},
keywords = {assembly,countermeasure,fault injection,instruction skip,microcontroller},
pages = {112--117},
publisher = {IEEE},
title = {{Experimental evaluation of two software countermeasures against fault attacks}},
year = {2014}
}
@article{DAU2011,
author = {DAU},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/DAU - 2011 - Defense Acquisition Guidebook.pdf:pdf},
pages = {1--969},
title = {{Defense Acquisition Guidebook}},
url = {https://www.dau.mil/tools/dag},
year = {2011}
}
@article{Cheng2019,
abstract = {Data-oriented attacks manipulate non-control data to alter a program's benign behavior without violating its control-flow integrity. It has been shown that such attacks can cause significant damage even in the presence of control-flow defense mechanisms. However, these threats have not been adequately addressed. In this SoK paper, we first map data-oriented exploits, including Data-Oriented Programming (DOP) attacks, to their assumptions/requirements and attack capabilities. We also compare known defenses against these attacks, in terms of approach, detection capabilities, overhead, and compatibility. Then, we experimentally assess the feasibility of a detection approach that is based on the Intel Processor Trace (PT) technology. PT only traces control flows, thus, is generally believed to be not useful for data-oriented security. However, our work reveals that data-oriented attacks (in particular the recent DOP attacks) may generate side-effects on control-flow behavior in multiple dimensions, which manifest in PT traces. Based on this evaluation, we discuss challenges for building deployable data-oriented defenses and open research questions.},
archivePrefix = {arXiv},
arxivId = {1902.08359},
author = {Cheng, Long and Liljestrand, Hans and Nyman, Thomas and Lee, Yu Tsung and Yao, Danfeng and Jaeger, Trent and Asokan, N.},
eprint = {1902.08359},
file = {:D$\backslash$:/Downloads/1902.08359.pdf:pdf},
title = {{Exploitation Techniques and Defenses for Data-Oriented Attacks}},
url = {http://arxiv.org/abs/1902.08359},
year = {2019}
}
@article{Collberg2002,
abstract = {We identify three types of attack on the intellectual property contained in software and three corresponding technical defenses. A defense against reverse engineering is obfuscation, a process that renders software unintelligible but still functional. A defense against software piracy is watermarking, a process that makes it possible to determine the origin of software. A defense against tampering is tamper-proofing, so that unauthorized modifications to software (for example, to remove a watermark) will result in nonfunctional code. We briefly survey the available technology for each type of defense.},
annote = {4 Tamper-Proofing is a good section},
author = {Collberg, Christian S. and Thomborson, Clark},
doi = {10.1109/TSE.2002.1027797},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Collberg, Thomborson - 2002 - Watermarking, tamper-proofing, and obfuscation - Tools for software protection.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Intellectual property protection,Obfuscation,Tamper-proofing,Watermarking},
number = {8},
pages = {735--746},
publisher = {IEEE},
title = {{Watermarking, tamper-proofing, and obfuscation - Tools for software protection}},
volume = {28},
year = {2002}
}
@article{Ott2018,
author = {Ott, Karl and Mahapatra, Rabi},
doi = {10.1109/DASC/PiCom/DataCom/CyberSciTec.2018.00101},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ott, Mahapatra - 2018 - Hardware performance counters for embedded software anomaly detection.pdf:pdf},
isbn = {9781538675182},
journal = {Proceedings - IEEE 16th International Conference on Dependable, Autonomic and Secure Computing, IEEE 16th International Conference on Pervasive Intelligence and Computing, IEEE 4th International Conference on Big Data Intelligence and Computing and IEEE 3},
keywords = {Embedded Systems,Hardware Performance Counters,Security},
pages = {528--535},
publisher = {IEEE},
title = {{Hardware performance counters for embedded software anomaly detection}},
year = {2018}
}
@article{Skorobogatov2005,
abstract = {Semiconductor chips are used today not only to control systems, but also to protect them against security threats. A continuous battle is waged between manufacturers who invent new security solutions, learning their lessons from previous mistakes, and the hacker community, constantly trying to break implemented protections. Some chip manufacturers do not pay enough attention to the proper design and testing of protection mechanisms. Even where they claim their products are highly secure, they do not guarantee this and do not take any responsibility if a device is compromised. In this situation, it is crucial for the design engineer to have a convenient and reliable method of testing secure chips. This thesis presents a wide range of attacks on hardware security in microcontrollers and smartcards. This includes already known non-invasive attacks, such as power analysis and glitching, and invasive attacks, such as reverse engineering and microprobing. A new class of attacks – semi-invasive attacks – is introduced. Like invasive attacks, they require depackaging the chip to get access to its surface. But the passivation layer remains intact, as these methods do not require electrical contact to internal lines. Semi-invasive attacks stand between noninvasive and invasive attacks. They represent a greater threat to hardware security, as they are almost as effective as invasive attacks but can be low-cost like non-invasive attacks. This thesis' contribution includes practical fault-injection attacks to modify SRAM and EEPROM content, or change the state of any individual CMOS transistor on a chip. This leads to almost unlimited capabilities to control chip operation and circumvent protection mechanisms. A second contribution consist of experiments on data remanence, which show that it is feasible to extract information from powered-off SRAM and erased EPROM, EEPROM and Flash memory devices. A brief introduction to copy protection in microcontrollers is given. Hardware security evaluation techniques using semi-invasive methods are introduced. They should help developers to make a proper selection of components according to the required level of security. Various defence technologies are discussed, from low-cost obscurity methods to new approaches in silicon design.},
author = {Skorobogatov, Sergei P.},
file = {:D$\backslash$:/Downloads/UCAM-CL-TR-630.pdf:pdf},
issn = {1476-2986},
journal = {Technical report, University of Cambridge, Computer Laboratory},
number = {630},
pages = {144},
title = {{Semi-invasive attacks-a new approach to hardware security analysis}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.228.2204{\&}rep=rep1{\&}type=pdf},
year = {2005}
}
@inproceedings{Goloubeva2003,
abstract = {Over the last years, an increasing number of safety-critical tasks have been demanded to computer systems. In this paper, a software-based approach for developing safety-critical applications is analyzed. The technique is based on the introduction of additional executable assertions to check the correct execution of the program control flow. By applying the proposed technique, several benchmark applications have been hardened against transient errors. Fault Injection campaigns have been performed to evaluate the fault detection capability of the proposed technique in comparison with state-of-the-art alternative assertion- based methods. Experimental results show that the proposed approach is far more effective than the other considered techniques in terms of fault detection capability, at the cost of a limited increase in memory requirements and in performance overhead.},
author = {Goloubeva, O. and Rebaudengo, M. and {Sonza Reorda}, M. and Violante, M.},
booktitle = {Proceedings. 16th IEEE Symposium on Computer Arithmetic},
doi = {10.1109/DFTVS.2003.1250158},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Goloubeva et al. - 2003 - Soft-error detection using control flow assertions.pdf:pdf},
isbn = {0-7695-2042-1},
issn = {0887-2171},
month = {nov},
number = {2},
pages = {581--588},
publisher = {IEEE Comput. Soc},
title = {{Soft-error detection using control flow assertions}},
url = {http://ieeexplore.ieee.org/document/1250158/},
volume = {16},
year = {2003}
}
@article{Edwards2001,
abstract = {Distributed computing on the Internet presents new challenges and$\backslash$nopportunities for tools that inspect and modify program binaries.$\backslash$nThe dynamic and heterogeneous nature of the Internet environment$\backslash$nextends the traditional product development process by requiring$\backslash$nprogram development tools like these, which were once used only internally,$\backslash$nto work in live environments too. The concept of compilation process$\backslash$nmust be expanded along with the capabilities of the binary tools.$\backslash$nThis paper presents Vulcan, a second-generation technology that addresses$\backslash$nmany of these challenges. Vulcan provides both static and dynamic$\backslash$ncode modification and provides a framework for cross-component analysis$\backslash$nand optimization. It provides system-level analysis for heterogeneous$\backslash$nbinaries across instruction sets. Vulcan works in the Win32 environment$\backslash$nand can process x86, IA64, and MSIL binaries. Vulcan scales to large$\backslash$ncommercial applications and has been used to improve performance$\backslash$nand reliability of Microsoft products in a production environment.},
author = {Edwards, Andrew and Srivastava, Amitabh and Vo, Hoi},
file = {:D$\backslash$:/Downloads/tr-2001-50.pdf:pdf},
pages = {12},
title = {{Vulcan: Binary transformation in a distributed environment}},
url = {https://www.microsoft.com/en-us/research/publication/vulcan-binary-transformation-in-a-distributed-environment/},
year = {2001}
}
@article{McGillion2015,
abstract = {Hardware-based Trusted Execution Environments (TEEs) are widely deployed in mobile devices. Yet their use has been limited primarily to applications developed by the device vendors. Recent standardization of TEE interfaces by GlobalPlatform (GP) promises to partially address this problem by enabling GP-compliant trusted applications to run on TEEs from different vendors. Nevertheless ordinary developers wishing to develop trusted applications face significant challenges. Access to hardware TEE interfaces are difficult to obtain without support from vendors. Tools and software needed to develop and debug trusted applications may be expensive or non-existent. In this paper, we describe Open-TEE, a virtual, hardware-independent TEE implemented in software. Open-TEE conforms to GP specifications. It allows developers to develop and debug trusted applications with the same tools they use for developing software in general. Once a trusted application is fully debugged, it can be compiled for any actual hardware TEE. Through performance measurements and a user study we demonstrate that Open-TEE is efficient and easy to use. We have made Open- TEE freely available as open source.},
archivePrefix = {arXiv},
arxivId = {arXiv:1506.07367v2},
author = {McGillion, Brian and Dettenborn, Tanel and Nyman, Thomas and Asokan, N.},
doi = {10.1109/Trustcom.2015.400},
eprint = {arXiv:1506.07367v2},
file = {:D$\backslash$:/Downloads/1506.07367.pdf:pdf},
isbn = {9781467379519},
journal = {Proceedings - 14th IEEE International Conference on Trust, Security and Privacy in Computing and Communications, TrustCom 2015},
keywords = {GlobalPlatform,Hardware security,Open source,Software development,Trusted Execution Environments,Usability},
pages = {400--407},
title = {{Open-TEE - An open virtual trusted execution environment}},
volume = {1},
year = {2015}
}
@article{Thompson1984,
author = {Thompson, K E N},
file = {:D$\backslash$:/Downloads/p761-thompson.pdf:pdf},
number = {8},
pages = {761--763},
title = {{Reflections on Trusting Trust}},
volume = {27},
year = {1984}
}
@article{Schuster2017,
abstract = {{\textcopyright} 2017 ACM. Soft errors are a challenging and urging problem in the domain of safety-critical embedded systems. For decades, checking schemes have been investigated and improved to mitigate soft-error effects for the class of control-flow faults, with current industrial standards strongly recommending their use. However, reality looks different: Taking a systems perspective, we implemented four representative Control-Flow Checking (CFC) schemes and put them through their paces in 396 fault-injection campaigns. In contrast to previous work, which typically relied on probability-based vulnerability metrics, we accounted for the influence of memory and time overheads on the fault-space dimensions and applied those in full-scan fault injections. This change in procedure alone severely degraded the perceived effectiveness of CFC. In addition, we expanded the perspective to data-flow faults and their influence on the overall susceptibility, an aspect that so far has been largely ignored. Our results suggest that, without accompanying measures, any improvement regarding control-flow faults is dominated by the increase in data faults caused by the increased attac k surface in terms of memory and runtime overhead. Moreover, CFC performance less depended on the detection capabilities than on general aspects of the concrete binary compilation and execution. In conclusion, incorporating CFC is not as straightforward as often assumed and the vulnerability of systems with hardened control-flow may in many cases even be increased by the schemes themselves.},
author = {Schuster, Simon and Ulbrich, Peter and Stilkerich, Isabella and Dietrich, Christian and Schr{\"{o}}Der-Preikschat, Wolfgang},
doi = {10.1145/3126503},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Schuster et al. - 2017 - Demystifying Soft-Error Mitigation by Control-Flow Checking -- A New Perspective on its Effectiveness.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {5s},
pages = {1--19},
title = {{Demystifying Soft-Error Mitigation by Control-Flow Checking -- A New Perspective on its Effectiveness}},
url = {http://dl.acm.org/citation.cfm?doid=3145508.3126503},
volume = {16},
year = {2017}
}
@article{TCG2007,
author = {TCG},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/TCG - 2007 - TCG TCG Specification Architecture Overview Specification Revision 1.4 2 nd.pdf:pdf},
number = {August},
title = {{TCG TCG Specification Architecture Overview Specification Revision 1.4 2 nd}},
url = {https://trustedcomputinggroup.org/wp-content/uploads/TCG{\_}1{\_}4{\_}Architecture{\_}Overview.pdf},
year = {2007}
}
@article{Ergun2000,
abstract = {On Labor Day weekend, the highway patrol sets up spot-checks at random points on the freeways with the intention of deterring a large fraction of motorists from driving incorrectly. We explore a very similar idea in the context of program checking to ascertain with minimal overhead that a program output is reasonably correct. Our model of spot-checking requires that the spot-checker must run asymptotically much faster than the combined length of the input and output. We then show that the spot-checking model can be applied to problems in a wide range of areas, including problems regarding graphs, sets, and algebra. In particular, we present spot-checkers for sorting, convex hull, element distinctness, set containment, set equality, total orders, and correctness of group and field operations. All of our spot-checkers are very simple to state and rely on testing that the input and/or output have certain simple properties that depend on very few bits. Our results also give property tests as defined by Rubinfeld and Sudan (1996, SIAM J. Comput. 25, 252-271), Rubinfeld (1994, 'Proc. 35th Foundations of Computer Science,' pp. 288-299), and Goldreich et al. (1998, J. Assoc. Comput. Mach. 45, 653-750).},
author = {Erg{\"{u}}n, Funda and Kannan, Sampath and Kumar, S. Ravi and Rubinfeld, Ronitt and Viswanathan, Mahesh},
doi = {10.1006/jcss.1999.1692},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Erg{\"{u}}n et al. - 2000 - Spot-checkers.pdf:pdf},
issn = {00220000},
journal = {Journal of Computer and System Sciences},
number = {3},
pages = {717--751},
title = {{Spot-checkers}},
volume = {60},
year = {2000}
}
@article{Chen2007,
abstract = {[1] Y. Chen, R. Venkatesan, M. Cary, R. Pang, S. Sinha, and M. H. Jakubowski, “Oblivious Hashing : A Stealthy Software Integrity Verification Primitive,” in 5th International Workshop on Information Hiding, 2002, pp. 400–414.},
author = {Chen, Yuqun and Sinha, Saurabh and Venkatesan, Ramarathnam and Pang, Ruoming and Jakubowski, Mariusz H. and Cary, Matthew},
doi = {10.1007/3-540-36415-3_26},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chen et al. - 2007 - Oblivious Hashing A Stealthy Software Integrity Verification Primitive.pdf:pdf},
pages = {400--414},
title = {{Oblivious Hashing: A Stealthy Software Integrity Verification Primitive}},
year = {2007}
}
@article{Erlingsson2004,
abstract = {SASI (Security Automata SFI Implementation) enforces security policies by modifying object code for a target system before that system is executed. The approach has been prototyped for two rather different machine architec-tures: Intel x86 and Java JVML. Details of these prototypes and some generalizations about the SASI approach are discussed .},
author = {Erlingsson, {\'{U}}lfar and Schneider, Fred B.},
doi = {10.1145/335169.335201},
file = {:D$\backslash$:/Downloads/00821527.pdf:pdf},
isbn = {3060296103},
number = {September},
pages = {87--95},
title = {{SASI enforcement of security policies}},
year = {2004}
}
@article{Burow,
author = {Burow, Nathan},
file = {:D$\backslash$:/Downloads/17CSUR.pdf:pdf},
title = {{Control-Flow Integrity : Precision , Security , and Performance}},
volume = {V}
}
@article{Carlini2015,
author = {Carlini, Nicolas and Barresi, Antonio and Z{\"{u}}rich, E T H and Payer, Mathias and Wagner, David and Gross, Thomas R and Z{\"{u}}rich, E T H and Carlini, Nicolas and Barresi, Antonio and Wagner, David and Gross, Thomas R},
file = {:D$\backslash$:/Downloads/sec15-paper-carlini.pdf:pdf},
isbn = {9781931971232},
title = {{Sec15-Paper-Carlini}},
year = {2015}
}
@article{Kinder2012,
abstract = {Unresolved indirect branch instructions are a major obstacle for statically reconstructing a control flow graph (CFG) from machine code. If static analysis cannot compute a precise set of possible targets for a branch, the necessary conservative over-approximation introduces a large amount of spurious edges, leading to even more imprecision and a degenerate CFG. In this paper, we propose to leverage under-approximation to handle this problem. We provide an abstract interpretation framework for control flow reconstruction that alternates between over- and under-approximation. Effectively, the framework imposes additional preconditions on the program on demand, allowing to avoid conservative over-approximation of indirect branches. We give an example instantiation of our framework using dynamically observed execution traces and constant propagation. We report preliminary experimental results confirming that our alternating analysis yields CFGs closer to the concrete CFG than pure over- or under-approximation.},
author = {Kinder, Johannes and Kravchenko, Dmitry},
file = {:D$\backslash$:/Downloads/Kinder-Kravchenko2012{\_}Chapter{\_}AlternatingControlFlowReconstr.pdf:pdf},
journal = {Verification, Model Checking, and Abstract Interpretation},
pages = {267--282},
title = {{LNCS 7148 - Alternating Control Flow Reconstruction}},
year = {2012}
}
@article{Kayaalp2014,
abstract = {Code reuse attacks (CRAs) are recent security exploits that allow attackers to execute arbitrary code on a compromised machine. CRAs, exemplified by return-oriented and jump-oriented programming approaches, reuse fragments of the library code, thus avoiding the need for explicit injection of attack code on the stack. Since the executed code is reused existing code, CRAs bypass current hardware and software security measures that prevent execution from data or stack regions of memory. While software- based full control flow integrity (CFI) checking can protect against CRAs, it includes significant overhead, involves non-trivial effort of constructing a control flow graph, relies on proprietary tools and has potential vulnerabilities due to the presence of unintended branch instructions in architectures such as x86—those branches are not checked by the software CFI.We propose branch regulation (BR), a lightweight hardware-supported protection mechanism against the CRAs that addresses all limitations of software CFI. BR enforces simple control flow rules in hardware at the function granularity to disallow arbitrary control flow transfers from one function into the middle of another function. This prevents common classes of CRAs without the complexity and run-time overhead of full CFI enforcement. BR incurs a slowdown of about 2{\%} and increases the code footprint by less than 1{\%} on the average for the SPEC 2006 benchmarks.},
author = {Kayaalp, Mehmet and Ozsoy, Meltem and Ghazaleh, Nael Abu and Ponomarev, Dmitry},
doi = {10.1109/TC.2012.269},
file = {:D$\backslash$:/Downloads/06355533.pdf:pdf},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Security,code reuse attacks,microarchitecture},
number = {5},
pages = {1144--1156},
publisher = {IEEE},
title = {{Efficiently securing systems from code reuse attacks}},
volume = {63},
year = {2014}
}
@article{Mao2010,
abstract = {The inherent limitations of embedded systems make them particularly vulnerable to attacks. We have developed a hardware monitor that operates in parallel to an embedded processor and detects any attack that causes the embedded processor to deviate from its originally programmed behavior. We explore several different characteristics that can be used for monitoring and quantify trade-offs between these approaches. Our results show that our proposed hash-based monitoring pattern can detect attacks within one instruction cycle at lower memory requirements than traditional approaches that use control flow information.},
author = {Mao, Shufu and Wolf, Tilman},
doi = {10.1109/TC.2010.32},
file = {:D$\backslash$:/Downloads/05406503.pdf:pdf},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Embedded system security,Processing monitor,Security enforcement},
number = {6},
pages = {847--854},
publisher = {IEEE},
title = {{Hardware support for secure processing in embedded systems}},
volume = {59},
year = {2010}
}
@article{He2017,
author = {He, Wenjian and Das, Sanjeev and Zhang, Wei and Liu, Yang},
doi = {10.1145/3061639.3062291},
file = {:D$\backslash$:/Downloads/08060307.pdf:pdf},
pages = {1--6},
title = {{No-Jump-into-Basic-Block}},
year = {2017}
}
@article{Corporation2017,
abstract = {Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non‐infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. This document contains information on products, services and/or processes in development. All information provided here is subject to change without notice. Contact your Intel representative to obtain the latest forecast, schedule, specifications and roadmaps. The products and services described may contain defects or errors known as errata which may cause deviations from published specifications. Current characterized errata are available on request. Intel technologies' features and benefits depend on system configuration and may require enabled hardware, software or service activation. Performance varies depending on system configuration.},
author = {Corporation, Intel},
file = {:D$\backslash$:/Downloads/control-flow-enforcement-technology-preview.pdf:pdf},
journal = {Intel Specifications},
number = {June},
pages = {1--136},
title = {{Control-flow Enforcement Technology Preview}},
url = {http://intel.com/.{\%}0Awww.intel.com/design/literature.htm.},
year = {2017}
}
@article{Security2017,
author = {Security, Qualcomm Product},
file = {:D$\backslash$:/Downloads/whitepaper-pointer-authentication-on-armv8-3.pdf:pdf},
number = {January},
title = {{Pointer Authentication on ARMv8.3 Design and Analysis of the New Software Security Instructions}},
year = {2017}
}
@article{Korner2012,
author = {Korner, Thomas William},
file = {:D$\backslash$:/Downloads/cpi.pdf:pdf},
isbn = {9781931971164},
journal = {Scepticism: Hero and Villain},
number = {October},
pages = {47--56},
title = {{Code-Pointer Integrity}},
url = {https://infoscience.epfl.ch/record/204783},
year = {2012}
}
@article{Kuznetsov:204783,
abstract = {Systems code is often written in low-level languages like C/C++, which offer many benefits but also delegate memory management to programmers. This invites memory safety bugs that attackers can exploit to divert control flow and compromise the system. Deployed defense mechanisms (e.g., ASLR, DEP) are incomplete, and stronger defense mechanisms (e.g., CFI) often have high overhead and limited guarantees [19, 15, 9]. We introduce code-pointer integrity (CPI), a new design point that guarantees the integrity of all code pointers in a program (e.g., function pointers, saved return addresses) and thereby prevents all control-flow hijack attacks, including return-oriented programming. We also introduce code-pointer separation (CPS), a relaxation of CPI with better performance properties. CPI and CPS offer substantially better security-to-overhead ratios than the state of the art, they are practical (we protect a complete FreeBSD system and over 100 packages like apache and postgresql), effective (prevent all attacks in the RIPE benchmark), and efficient: on SPEC CPU2006, CPS averages 1.2{\%} overhead for C and 1.9{\%} for C/C++, while CPI's overhead is 2.9{\%} for C and 8.4{\%} for C/C++. A prototype implementation of CPI and CPS can be obtained from http://levee.epfl.ch.},
author = {Kuznetsov, Volodymyr and Szekeres, L{\'{a}}szl{\'{o}} and Payer, Mathias and Candea, George and Sekar, R and Song, Dawn},
title = {{Code-Pointer Integrity}},
url = {http://infoscience.epfl.ch/record/204783},
year = {2014}
}
@article{Mashtizadeh2014,
abstract = {Recent Pwn2Own competitions have demonstrated the continued effectiveness of control hijacking attacks despite deployed countermeasures including stack canaries and ASLR. A powerful defense called Control flow Integrity (CFI) offers a principled approach to preventing such attacks. However, prior CFI implementations use static analysis and must limit protection to remain practical. These limitations have enabled attacks against all known CFI systems, as demonstrated in recent work. This paper presents a cryptographic approach to control flow integrity (CCFI) that is both fine-grain and practical: using message authentication codes (MAC) to protect control flow elements such as return addresses, function pointers, and vtable pointers. MACs on these elements prevent even powerful attackers with random read/write access to memory from tampering with program control flow. We implemented CCFI in Clang/LLVM, taking advantage of recently available cryptographic CPU instructions. We evaluate our system on several large software packages (including nginx, Apache and memcache) as well as all their dependencies. The cost of protection ranges from a 3-18{\%} decrease in request rate.},
archivePrefix = {arXiv},
arxivId = {1408.1451},
author = {Mashtizadeh, Ali Jose and Bittau, Andrea and Mazieres, David and Boneh, Dan},
eprint = {1408.1451},
file = {:D$\backslash$:/Downloads/mashtizadeh-ccfi-ccs15.pdf:pdf},
isbn = {9781450338325},
keywords = {control flow integrity,return oriented programming,vulnerabil-},
pages = {941--951},
title = {{Cryptographically Enforced Control Flow Integrity}},
url = {http://arxiv.org/abs/1408.1451},
year = {2014}
}
@article{Szekeres2013,
abstract = {Memory corruption bugs in software written in low-level languages like C or C++ are one of the oldest problems in computer security. The lack of safety in these languages allows attackers to alter the program's behavior or take full control over it by hijacking its control flow. This problem has existed for more than 30 years and a vast number of potential solutions have been proposed, yet memory corruption attacks continue to pose a serious threat. Real world exploits show that all currently deployed protections can be defeated. This paper sheds light on the primary reasons for this by describing attacks that succeed on today's systems. We systematize the current knowledge about various protection techniques by setting up a general model for memory corrup- tion attacks. Using this model we show what policies can stop which attacks. The model identifies weaknesses of currently deployed techniques, as well as other proposed protections enforcing stricter policies. We analyze the reasons why protection mechanisms imple- menting stricter polices are not deployed. To achieve wide adoption, protection mechanisms must support a multitude of features and must satisfy a host of requirements. Especially important is performance, as experience shows that only solutions whose overhead is in reasonable bounds get deployed. A comparison of different enforceable policies helps de- signers of new protection mechanisms in finding the balance between effectiveness (security) and efficiency.We identify some open research problems, and provide suggestions on improving the adoption of newer techniques.},
author = {Szekeres, L{\'{a}}szl{\'{o}} and Payer, Mathias and Wei, Tao and Song, Dawn},
doi = {10.1109/SP.2013.13},
file = {:D$\backslash$:/Downloads/06547101.pdf:pdf},
isbn = {9780769549774},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {48--62},
title = {{SoK: Eternal war in memory}},
year = {2013}
}
@article{Mahmood1988,
abstract = {Concurrent system-level error detection techniques using a watchdog processor are surveyed. A watchdog processor is a small and simple coprocessor that detects errors by monitoring the behavior of a system. Like replication, it does not depend on any fault model for error detection. However, it requires less hardware than replication. It is shown that a large number of errors can be detected by monitoring the control flow and memory-access behavior. Two techniques for control-flow checking are discussed and compared with current error-detection techniques. A scheme for memory-access checking based on capability-based addressing is described. The design of a watchdog for performing reasonable checks on the output of a main processor by executing assertions is discussed.},
author = {Mahmood, Aamer and Mccluskey, E. J.},
doi = {10.1109/12.2145},
file = {:D$\backslash$:/Downloads/00002145.pdf:pdf},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Capability-based addressing,concurrent checking,control flow checking coprocessor,distributed computing,executable assertions,microprogramming,parallel computing,signature analysis,system-level error detection,watchdog processor},
number = {2},
pages = {160--174},
publisher = {IEEE},
title = {{Concurrent Error Detection Using Watchdog Processors—A Survey}},
volume = {37},
year = {1988}
}
@article{DeClercq2017,
abstract = {CFI is a computer security technique that detects runtime attacks by monitoring a program's branching behavior. This work presents a detailed analysis of the security policies enforced by 21 recent hardware-based CFI architectures. The goal is to evaluate the security, limitations, hardware cost, performance, and practicality of using these policies. We show that many architectures are not suitable for widespread adoption, since they have practical issues, such as relying on accurate control flow model (which is difficult to obtain) or they implement policies which provide only limited security.},
archivePrefix = {arXiv},
arxivId = {1706.07257},
author = {de Clercq, Ruan and Verbauwhede, Ingrid},
eprint = {1706.07257},
file = {:D$\backslash$:/Downloads/1706.07257.pdf:pdf},
pages = {1--27},
title = {{A survey of Hardware-based Control Flow Integrity (CFI)}},
url = {http://arxiv.org/abs/1706.07257},
volume = {1},
year = {2017}
}
@incollection{Quisquater2001,
author = {Quisquater, Jean-Jacques and Samyde, David},
booktitle = {ACM Transactions on Embedded Computing Systems},
doi = {10.1007/3-540-45418-7_17},
file = {:D$\backslash$:/Downloads/Quisquater-Samyde2001{\_}Chapter{\_}ElectroMagneticAnalysisEMAMeas.pdf:pdf},
issn = {15399087},
month = {apr},
number = {3},
pages = {200--210},
title = {{ElectroMagnetic Analysis (EMA): Measures and Counter-measures for Smart Cards}},
url = {http://dl.acm.org/citation.cfm?doid=3323876.3284361 http://link.springer.com/10.1007/3-540-45418-7{\_}17},
volume = {18},
year = {2001}
}
@article{Lee2019,
author = {Lee, Robert P and Markantonakis, Konstantinos and Akram, Raja Naeem},
doi = {10.1145/3284361},
file = {:D$\backslash$:/Downloads/Robert Lee PhD.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
keywords = {Hardware-Software Binding,Internet of Things,Platform Specific Execution,Secure Application Execution},
month = {apr},
number = {3},
pages = {1--21},
title = {{Ensuring Secure Application Execution and Platform-Specific Execution in Embedded Devices}},
url = {http://dl.acm.org/citation.cfm?doid=3323876.3284361},
volume = {18},
year = {2019}
}
@inproceedings{Abadi2005,
address = {New York, New York, USA},
author = {Abadi, Mart{\'{i}}n and Budiu, Mihai and Erlingsson, {\'{U}}lfar and Ligatti, Jay},
booktitle = {Proceedings of the 12th ACM conference on Computer and communications security - CCS '05},
doi = {10.1145/1102120.1102165},
file = {:D$\backslash$:/Downloads/Abadi et al.{\_}2005{\_}Control Flow Integrity.pdf:pdf},
isbn = {1595932267},
keywords = {binary rewriting,control-flow graph,inlined reference moni-,tors,vulnerabilities},
pages = {340},
publisher = {ACM Press},
title = {{Control-flow integrity}},
url = {http://portal.acm.org/citation.cfm?doid=1102120.1102165},
year = {2005}
}
@article{Lee2016,
abstract = {Embedded systems are small scale computing devices that are increasingly located in more of the items we use and own. The number of embedded systems in the world is increasing dramatically as the “internet of things” concept becomes more prevalent in the market. The value of the market for embedded systems is predicted to increase to being worth trillions of dollars by 2020. With great value in the embedded system market, there is a need for preventing unauthorised firmware tampering or product counterfeiting. Here is presen- ted a technique for binding software to hardware instances that uses hardware intrinsic security properties of the devices being protected. The proposed technique provides assurance to manufacturers that only they can perform their hardware and software binding and create their products. Also presen- ted is an FPGA implementation of the described scheme that binds the hardware and software together with only a 6.7{\%} increase in execution time. Thus, making it difficult for an attacker to either counterfeit the device or extract the (software) Intellectual Property. Keywords},
author = {Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem},
doi = {10.1145/2899015.2899029},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Markantonakis, Akram - 2016 - Binding Hardware and Software to Prevent Firmware Modification and Device Counterfeiting.pdf:pdf},
isbn = {9781450342889},
journal = {Proceedings of the 2nd ACM International Workshop on Cyber-Physical System Security - CPSS '16},
keywords = {binding,counterfeiting,firm-,hardware,intrinsic,modification,puf,security,software,ware},
pages = {70--81},
title = {{Binding Hardware and Software to Prevent Firmware Modification and Device Counterfeiting}},
url = {http://dl.acm.org/citation.cfm?doid=2899015.2899029},
year = {2016}
}
@article{Benso2003,
abstract = {{\textcopyright} 2003 IEEE. A watchdog processor for the MOTOROLA M68040 microprocessor is presented. Its main task is to protect from transient faults caused by SEUs the transmission of data between the processor and the system memory, and to ensure a correct instructions' flow, just monitoring the external bus, without modifying the internal architecture of the M68040. A description of the principal procedures is given, together with the method used for monitoring the instructions' flow.},
author = {Benso, A. and {Di Carlo}, S. and {Di Natale}, G. and Prinetto, P.},
doi = {10.1109/OLT.2003.1214381},
file = {:D$\backslash$:/Downloads/11384490.pdf:pdf},
isbn = {0769519687},
journal = {Proceedings - 9th IEEE International On-Line Testing Symposium, IOLTS 2003},
keywords = {Aerospace electronics,Circuit faults,Electromagnetic interference,Electromagnetic radiation,Electromagnetic radiative interference,Error correction,Microprocessors,Monitoring,Protection,Wiring},
pages = {144--148},
title = {{A watchdog processor to detect data and control flow errors}},
year = {2003}
}
@article{Yang2013,
abstract = {This paper proposes a generic high-performance and low-time-overhead software control flow checking solution, graph-tree-based control flow checking (GTCFC) for space-borne commercial-off-the-shelf (COTS) processors. A graph tree data structure with a topology similar to common trees is introduced to transform the control flow graphs of target programs. This together with design of IDs and signatures of its vertices and edges allows for an easy check of legality of actual branching during target program execution. As a result, the algorithm not only is capable of detecting all single and multiple branching errors with low latency and time overheads along with a linear-complexity space overhead, but also remains generic among arbitrary instruction sets and independent of any specific hardware. Tests of the algorithm using a COTS-processor-based on-board computer (OBC) of in-service ZDPS-1A pico-satellite products show that GTCFC can detect over 90{\%} of the randomly injected and all-pattern-covering branching errors for different types of target programs, with performance and overheads consistent with the theoretical analysis; and beats well-established preeminent control flow checking algorithms in these dimensions. Furthermore, it is validated that GTCGC not only can be accommodated in pico-satellites conveniently with still sufficient system margins left, but also has the ability to minimize the risk of control flow errors being undetected in their space missions. Therefore, due to its effectiveness, efficiency, and compatibility, the GTCFC solution is ready for applications on COTS processors on pico-satellites in their real space missions. {\textcopyright} 2013 Production and hosting by Elsevier Ltd. on behalf of CSAA and BUAA.},
annote = {Good descriptions/lists of cfg techniques},
author = {Yang, Mu and Wang, Hao and Zheng, Yangming and Jin, Zhonghe},
doi = {10.1016/j.cja.2013.02.019},
file = {:D$\backslash$:/Downloads/1-s2.0-S1000936113000319-main.pdf:pdf},
issn = {10009361},
journal = {Chinese Journal of Aeronautics},
keywords = {Branching error,Commercial-off-the-shelf (COTS),Control flow checking,Error injection,Graph tree,On-board computer,Pico-satellite},
number = {2},
pages = {413--422},
publisher = {Chinese Society of Aeronautics and Astronautics},
title = {{Graph-tree-based software control flow checking for COTS processors on pico-satellites}},
url = {http://dx.doi.org/10.1016/j.cja.2013.02.019},
volume = {26},
year = {2013}
}
@article{Dessouky2017,
abstract = {Attacks targeting software on embedded systems are becoming increasingly prevalent. Remote attestation is a mechanism that allows establishing trust in embedded devices. However, existing attestation schemes are either static and cannot detect control-flow attacks, or require instrumentation of software incurring high performance overheads. To overcome these limitations, we present LO-FAT, the first practical hardware-based approach to control-flow attestation. By leveraging existing processor hardware features and commonly-used IP blocks, our approach enables efficient control-flow attestation without requiring software instrumentation. We show that our proof-of-concept implementation based on a RISC-V SoC incurs no processor stalls and requires reasonable area overhead.},
archivePrefix = {arXiv},
arxivId = {1706.03754},
author = {Dessouky, Ghada and Zeitouni, Shaza and Nyman, Thomas and Paverd, Andrew and Davi, Lucas and Koeberl, Patrick and Asokan, N. and Sadeghi, Ahmad-Reza},
doi = {10.1145/3061639.3062276},
eprint = {1706.03754},
file = {:D$\backslash$:/Downloads/1706.03754.pdf:pdf},
isbn = {9781450349277},
issn = {0738100X},
title = {{LO-FAT: Low-Overhead Control Flow ATtestation in Hardware}},
url = {http://arxiv.org/abs/1706.03754{\%}0Ahttp://dx.doi.org/10.1145/3061639.3062276},
year = {2017}
}
@inproceedings{Abera2016,
abstract = {Remote attestation is a crucial security service particularly relevant to increasingly popular IoT (and other embedded) devices. It allows a trusted party (verifier) to learn the state of a remote, and potentially malware-infected, device (prover). Most existing approaches are static in nature and only check whether benign software is initially loaded on the prover. However, they are vulnerable to run-time attacks that hijack the application's control or data flow, e.g., via return-oriented programming or data-oriented exploits. As a concrete step towards more comprehensive run-time remote attestation, we present the design and implementation of Control- FLow ATtestation (C-FLAT) that enables remote attestation of an application's control-flow path, without requiring the source code. We describe a full prototype implementation of C-FLAT on Raspberry Pi using its ARM TrustZone hardware security extensions. We evaluate C-FLAT's performance using a real-world embedded (cyber-physical) application, and demonstrate its efficacy against control-flow hijacking attacks.},
address = {New York, New York, USA},
archivePrefix = {arXiv},
arxivId = {1605.07763},
author = {Abera, Tigist and Asokan, N. and Davi, Lucas and Ekberg, Jan-Erik and Nyman, Thomas and Paverd, Andrew and Sadeghi, Ahmad-Reza and Tsudik, Gene},
booktitle = {Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security - CCS'16},
doi = {10.1145/2976749.2978358},
eprint = {1605.07763},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Abera et al. - 2016 - C-FLAT Control-Flow Attestation for Embedded Systems Software.pdf:pdf},
isbn = {9781450341394},
issn = {15437221},
keywords = {control-flow attacks,embedded system security,remote attestation},
pages = {743--754},
pmid = {23776192},
publisher = {ACM Press},
title = {{C-FLAT: Control-Flow Attestation for Embedded Systems Software}},
url = {http://arxiv.org/abs/1605.07763 http://dl.acm.org/citation.cfm?doid=2976749.2978358},
year = {2016}
}
@article{Simpson2006,
abstract = {Many Field-Programmable Gate Array (FPGA) based systems uti-lize third-party intellectual property (IP) in their development. When they are deployed in non-networked environments, the question raises how this IP can be protected against non-authorized use. We de-scribe an offline authentication scheme for IP modules. The scheme implements mutual authentication of the IP modules and the hard-ware platform, and enables us to provide authentication and integrity assurances to both the system developer and IP provider. Compared to the Trusted Computing Platform's approach to hardware, software authentication, our solution is more lightweight and tightly integrates with existing FPGA security features. We are able to demonstrate an implementation of the authentication scheme that requires a symmet-ric cipher and a Physically Unclonable Function (PUF). In addition to the low hardware requirements, our implementation does not require any on-chip, non-volatile storage.},
author = {Simpson, Eric and Schaumont, Patrick},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Simpson, Schaumont - 2006 - Offline HW SW Authentication for Reconfigurable Platforms.pdf:pdf},
journal = {Cryptographic Hardware and Embedded Systems (CHES)},
pages = {1--13},
title = {{Offline HW / SW Authentication for Reconfigurable Platforms}},
year = {2006}
}
@article{Kleber2015a,
author = {Kleber, Stephan and Unterstein, Florian and Matousek, Matthias and Kargl, Frank and Slomka, Frank and Hiller, Matthias},
doi = {10.18725/OPARU-3255},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kleber et al. - 2015 - Design of the Secure Execution PUF-based Processor ( SEPP ).pdf:pdf},
journal = {Workshop on Trustworthy Manufacturing and Utilization of Secure Devices, TRUDEVICE 2015},
number = {2},
pages = {1--5},
title = {{Design of the Secure Execution PUF-based Processor ( SEPP )}},
year = {2015}
}
@inproceedings{Lee2017,
address = {New York, New York, USA},
author = {Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem},
booktitle = {Proceedings of the 12th International Conference on Availability, Reliability and Security - ARES '17},
doi = {10.1145/3098954.3103158},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Markantonakis, Akram - 2017 - Provisioning Software with Hardware-Software Binding.pdf:pdf},
isbn = {9781450352574},
pages = {1--9},
publisher = {ACM Press},
title = {{Provisioning Software with Hardware-Software Binding}},
url = {http://dl.acm.org/citation.cfm?doid=3098954.3103158},
year = {2017}
}
@article{Bryant2004,
annote = {No references for "Encryption Wrappers"},
author = {Bryant, Eric D and Atallah, Mikhail J and Stytz, Martin R and Atallah, Mikhail J and Bryant, Eric D and Stytz, Martin R},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bryant et al. - 2004 - A Survey of Anti-Tamper Technologies.pdf:pdf},
journal = {The Journal of Defense Software Engineering},
number = {November},
pages = {12 -- 16},
title = {{A Survey of Anti-Tamper Technologies}},
year = {2004}
}
@inproceedings{Shepherd2016,
abstract = {Notions like security, trust, and privacy are crucial in the digital environment and in the future, with the advent of technologies like the Internet of Things (IoT) and Cyber-Physical Systems (CPS), their importance is only going to increase. Trust has different definitions, some situations rely on real-world relationships between entities while others depend on robust technologies to gain trust after deployment. In this paper we focus on these robust technologies, their evolution in past decades and their scope in the near future. The evolution of robust trust technologies has involved diverse approaches, as a consequence trust is defined, understood and ascertained differently across heterogeneous domains and technologies. In this paper we look at digital trust technologies from the point of view of security and examine how they are making secure computing an attainable reality. The paper also revisits and analyses the Trusted Platform Module (TPM), Secure Elements (SE), Hypervisors and Virtualisation, Intel TXT, Trusted Execution Environments (TEE) like GlobalPlatform TEE, Intel SGX, along with Host Card Emulation, and Encrypted Execution Environment (E3). In our analysis we focus on these technologies and their application to the emerging domains of the IoT and CPS.},
annote = {Breif review into Secure and Trusted Execution, does not mention various other encrypted execution environments. Has a good set of properties},
author = {Shepherd, Carlton and Arfaoui, Ghada and Gurulian, Iakovos and Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem and Sauveron, Damien and Conchon, Emmanuel},
booktitle = {2016 IEEE Trustcom/BigDataSE/ISPA},
doi = {10.1109/TrustCom.2016.0060},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Shepherd et al. - 2016 - Secure and Trusted Execution Past, Present, and Future - A Critical Review in the Context of the Internet of Th.pdf:pdf},
isbn = {978-1-5090-3205-1},
issn = {2324-9013},
keywords = {Cyber-physical system,Encrypted execution environment,GlobalPlatform,Host card emulation,Intel SGX,Internet of things,Java card,Trust,Trusted computing,Trusted execution environment,Trusted platform module,Trustworthiness},
month = {aug},
pages = {168--177},
publisher = {IEEE},
title = {{Secure and Trusted Execution: Past, Present, and Future - A Critical Review in the Context of the Internet of Things and Cyber-Physical Systems}},
url = {http://ieeexplore.ieee.org/document/7846943/},
year = {2016}
}
@article{Samyde2003,
abstract = {This paper explains a new family of techniques to extract data from semiconductor memory, without using the read-out circuitry provided for the purpose. What these techniques have in common is the use of semi-invasive probing methods to induce measurable changes in the analogue characteristics of the memory cells of interest. The basic idea is that when a memory cell, or read-out amplifier, is scanned appropriately with a laser, the resulting increase in leakage current depends on its state; the same happens when we induce an eddy current in a cell. These perturbations can be carried out at a level that does not modify the stored value, but still enables it to be read out. Our techniques build on it number of recent advances in semi-invasive attack techniques, low temperature data remanence, electromagnetic analysis and eddy current induction. They can be used against a wide range of memory structures, from registers through RAM to FLASH. We have demonstrated their practicality by reading out DES keys stored in RAM without using the normal read-out circuits. This suggests that vendors of products such as smartcards and secure microcontrollers should review their memory encryption, access control and other storage security issues with care.},
author = {Samyde, D. and Skorobogatov, S. and Anderson, R. and Quisquater, J. J.},
doi = {10.1109/SISW.2002.1183512},
file = {:D$\backslash$:/Downloads/01183512.pdf:pdf},
isbn = {0769518885},
journal = {Proceedings - 1st International IEEE Security in Storage Workshop, SISW 2002},
keywords = {Smartcards,data remanence,eddy current attack,electromagnetic security,optical probing,semi-invasive attacks,tamper resistance},
pages = {65--69},
publisher = {IEEE},
title = {{On a new way to read data from memory}},
year = {2003}
}
@article{Maurer1999,
abstract = {We discuss several applications of information theory in cryptography, both for unconditional and for computational security.$\backslash$n Unconditionally-secure secrecy, authentication, and key agreement are reviewed. It is argued that unconditional security can$\backslash$n practically be achieved by exploiting the fact that cryptography takes place in a physical world in which, for instance due$\backslash$n to noise, nobody can have complete information about the state of a system.$\backslash$n $\backslash$n The general concept of an information-theoretic cryptographic primitive is proposed which covers many previously considered$\backslash$n primitives like oblivious transfer, noisy channels, and multi-party computation. Many results in information-theoretic cryptography$\backslash$n can be phrased as reductions among such primitives We also propose the concept of a generalized random oracle which answers$\backslash$n more general queries than the evaluation of a random function. They have applications in proofs of the computational security$\backslash$n of certain cryptographic schemes.$\backslash$n $\backslash$n $\backslash$n $\backslash$n This extended abstract summarizes in an informal and non-technical way some of the material presented in the author's lecture$\backslash$n to be given at Crypto '99.},
author = {Maurer, Ueli},
doi = {10.1007/3-540-48405-1},
file = {:D$\backslash$:/Downloads/Kocher1999{\_}Chapter{\_}DifferentialPowerAnalysis.pdf:pdf},
isbn = {978-3-540-66347-8},
issn = {0302-9743},
journal = {Advances in Cryptology — CRYPTO' 99},
keywords = {and hardware engineers do,and model,attacks that involve multiple,cryptanalysis,des,di{\ae}erential power analysis,dpa,each,each other,if cipher designers,not understand or review,parts of a security,predict,s work,security assumptions made at,software developers,spa,system are di{\ae}cult to},
pages = {785},
title = {{Differential Power Analysis}},
url = {http://www.springerlink.com/content/cdp6u8xpenkkx08m},
volume = {1666},
year = {1999}
}
@incollection{Street,
author = {Anderson, Ross and Kuhn, Markus},
doi = {10.1007/BFb0028165},
file = {:D$\backslash$:/Downloads/Anderson-Kuhn1998{\_}Chapter{\_}LowCostAttacksOnTamperResistan.pdf:pdf},
pages = {125--136},
title = {{Low cost attacks on tamper resistant devices}},
url = {http://link.springer.com/10.1007/BFb0028165},
year = {1998}
}
@article{Anderson1996,
author = {Anderson, R. and Kuhn, M.},
file = {:D$\backslash$:/Downloads/57508cf35d8762e152eb3d4f0e872ae79ba6.pdf:pdf},
isbn = {1880446839},
pages = {1--11},
title = {{Tamper Resistance — a Cautionary Note}},
url = {http://www.cl.cam.ac.uk/{~}rja14/Papers/tamper.pdf},
year = {1996}
}
@article{Boneh,
author = {Boneh, Dan and DeMillo, Richard A. and Lipton, Richard J},
doi = {10.1007/s001450010016},
file = {:D$\backslash$:/Downloads/10.1.1.41.7211.pdf:pdf},
issn = {0933-2790},
journal = {Journal of Cryptology},
month = {mar},
number = {2},
pages = {101--119},
title = {{On the Importance of Eliminating Errors in Cryptographic Computations}},
url = {http://link.springer.com/10.1007/s001450010016},
volume = {14},
year = {2001}
}
@article{Kleber2015,
abstract = {A persistent problem with program execution, despite nu-merous mitigation attempts, is its inherent vulnerability to the injec-tion of malicious code. Equally unsolved is the susceptibility of firmware to reverse engineering, which undermines the manufacturer's code con-fidentiality. We propose an approach that solves both kinds of security problems employing instruction-level code encryption combined with the use of a physical unclonable function (PUF). Our novel Secure Execution PUF-based Processor (SEPP) architecture is designed to minimize the attack surface, as well as performance impact, and requires no significant changes to the development process. This is possible based on a tight integration of a PUF directly into the processor's instruction pipeline. Furthermore, cloud scenarios and distributed embedded systems alike inherently depend on remote execution; our approach supports this, as the secure execution environment needs not to be locally available at the developers site. We implemented an FPGA-based prototype based on the OpenRISC Reference Platform. To assess our results, we performed a security analysis of the processor and evaluated the performance im-pact of the encryption. We show that the attack surface is significantly reduced compared to previous approaches while the performance penalty is at a reasonable factor of about 1.5.},
author = {Kleber, Stephan and Unterstein, Florian and Matousek, Matthias and Kargl, Frank and Slomka, Frank and Hiller, Matthias},
doi = {cr.org/2015/651},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kleber et al. - 2015 - Secure Execution Architecture based on PUF-driven Instruction Level Code Encryption.pdf:pdf},
journal = {Cryptology ePrint Archive, Report 2015/651},
keywords = {and matthias hiller 3,encryption,florian unterstein 1,frank kargl 1,frank slomka 2,matthias matousek 1,on,puf-driven instruction level code,stephan kleber 1,ure execution architecture based},
title = {{Secure Execution Architecture based on PUF-driven Instruction Level Code Encryption}},
year = {2015}
}
@article{Theissing2013,
abstract = {Fault tolerant software against fault attacks constitutes an important class of countermeasures for embedded systems. In this work, we implemented and systematically analyzed a comprehensive set of 19 different strategies for software countermeasures with respect to protection effectiveness as well as time and memory efficiency. We evaluated the performance and security of all implementations by fault injections into a microcontroller simulator based on an ARM Cortex-M3. Our results show that some rather simple countermeasures outperform other more sophisticated methods due to their low memory and/or performance overhead. Further, combinations of countermeasures show strong characteristics and can lead to a high fault coverage, while keeping additional resources at a minimum. The results obtained in this study provide developers of secure software for embedded systems with a solid basis to decide on the right type of fault attack countermeasure for their application.},
author = {Theissing, Nikolaus and Merli, Dominik and Smola, Michael and Stumpf, Frederic and Sigl, Georg},
doi = {10.7873/DATE.2013.092},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Theissing et al. - 2013 - Comprehensive Analysis of Software Countermeasures against Fault Attacks.pdf:pdf},
isbn = {9781467350716},
issn = {15301591},
journal = {Design, Automation {\&} Test in Europe Conference {\&} Exhibition (DATE), 2013},
pages = {404--409},
publisher = {IEEE},
title = {{Comprehensive Analysis of Software Countermeasures against Fault Attacks}},
url = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6513538},
year = {2013}
}
@book{Maes2012,
author = {Maes, R},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Maes - 2012 - Physically Unclonable Functions Constructions, Properties and Applications (Fysisch onkloonbare functies constructies, eig.pdf:pdf},
isbn = {9789460185618},
keywords = {phd, thesis, dissertation, doctoraat, kuleuven, Ro},
number = {August},
title = {{Physically Unclonable Functions: Constructions, Properties and Applications (Fysisch onkloonbare functies: constructies, eigenschappen en toepassingen)}},
url = {https://lirias.kuleuven.be/handle/123456789/353455},
year = {2012}
}
