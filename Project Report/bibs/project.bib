@article{Boneh,
author = {Boneh, Dan and DeMillo, Richard A. and Lipton, Richard J},
doi = {10.1007/s001450010016},
file = {:D$\backslash$:/Downloads/10.1.1.41.7211.pdf:pdf},
issn = {0933-2790},
journal = {Journal of Cryptology},
month = {mar},
number = {2},
pages = {101--119},
title = {{On the Importance of Eliminating Errors in Cryptographic Computations}},
url = {http://link.springer.com/10.1007/s001450010016},
volume = {14},
year = {2001}
}
@article{Khelladi2008,
author = {Khelladi, Lyes and Challal, Yacine and Bouabdallah, Abdelmadjid and Badache, Nadjib},
doi = {10.1504/ijics.2008.018515},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Khelladi et al. - 2008 - On security issues in embedded systems challenges and solutions.pdf:pdf},
issn = {1744-1765},
journal = {International Journal of Information and Computer Security},
number = {2},
pages = {140},
title = {{On security issues in embedded systems: challenges and solutions}},
volume = {2},
year = {2008}
}
@article{Suzer2011,
abstract = {Traditionally, IC companies were able to protect their IP assets by simply keeping these in safe. However, the new trends such as outsourcing and fabless IC development make the silicon processing and IC development more accessible. Therefore, IC authentication and IP (intellectual property) protection have become real world problems that industry eagerly seeks for efficient solutions. Most of the considerable proposals to these intense problems involve complicated cryptographic schemes and procedures that bring extra burden on system design. Moreover, if the target platform is a constraint environment, this burden is amplified and even the most efficient solutions become infeasible. Therefore, designers tend to use the ad-hoc methods that possibly have serious security risks. In this study, we seek practical solutions for the FPGAs (Field Programmable Gate Array) which represent a relatively small but important subset of hardware IP utilization.},
author = {Suzer, Orhun and Kaya, Gurkan and Donmez, Faruk and Saldamli, Gokay and Yalcin, Mustak E.},
file = {:D$\backslash$:/Downloads/b847255d7a04a49{\_}ek.pdf:pdf},
journal = {2011 7th International Conference on Electrical and Electronics Engineering (ELECO)},
pages = {II--293--II--296},
title = {{A practical authentication method of FPGA designs suitable for mass production}},
year = {2011}
}
@article{Breeuwsma2007,
abstract = {Current forensic tools for examination of embedded systems like mobile phones and PDAs mostly perform data extraction on a logical level and do not consider the type of storage media during data analysis. This paper suggests a low level approach for the forensic examination of flash memories and describes three low-level data acquisition methods for making full memory copies of flash memory devices. Results are presented of a file system study in which USB memory sticks from 45 different make and models were used. For different mobile phones is shown how full memory copies of their flash memories can be made and which steps are needed to translate the extracted data into a format that can be understood by common forensic media analysis tools. Artifacts, caused by flash specific operations like block erasing and wear leveling, are discussed and directions are given for enhanced data recovery and analysis on data originating from flash memory.},
author = {Breeuwsma, Marcel and Jongh, Martien De},
file = {:D$\backslash$:/Downloads/SSDDFJ{\_}V1{\_}1{\_}Breeuwsma{\_}et{\_}al.pdf:pdf},
journal = {Small Scale Digital Device Forensics Journal},
keywords = {embedded systems, flash memory, physical analysis,},
number = {1},
pages = {1--17},
title = {{Forensic data recovery from flash memory}},
volume = {1},
year = {2007}
}
@article{Al-Kuwaiti2009,
abstract = {Abstract— Nowadays, there is a wide variety of network benchmarking tools, giving researchers and network administrators many choices to work with. However, this variety tends to difficult the selection process of the appropriate tool. Furthermore, sometimes users are forced to try several tools in order to find the one that calculates a given gauge, so they have to learn how to manipulate different tools and how to interpret obtained results. This paper offers a compilation of currently used network benchmarking tools, with the intention of guiding the selection of one tool over others, by outlining their main features, strengths and weaknesses. Index},
author = {Al-Kuwaiti, M. and Kyriakopoulos, N. and Hussein, S.},
doi = {10.1109/SURV.2009.090208},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Al-Kuwaiti, Kyriakopoulos, Hussein - 2009 - A comparative analysis of network dependability, fault-tolerance, reliability, security, and.pdf:pdf},
issn = {1553877X},
journal = {IEEE Communications Surveys and Tutorials},
keywords = {Dependability,Fault-tolerance,Reliability,Security,Survivability},
number = {2},
pages = {106--124},
title = {{A comparative analysis of network dependability, fault-tolerance, reliability, security, and survivability}},
volume = {11},
year = {2009}
}
@article{BrasserF.andElMahjoubB.andSadeghiA.-R.andWachsmannC.andKoeberl2015,
abstract = {Embedded systems are at the core of many security-sensitive and safety-critical applications, including automotive, industrial control systems, and critical infrastructures. Existing protection mechanisms against (software-based) malware are inflexible, too complex, expensive, or do not meet real-time requirements. We present TyTAN, which, to the best of our knowledge, is the first security architecture for embedded systems that provides (1) hardware-assisted strong isolation of dynamically configurable tasks and (2) real-time guarantees. We implemented TyTAN on the Intel{\textregistered} Siskiyou Peak embedded platform and demonstrate its efficiency and effectiveness through extensive evaluation.},
author = {{Brasser, F. and El Mahjoub, B. and Sadeghi, A.-R. and Wachsmann, C. and Koeberl}, P.},
doi = {10.1145/2744769.2744922},
file = {:D$\backslash$:/Downloads/TyTAN.pdf:pdf},
isbn = {9781450335201},
issn = {0738100X},
journal = {Design Automation Conference (DAC), 2015 52nd ACM/EDAC/IEEE},
keywords = {Clocks,Embedded systems,Intel Siskiyou Peak embedded platform,Loading,Real-time systems,Runtime,Security,TyTAN,embedded systems,hardware-assisted dynamically configurable task is,invasive software,malware,mbedded systems,real-time guarantees,safety-critical applications,security-sensitive applications,tiny devices,tiny trust anchor,trusted computing},
pages = {1--6},
title = {{TyTAN: Tiny trust anchor for tiny devices}},
year = {2015}
}
@inproceedings{Miremadi,
author = {Miremadi, G. and Harlsson, J. and Gunneflo, U. and Torin, J.},
booktitle = {[1992] Digest of Papers. FTCS-22: The Twenty-Second International Symposium on Fault-Tolerant Computing},
doi = {10.1109/FTCS.1992.243568},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Miremadi et al. - Unknown - Two software techniques for on-line error detection.pdf:pdf},
isbn = {0-8186-2875-8},
pages = {328--335},
publisher = {IEEE},
title = {{Two software techniques for on-line error detection}},
url = {http://ieeexplore.ieee.org/document/243568/}
}
@article{Maurer1999,
abstract = {We discuss several applications of information theory in cryptography, both for unconditional and for computational security.$\backslash$n Unconditionally-secure secrecy, authentication, and key agreement are reviewed. It is argued that unconditional security can$\backslash$n practically be achieved by exploiting the fact that cryptography takes place in a physical world in which, for instance due$\backslash$n to noise, nobody can have complete information about the state of a system.$\backslash$n $\backslash$n The general concept of an information-theoretic cryptographic primitive is proposed which covers many previously considered$\backslash$n primitives like oblivious transfer, noisy channels, and multi-party computation. Many results in information-theoretic cryptography$\backslash$n can be phrased as reductions among such primitives We also propose the concept of a generalized random oracle which answers$\backslash$n more general queries than the evaluation of a random function. They have applications in proofs of the computational security$\backslash$n of certain cryptographic schemes.$\backslash$n $\backslash$n $\backslash$n $\backslash$n This extended abstract summarizes in an informal and non-technical way some of the material presented in the author's lecture$\backslash$n to be given at Crypto '99.},
author = {Maurer, Ueli},
doi = {10.1007/3-540-48405-1},
file = {:D$\backslash$:/Downloads/Kocher1999{\_}Chapter{\_}DifferentialPowerAnalysis.pdf:pdf},
isbn = {978-3-540-66347-8},
issn = {0302-9743},
journal = {Advances in Cryptology — CRYPTO' 99},
keywords = {and hardware engineers do,and model,attacks that involve multiple,cryptanalysis,des,di{\ae}erential power analysis,dpa,each,each other,if cipher designers,not understand or review,parts of a security,predict,s work,security assumptions made at,software developers,spa,system are di{\ae}cult to},
pages = {785},
title = {{Differential Power Analysis}},
url = {http://www.springerlink.com/content/cdp6u8xpenkkx08m},
volume = {1666},
year = {1999}
}
@article{Abadi2014,
author = {Abadi, Martın and Budiu, Mihai and Erlingsson, Ulfar and Ligatti, Jay},
doi = {10.3929/ethz-a-010250961},
file = {:D$\backslash$:/Downloads/cfitheory{\_}submit.pdf:pdf},
number = {22140},
pages = {1--15},
title = {{A Theory of Secure Control Flow}},
url = {http://e-collection.library.ethz.ch/view/eth:46700},
year = {2014}
}
@article{Mao2010,
abstract = {The inherent limitations of embedded systems make them particularly vulnerable to attacks. We have developed a hardware monitor that operates in parallel to an embedded processor and detects any attack that causes the embedded processor to deviate from its originally programmed behavior. We explore several different characteristics that can be used for monitoring and quantify trade-offs between these approaches. Our results show that our proposed hash-based monitoring pattern can detect attacks within one instruction cycle at lower memory requirements than traditional approaches that use control flow information.},
author = {Mao, Shufu and Wolf, Tilman},
doi = {10.1109/TC.2010.32},
file = {:D$\backslash$:/Downloads/05406503.pdf:pdf},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Embedded system security,Processing monitor,Security enforcement},
number = {6},
pages = {847--854},
publisher = {IEEE},
title = {{Hardware support for secure processing in embedded systems}},
volume = {59},
year = {2010}
}
@article{Yuce2016a,
annote = {Breaks software only protections (not including flow analysis)},
author = {Yuce, Bilgiday and Ghalaty, Nahid Farhady and Santapuri, Harika and Deshpande, Chinmay and Patrick, Conor and Schaumont, Patrick},
doi = {10.1109/FDTC.2016.21},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yuce et al. - 2016 - Software Fault Resistance is Futile Effective Single-Glitch Attacks.pdf:pdf},
isbn = {9781509011087},
journal = {Proceedings - 2016 Workshop on Fault Diagnosis and Tolerance in Cryptography, FDTC 2016},
keywords = {Embedded Software Security,Fault Attacks,Software Countermeasures},
pages = {47--58},
publisher = {IEEE},
title = {{Software Fault Resistance is Futile: Effective Single-Glitch Attacks}},
year = {2016}
}
@article{Kayaalp2014,
abstract = {Code reuse attacks (CRAs) are recent security exploits that allow attackers to execute arbitrary code on a compromised machine. CRAs, exemplified by return-oriented and jump-oriented programming approaches, reuse fragments of the library code, thus avoiding the need for explicit injection of attack code on the stack. Since the executed code is reused existing code, CRAs bypass current hardware and software security measures that prevent execution from data or stack regions of memory. While software- based full control flow integrity (CFI) checking can protect against CRAs, it includes significant overhead, involves non-trivial effort of constructing a control flow graph, relies on proprietary tools and has potential vulnerabilities due to the presence of unintended branch instructions in architectures such as x86—those branches are not checked by the software CFI.We propose branch regulation (BR), a lightweight hardware-supported protection mechanism against the CRAs that addresses all limitations of software CFI. BR enforces simple control flow rules in hardware at the function granularity to disallow arbitrary control flow transfers from one function into the middle of another function. This prevents common classes of CRAs without the complexity and run-time overhead of full CFI enforcement. BR incurs a slowdown of about 2{\%} and increases the code footprint by less than 1{\%} on the average for the SPEC 2006 benchmarks.},
author = {Kayaalp, Mehmet and Ozsoy, Meltem and Ghazaleh, Nael Abu and Ponomarev, Dmitry},
doi = {10.1109/TC.2012.269},
file = {:D$\backslash$:/Downloads/06355533.pdf:pdf},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Security,code reuse attacks,microarchitecture},
number = {5},
pages = {1144--1156},
publisher = {IEEE},
title = {{Efficiently securing systems from code reuse attacks}},
volume = {63},
year = {2014}
}
@incollection{Quisquater2001,
author = {Quisquater, Jean-Jacques and Samyde, David},
booktitle = {ACM Transactions on Embedded Computing Systems},
doi = {10.1007/3-540-45418-7_17},
file = {:D$\backslash$:/Downloads/Quisquater-Samyde2001{\_}Chapter{\_}ElectroMagneticAnalysisEMAMeas.pdf:pdf},
issn = {15399087},
month = {apr},
number = {3},
pages = {200--210},
title = {{ElectroMagnetic Analysis (EMA): Measures and Counter-measures for Smart Cards}},
url = {http://link.springer.com/10.1007/3-540-45418-7{\_}17},
volume = {18},
year = {2001}
}
@article{Coudray2015,
author = {Coudray, Thomas and Fontaine, Arnaud and Chifflier, Pierre},
file = {:D$\backslash$:/Downloads/SSTIC2015-Article-control{\_}flow{\_}integrity{\_}on{\_}llvm{\_}ir-fontaine{\_}chifflier{\_}coudray{\_}esfrDAl.pdf:pdf},
journal = {Proceedings of SSTIC},
title = {{PICON: Control Flow Integrity on LLVM IR}},
year = {2015}
}
@article{Shankar2004,
abstract = {Kennell and Jamieson [KJ03] recently introduced the Genuinity system for authenticating trusted software on a remote machine without using trusted hardware. Gen- uinity relies on machine-specific computations, incorpo- rating side effects that cannot be simulated quickly. The system is vulnerable to a novel attack, which we call a substitution attack. We implement a successful attack on Genuinity, and further argue this class of schemes are not only impractical but unlikely to succeed without trusted hardware.},
author = {Shankar, Umesh and Chew, Monica and Tygar, J. D.},
doi = {10.1109/MSP.2010.92},
file = {:D$\backslash$:/Downloads/Side{\_}effects{\_}techreport.pdf:pdf},
issn = {1540-7993},
journal = {13th USENIX Security Symposium},
number = {3},
title = {{Side effects are not sufficient to authenticate software}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5470965},
volume = {8},
year = {2004}
}
@article{Yang2003,
abstract = {Due to the widespread software piracy and virus attacks, significant efforts have been made to improve security for computer systems. For stand-alone computers, a key observation is that other than the processor, any component is vulnerable to security attacks. Recently, an execution only memory (XOM) architecture has been proposed to support copy and tamper resistant software by D. Lie et al. (2000), D. Lie et al. (2003) and T. Gilmont et al. (1999). In this design, the program and data are stored in encrypted format outside the CPU boundary. The decryption is carried after they are fetched from memory, and before they are used by the CPU. As a result, the lengthened critical path causes a serious performance degradation. In this paper, we present an innovative technique in which the cryptography computation is shifted off from the memory access critical path. We propose to use a different encryption scheme, namely "one-time pad" encryption, to produce the instructions and data ciphertext. With some additional on-chip storage, cryptography computations are carried in parallel with memory accesses, minimizing performance penalty. We performed experiments to study the trade-off between storage size and performance penalty. Our technique improves the execution speed of the XOM architecture by 34{\%} at maximum},
author = {Yang, Jun and Zhang, Youtao and Gao, Lan},
doi = {10.1109/MICRO.2003.1253209},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yang, Zhang, Gao - 2003 - Fast secure processor for inhibiting software piracy and tampering.pdf:pdf},
isbn = {076952043X},
issn = {10724451},
journal = {Proceedings of the Annual International Symposium on Microarchitecture, MICRO},
keywords = {Central Processing Unit,Computer architecture,Computer crime,Computer security,Concurrent computing,Cryptography,Data security,Degradation,Immune system,Memory architecture},
pages = {351--360},
title = {{Fast secure processor for inhibiting software piracy and tampering}},
volume = {2003-Janua},
year = {2003}
}
@article{Kiriansky2002,
abstract = {We introduce program shepherding, a method for monitoring control flow transfers during program execution to enforce a security policy. Program shepherding provides three techniques as building blocks for security policies. First, shepherding can restrict execution privileges on the basis of code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict control transfers based on instruction class, source, and target. For example, shepherding can forbid execution of shared library code except through declared entry points, and can ensure that a return instruction only targets the instruction after a call. Finally, shepherding guarantees that sandboxing checks placed around any type of program operation will never be bypassed. We have implemented these capabilities efficiently in a runtime system with minimal or no performance penalties. This system operates on unmodified native binaries, requires no special hardware or operating system support, and runs on existing IA-32 machines under both Linux and Windows.},
author = {Kiriansky, Vladimir and Bruening, Derek and Amarasinghe, Saman P.},
doi = {10.1016/j.hydromet.2010.01.018},
file = {:D$\backslash$:/Downloads/RIO-security-usenix.pdf:pdf},
isbn = {1931971005},
journal = {Proceedings of the 11th USENIX Security Symposium},
pages = {191--206},
title = {{Secure Execution Via Program Shepherding}},
url = {http://www.usenix.org/events/sec02/full{\_}papers/kiriansky/kiriansky{\_}html/{\%}5Cnhttp://static.usenix.org/events/sec02/full{\_}papers/kiriansky/kiriansky{\_}html/{\%}5Cnhttp://dl.acm.org/citation.cfm?id=647253.720293},
year = {2002}
}
@article{Schuster2017,
abstract = {{\textcopyright} 2017 ACM. Soft errors are a challenging and urging problem in the domain of safety-critical embedded systems. For decades, checking schemes have been investigated and improved to mitigate soft-error effects for the class of control-flow faults, with current industrial standards strongly recommending their use. However, reality looks different: Taking a systems perspective, we implemented four representative Control-Flow Checking (CFC) schemes and put them through their paces in 396 fault-injection campaigns. In contrast to previous work, which typically relied on probability-based vulnerability metrics, we accounted for the influence of memory and time overheads on the fault-space dimensions and applied those in full-scan fault injections. This change in procedure alone severely degraded the perceived effectiveness of CFC. In addition, we expanded the perspective to data-flow faults and their influence on the overall susceptibility, an aspect that so far has been largely ignored. Our results suggest that, without accompanying measures, any improvement regarding control-flow faults is dominated by the increase in data faults caused by the increased attac k surface in terms of memory and runtime overhead. Moreover, CFC performance less depended on the detection capabilities than on general aspects of the concrete binary compilation and execution. In conclusion, incorporating CFC is not as straightforward as often assumed and the vulnerability of systems with hardened control-flow may in many cases even be increased by the schemes themselves.},
author = {Schuster, Simon and Ulbrich, Peter and Stilkerich, Isabella and Dietrich, Christian and Schr{\"{o}}Der-Preikschat, Wolfgang},
doi = {10.1145/3126503},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Schuster et al. - 2017 - Demystifying Soft-Error Mitigation by Control-Flow Checking -- A New Perspective on its Effectiveness.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {5s},
pages = {1--19},
title = {{Demystifying Soft-Error Mitigation by Control-Flow Checking -- A New Perspective on its Effectiveness}},
url = {http://dl.acm.org/citation.cfm?doid=3145508.3126503},
volume = {16},
year = {2017}
}
@article{G.G.LiversidgeJ.F.BishopD.A.Czekai1980,
author = {{G.G. Liversidge  J.F. Bishop, D.A. Czekai}, K C Cundy},
doi = {US005485919A},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/G.G. Liversidge J.F. Bishop, D.A. Czekai - 1980 - United States Patent (19) 54.pdf:pdf},
isbn = {2222222222},
issn = {2222222222},
number = {19},
pages = {62--66},
title = {{United States Patent (19) 54}},
volume = {96},
year = {1980}
}
@article{DAU2011,
author = {DAU},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/DAU - 2011 - Defense Acquisition Guidebook.pdf:pdf},
pages = {1--969},
title = {{Defense Acquisition Guidebook}},
url = {https://www.dau.mil/tools/dag},
year = {2011}
}
@article{VieiraSteiner2019,
abstract = {Software-based attestation promises to enable the integrity verification of untrusted devices without requiring any particular hardware. However, existing proposals rely on strong assumptions that hinder their deployment and might even weaken their security. One of such assumptions is that using the maximum known network round-trip time to define the attestation timeout allows all honest devices to reply in time. While this is normally true in controlled environments, it is generally false in real deployments and especially so in a scenario like the Internet of Things where numerous devices communicate over an intrinsically unreliable wireless medium. Moreover, a larger timeout demands more computations, consuming extra time and energy and restraining the untrusted device from performing its main tasks. In this paper, we review this fundamental and yet overlooked assumption and propose a novel stochastic approach that significantly improves the overall attestation performance. Our experimental evaluation with IoT devices communicating over real-world uncontrolled Wi-Fi networks demonstrates the practicality and superior performance of our approach that in comparison with the current state of the art solution reduces the total attestation time and energy consumption around seven times for honest devices and two times for malicious ones, while improving the detection rate of honest devices (8{\%} higher TPR) without compromising security (0{\%} FPR).},
author = {{Vieira Steiner}, Rodrigo and Lupu, Emil},
doi = {10.1016/j.comnet.2018.11.003},
file = {:D$\backslash$:/Downloads/1-s2.0-S1389128618307631-main.pdf:pdf},
issn = {13891286},
journal = {Computer Networks},
keywords = {Internet of things,Security,Software-based attestation,Wireless},
pages = {43--55},
publisher = {Elsevier B.V.},
title = {{Towards more practical software-based attestation}},
url = {https://doi.org/10.1016/j.comnet.2018.11.003},
volume = {149},
year = {2019}
}
@article{Ngabonziza2017,
abstract = {ARM TrustZone is a hardware security extension technology, which aims to provide secure execution environment by splitting computer resources between two execution worlds, namely normal world and secure world. TrustZone is supported on different flavors of ARM architectures, that include architecture deployed on targets running regular applications, such as mobile devices and architecture for micro-controllers. As ARM is widely deployed on the majority of mobile and micro-controller devices, TrustZone's goal is to provide security for those platforms. In this paper, we will discuss details of different ARM architectures that support TrustZone technology. Then, we will review how TrustZone is implemented in the hardware and software of ARM products. We will also compare TrustZone with other implementations of trusted execution environments on the market.},
author = {Ngabonziza, Bernard and Martin, Daniel and Bailey, Anna and Cho, Haehyun and Martin, Sarah},
doi = {10.1109/CIC.2016.065},
file = {:D$\backslash$:/Downloads/07809736.pdf:pdf},
isbn = {9781509046072},
journal = {Proceedings - 2016 IEEE 2nd International Conference on Collaboration and Internet Computing, IEEE CIC 2016},
pages = {445--451},
publisher = {IEEE},
title = {{TrustZone explained: Architectural features and use cases}},
volume = {7},
year = {2017}
}
@article{Suh,
author = {Suh, G Edward and Clarke, Dwaine and Gassend, Blaise and Dijk, Marten Van and Devadas, Srinivas},
doi = {10.1145/782814.782838},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Suh et al. - Unknown - AEGIS Architecture for Tamper-Evident and Tamper-Resistant Processing.pdf:pdf},
isbn = {1581137338},
issn = {02105187},
keywords = {certified execution,secure processors,software licensing},
title = {{AEGIS : Architecture for Tamper-Evident and Tamper-Resistant Processing}}
}
@inproceedings{Edwards2001,
abstract = {Distributed computing on the Internet presents new challenges and$\backslash$nopportunities for tools that inspect and modify program binaries.$\backslash$nThe dynamic and heterogeneous nature of the Internet environment$\backslash$nextends the traditional product development process by requiring$\backslash$nprogram development tools like these, which were once used only internally,$\backslash$nto work in live environments too. The concept of compilation process$\backslash$nmust be expanded along with the capabilities of the binary tools.$\backslash$nThis paper presents Vulcan, a second-generation technology that addresses$\backslash$nmany of these challenges. Vulcan provides both static and dynamic$\backslash$ncode modification and provides a framework for cross-component analysis$\backslash$nand optimization. It provides system-level analysis for heterogeneous$\backslash$nbinaries across instruction sets. Vulcan works in the Win32 environment$\backslash$nand can process x86, IA64, and MSIL binaries. Vulcan scales to large$\backslash$ncommercial applications and has been used to improve performance$\backslash$nand reliability of Microsoft products in a production environment.},
author = {Srivastava, Amitabh and Edwards, Andrew and Vo, Hoi},
booktitle = {MSR TechReport},
publisher = {Microsoft Research},
title = {{Vulcan: Binary Transformation in a Distributed Environment}},
url = {https://www.microsoft.com/en-us/research/publication/vulcan-binary-transformation-in-a-distributed-environment/},
year = {2001}
}
@article{Nyman2017,
abstract = {Widespread use of memory unsafe programming languages (e.g., C and C++) leaves many systems vulnerable to memory corruption attacks. A variety of defenses have been proposed to mitigate attacks that exploit memory errors to hijack the control flow of the code at run-time, e.g., (fine-grained) randomization or Control Flow Integrity. However, recent work on data-oriented programming (DOP) demonstrated highly expressive (Turing-complete) attacks, even in the presence of these state-of-the-art defenses. Although multiple real-world DOP attacks have been demonstrated, no efficient defenses are yet available. We propose run-time scope enforcement (RSE), a novel approach designed to efficiently mitigate all currently known DOP attacks by enforcing compile-time memory safety constraints (e.g., variable visibility rules) at run-time. We present HardScope, a proof-of-concept implementation of hardware-assisted RSE for the new RISC-V open instruction set architecture. We discuss our systematic empirical evaluation of HardScope which demonstrates that it can mitigate all currently known DOP attacks, and has a real-world performance overhead of 3.2{\%} in embedded benchmarks.},
archivePrefix = {arXiv},
arxivId = {1705.10295},
author = {Nyman, Thomas and Dessouky, Ghada and Zeitouni, Shaza and Lehikoinen, Aaro and Paverd, Andrew and Asokan, N. and Sadeghi, Ahmad-Reza},
eprint = {1705.10295},
file = {:D$\backslash$:/Downloads/1705.10295.pdf:pdf},
title = {{HardScope: Thwarting DOP with Hardware-assisted Run-time Scope Enforcement}},
url = {http://arxiv.org/abs/1705.10295},
year = {2017}
}
@article{Govindavajhala2003,
abstract = {We present an experimental study showing that soft to the JVM error in its address space will allow it to take control of the JVM. All conventional Java and .NET to this a probability of about 70{\%}, and multiple-bit a lower probability. Our is particularly relevant against smart cards or tamper-resistant computers, where the user has physical access (to the outside of the computer) and can use various means {\textless}span faults; we have successfully {\textless}span Fortunately, there are some straightforward defenses against this {\textless}span},
author = {Govindavajhala, S. and Appel, A. W.},
doi = {10.1109/SECPRI.2003.1199334},
file = {:D$\backslash$:/Downloads/01199334.pdf:pdf},
isbn = {0769519407},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {154--165},
publisher = {IEEE},
title = {{Using memory errors to attack a virtual machine}},
volume = {2003-Janua},
year = {2003}
}
@article{Davi2015,
author = {Davi, Lucas and Hanreich, Matthias and Paul, Debayan and Sadeghi, Ahmad-Reza and Koeberl, Patrick and Sullivan, Dean and Arias, Orlando and Jin, Yier},
doi = {10.1145/2744769.2744847},
file = {:D$\backslash$:/Downloads/07167258.pdf:pdf},
isbn = {9781450335201},
journal = {2015 52nd ACM/EDAC/IEEE Design Automation Conference (DAC)},
pages = {1--6},
publisher = {IEEE},
title = {{Hafix}},
year = {2015}
}
@inproceedings{Mashtizadeh2014,
abstract = {Recent Pwn2Own competitions have demonstrated the continued effectiveness of control hijacking attacks despite deployed countermeasures including stack canaries and ASLR. A powerful defense called Control flow Integrity (CFI) offers a principled approach to preventing such attacks. However, prior CFI implementations use static analysis and must limit protection to remain practical. These limitations have enabled attacks against all known CFI systems, as demonstrated in recent work. This paper presents a cryptographic approach to control flow integrity (CCFI) that is both fine-grain and practical: using message authentication codes (MAC) to protect control flow elements such as return addresses, function pointers, and vtable pointers. MACs on these elements prevent even powerful attackers with random read/write access to memory from tampering with program control flow. We implemented CCFI in Clang/LLVM, taking advantage of recently available cryptographic CPU instructions. We evaluate our system on several large software packages (including nginx, Apache and memcache) as well as all their dependencies. The cost of protection ranges from a 3-18{\%} decrease in request rate.},
address = {New York, New York, USA},
archivePrefix = {arXiv},
arxivId = {1408.1451},
author = {Mashtizadeh, Ali Jos{\'{e}} and Bittau, Andrea and Boneh, Dan and Mazi{\`{e}}res, David},
booktitle = {Proceedings of the ACM Conference on Computer and Communications Security},
doi = {10.1145/2810103.2813676},
eprint = {1408.1451},
file = {:D$\backslash$:/Downloads/mashtizadeh-ccfi-ccs15.pdf:pdf},
isbn = {9781450338325},
issn = {15437221},
keywords = {Control flow integrity,Return oriented programming,Vulnerabilities},
pages = {941--951},
publisher = {ACM Press},
title = {{CCFI: Cryptographically enforced control flow integrity}},
url = {http://dl.acm.org/citation.cfm?doid=2810103.2813676},
volume = {2015-Octob},
year = {2015}
}
@article{Bar-el2006,
author = {Bar-el, Hagai and Choukri, Hamid},
file = {:D$\backslash$:/Downloads/01580506.pdf:pdf},
journal = {Proceedings of the IEEE},
keywords = {fault attacks,glitch attacks,side-channel attacks},
number = {2},
pages = {370--382},
title = {{The Sorcerer ' s Apprenctice ' s Guide to Fault Attacks}},
url = {http://ieeexplore.ieee.org/abstract/document/1580506/},
volume = {94},
year = {2006}
}
@article{ShuoChenJunXuEmreC.SezerPrachiGauriar2015,
abstract = {Most memory corruption attacks and Internet worms follow a familiar pattern known as the control-data attack. Hence, many defensive techniques are designed to protect program control flow integrity. Although earlier work did suggest the existence of attacks that do not alter control flow, such attacks are generally believed to be rare against real-world software. The key contribution of this paper is to show that non-control-data attacks are realistic. We demonstrate that many real-world applications, including FTP, SSH, Telnet, and HTTP servers, are vulnerable to such attacks. In each case, the generated attack results in a security compromise equivalent to that due to the control-data attack exploiting the same security bug. Non-control-data attacks corrupt a variety of application data including user identity data, configuration data, user input data, and decision-making data. The success of these attacks and the variety of applications and target data suggest that potential attack patterns are diverse. Attackers are currently focused on control-data attacks, but it is clear that when control flow protection techniques shut them down, they have incentives to study and employ non-control-data attacks. This paper emphasizes the importance of future research efforts to address this realistic threat.},
author = {{Shuo Chen†, Jun Xu‡, Emre C. Sezer‡, Prachi Gauriar‡}, and Ravishankar K. Iyer},
doi = {10.1088/0953-2048/29/2/025003},
file = {:D$\backslash$:/Downloads/data{\_}attack.pdf:pdf},
issn = {13616668},
journal = {Superconductor Science and Technology},
keywords = {critical current,flux line pinning,superconductivity},
number = {2},
pages = {12},
pmid = {24127066},
title = {{Non-Control-Data Attacks Are Realistic Threats Shuo}},
url = {http://portal.acm.org/citation.cfm?id=1251410},
volume = {29},
year = {2015}
}
@article{Abera2016a,
abstract = {The emerging and much-touted Internet of Things (IoT) presents a variety of security and privacy challenges. Promi-nent among them is the establishment of trust in remote IoT devices, which is typically attained via remote attestation, a distinct security service that aims to ascertain the cur-rent state of a potentially compromised remote device. Re-mote attestation ranges from relatively heavy-weight secure hardware-based techniques, to light-weight software-based ones, and also includes approaches that blend software (e.g., control-flow integrity) and hardware features (e.g., PUFs). In this paper, we survey the landscape of state-of-the-art attestation techniques from the IoT device perspective and argue that most of them have a role to play in IoT trust establishment.},
author = {Abera, Tigist and Asokan, N. and Davi, Lucas and Koushanfar, Farinaz and Paverd, Andrew and Sadeghi, Ahmad-Reza and Tsudik, Gene},
doi = {10.1145/2897937.2905020},
file = {:D$\backslash$:/Downloads/a121-abera.pdf:pdf},
isbn = {9781450342360},
keywords = {internet of things,remote attestation,trust establishment},
number = {3},
pages = {1--6},
title = {{Invited - Things, trouble, trust}},
year = {2016}
}
@article{AbuHmed2009,
abstract = {Sensor nodes are usually vulnerable to be com- promised due to their unattended deployment. The low cost requirement of the sensor node precludes using an expensive tamper resistant hardware for sensor physical protection. Thus, the adversary can reprogram the compromised sensors and deviates sensor network functionality. In this paper, we propose two simple software-based remote code attestation schemes for different WSN criterion. Our schemes use different indepen- dent memory noise filling techniques called pre-deployment and post-deployment noise filling, and also different communication protocols for attestation purpose. The protocols are well-suited for wireless sensor networks, where external factors , such as channel collision, result in network delay. Hence, the success of our schemes of attestation does not depend on the accurate mea- surement of the execution time, which is the main drawback of previously proposed wireless sensor network attestation schemes.},
author = {AbuHmed, Tamer and Nyamaa, Nandinbold and Nyang, Dae Hun},
doi = {10.1109/GLOCOM.2009.5425280},
file = {:D$\backslash$:/Downloads/05425280.pdf:pdf},
isbn = {9781424441488},
journal = {GLOBECOM - IEEE Global Telecommunications Conference},
keywords = {Security,Software attestation,Wireless sensor network},
pages = {1--8},
publisher = {IEEE},
title = {{Software-based remote code attestation in wireless sensor network}},
year = {2009}
}
@article{Moro2014a,
abstract = {njection of transient faults can be used as a way to attack embedded systems. On embedded processors such as microcontrollers, several studies showed that such a transient fault injection with glitches or electromagnetic pulses could corrupt either the data loads from the memory or the assembly instructions executed by the circuit. Some countermeasure schemes which rely on temporal redundancy have been proposed to handle this issue. Among them, several schemes add this redundancy at assembly instruction level. In this paper, we perform a practical evaluation for two of those countermeasure schemes by using a pulsed electromagnetic fault injection process on a 32-bit microcontroller. We provide some necessary conditions for an efficient implementation of those countermeasure schemes in practice. We also evaluate their efficiency and highlight their limitations. To the best of our knowledge, no experimental evaluation of the security of such instruction-level countermeasure schemes has been published yet.},
author = {Moro, Nicolas and Heydemann, Karine and Dehbaoui, Amine and Robisson, Bruno and Encrenaz, Emmanuelle},
doi = {10.1109/HST.2014.6855580},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Moro et al. - 2014 - Experimental evaluation of two software countermeasures against fault attacks.pdf:pdf},
isbn = {9781479941148},
journal = {Proceedings of the 2014 IEEE International Symposium on Hardware-Oriented Security and Trust, HOST 2014},
keywords = {assembly,countermeasure,fault injection,instruction skip,microcontroller},
pages = {112--117},
publisher = {IEEE},
title = {{Experimental evaluation of two software countermeasures against fault attacks}},
year = {2014}
}
@article{Thompson1984,
author = {Thompson, K E N},
file = {:D$\backslash$:/Downloads/p761-thompson.pdf:pdf},
number = {8},
pages = {761--763},
title = {{Reflections on Trusting Trust}},
volume = {27},
year = {1984}
}
@article{Liljestrand2018,
abstract = {Run-time attacks against programs written in memory-unsafe programming languages (e.g., C and C++) remain a prominent threat against computer systems. The prevalence of techniques like return-oriented programming (ROP) in attacking real-world systems has prompted major processor manufacturers to design hardware-based countermeasures against specific classes of run-time attacks. An example is the recently added support for pointer authentication (PA) in the ARMv8-A processor architecture, commonly used in devices like smartphones. PA is a low-cost technique to authenticate pointers so as to resist memory vulnerabilities. It has been shown to enable practical protection against memory vulnerabilities that corrupt return addresses or function pointers. However, so far, PA has received very little attention as a general purpose protection mechanism to harden software against various classes of memory attacks. In this paper, we use PA to build novel defenses against various classes of run-time attacks, including the first PA-based mechanism for data pointer integrity. We present PARTS, an instrumentation framework that integrates our PA-based defenses into the LLVM compiler and the GNU/Linux operating system and show, via systematic evaluation, that PARTS provides better protection than current solutions at a reasonable performance overhead},
archivePrefix = {arXiv},
arxivId = {1811.09189},
author = {Liljestrand, Hans and Nyman, Thomas and Wang, Kui and Perez, Carlos Chinea and Ekberg, Jan-Erik and Asokan, N.},
eprint = {1811.09189},
file = {:D$\backslash$:/Downloads/1811.09189.pdf:pdf},
title = {{PAC it up: Towards Pointer Integrity using ARM Pointer Authentication}},
url = {http://arxiv.org/abs/1811.09189},
year = {2018}
}
@article{Ergun2000,
abstract = {On Labor Day weekend, the highway patrol sets up spot-checks at random points on the freeways with the intention of deterring a large fraction of motorists from driving incorrectly. We explore a very similar idea in the context of program checking to ascertain with minimal overhead that a program output is reasonably correct. Our model of spot-checking requires that the spot-checker must run asymptotically much faster than the combined length of the input and output. We then show that the spot-checking model can be applied to problems in a wide range of areas, including problems regarding graphs, sets, and algebra. In particular, we present spot-checkers for sorting, convex hull, element distinctness, set containment, set equality, total orders, and correctness of group and field operations. All of our spot-checkers are very simple to state and rely on testing that the input and/or output have certain simple properties that depend on very few bits. Our results also give property tests as defined by Rubinfeld and Sudan (1996, SIAM J. Comput. 25, 252-271), Rubinfeld (1994, 'Proc. 35th Foundations of Computer Science,' pp. 288-299), and Goldreich et al. (1998, J. Assoc. Comput. Mach. 45, 653-750).},
author = {Erg{\"{u}}n, Funda and Kannan, Sampath and Kumar, S. Ravi and Rubinfeld, Ronitt and Viswanathan, Mahesh},
doi = {10.1006/jcss.1999.1692},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Erg{\"{u}}n et al. - 2000 - Spot-checkers.pdf:pdf},
issn = {00220000},
journal = {Journal of Computer and System Sciences},
number = {3},
pages = {717--751},
title = {{Spot-checkers}},
volume = {60},
year = {2000}
}
@article{Tice2014,
abstract = {Constraining dynamic control transfers is a common tech-nique for mitigating software vulnerabilities. This de-fense has been widely and successfully used to protect return addresses and stack data; hence, current attacks instead typically corrupt vtable and function pointers to subvert a forward edge (an indirect jump or call) in the control-flow graph. Forward edges can be protected us-ing Control-Flow Integrity (CFI) but, to date, CFI im-plementations have been research prototypes, based on impractical assumptions or ad hoc, heuristic techniques. To be widely adoptable, CFI mechanisms must be inte-grated into production compilers and be compatible with software-engineering aspects such as incremental compi-lation and dynamic libraries. This paper presents implementations of fine-grained, forward-edge CFI enforcement and analysis for GCC and LLVM that meet the above requirements. An analysis and evaluation of the security, performance, and resource consumption of these mechanisms applied to the SPEC CPU2006 benchmarks and common benchmarks for the Chromium web browser show the practicality of our ap-proach: these fine-grained CFI mechanisms have signif-icantly lower overhead than recent academic CFI proto-types. Implementing CFI in industrial compiler frame-works has also led to insights into design tradeoffs and practical challenges, such as dynamic loading.},
author = {Tice, Caroline and Roeder, Tom and Collingbourne, Peter and Checkoway, Stephen and Erlingsson, {\'{U}}lfar and Lozano, Luis and Pike, Geoff},
file = {:D$\backslash$:/Downloads/sec14-paper-tice.pdf:pdf},
isbn = {9781931971157},
journal = {{\{}USENIX{\}} Security},
pages = {941--955},
title = {{Enforcing Forward-Edge Control-Flow Integrity in {\{}GCC{\}} {\{}{\&}{\}} {\{}LLVM{\}}}},
url = {https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/tice},
year = {2014}
}
@inproceedings{Erlingsson2004,
abstract = {SASI (Security Automata SFI Implementation) enforces security policies by modifying object code for a target system before that system is executed. The approach has been prototyped for two rather different machine architec-tures: Intel x86 and Java JVML. Details of these prototypes and some generalizations about the SASI approach are discussed .},
address = {New York, New York, USA},
author = {Erlingsson, {\'{U}}lfar and Schneider, Fred B.},
booktitle = {Proceedings of the 1999 workshop on New security paradigms - NSPW '99},
doi = {10.1145/335169.335201},
file = {:D$\backslash$:/Downloads/00821527.pdf:pdf},
isbn = {1581131496},
number = {September},
pages = {87--95},
publisher = {ACM Press},
title = {{SASI enforcement of security policies}},
url = {http://portal.acm.org/citation.cfm?doid=335169.335201},
year = {2000}
}
@article{Avots2005,
abstract = {This paper presents a context-sensitive, inclusion-based, field-sensitive points-to analysis for C, which we use to detect and prevent program security vulnerabilities. In addition to a conservative points-to analysis, we propose an optimistic analysis that assumes a more restricted C semantics reflecting common C usage in order to increase the precision of the analysis. Using the proposed pointer alias analyses, we infer the types of variables in C programs and show that most C variables are used in a manner consistent with their declared types. We show that pointer analysis can be used to reduce the overhead of a dynamic string-buffer overflow detector by 30{\%} to 100{\%} among applications with significant overheads. Finally, using pointer analysis, we statically discover twelve actual format string vulnerabilities in three of the 12 programs we analyze.},
author = {Avots, Dzintars and Dalton, Michael and Livshits, V. Benjamin and Lam, Monica S.},
doi = {10.1145/1062455.1062520},
file = {:D$\backslash$:/Downloads/icse05.pdf:pdf},
isbn = {1581139632},
keywords = {buffer overflows,context-sensitive,dynamic analysis,error detection,format string violations,pointer analysis,program analysis,safety,security flaws,software security,type},
pages = {332},
title = {{Improving software security with a C pointer analysis}},
year = {2005}
}
@incollection{Chong2003,
abstract = {In this paper we present a generic and adaptable security module called CSAP (Communication, Security, Authentication, and Privacy) which may be used in order to make e-government and e-commerce systems secure and trustworthy. CSAP is service-oriented and offers programming interfaces to core security services such as user identification, authentication, access control, auditing, and security management. We discuss the conceptual architecture, the layered design, and the object-oriented implementation of CSAP. The layered design of CSAP allows the application developer to exchange or enhance security mechanisms via a plug-in concept based oil abstract classes and appropriate design patterns. As a consequence, CSAP becomes maintain able and adaptable. Among other services, CSAP provides all implementation of a role-based access control subsystem that conforms to the Core RBAC model as defined in the proposed NIST standard. Currently, CSAP is almost fully implemented and integrated in the WEBOCRAT system which in the framework of e-government - provides services supporting direct participation of citizens in democratic processes in a secure way.},
address = {Boston, MA},
author = {Chong, Cheun Ngen and Peng, Zhonghong and Hartel, Pieter H.},
booktitle = {Security and Privacy in the Age of Uncertainty},
doi = {10.1007/978-0-387-35691-4_7},
editor = {Gritzalis, Dimitris and {Capitani di Vimercati}, Sabrina and Samarati, Pierangela and Katsikas, Sokratis},
file = {:D$\backslash$:/Downloads/Chong2003{\_}Chapter{\_}SecureAuditLoggingWithTamper-R.pdf:pdf},
issn = {18684238},
keywords = {Adaptable security systems,Role-based access control (RBAC),Security architecture and services,Software design},
pages = {73--84},
publisher = {Springer US},
title = {{Secure Audit Logging with Tamper-Resistant Hardware}},
url = {http://link.springer.com/10.1007/978-0-387-35691-4{\_}7},
volume = {122},
year = {2003}
}
@article{Samyde2003,
abstract = {This paper explains a new family of techniques to extract data from semiconductor memory, without using the read-out circuitry provided for the purpose. What these techniques have in common is the use of semi-invasive probing methods to induce measurable changes in the analogue characteristics of the memory cells of interest. The basic idea is that when a memory cell, or read-out amplifier, is scanned appropriately with a laser, the resulting increase in leakage current depends on its state; the same happens when we induce an eddy current in a cell. These perturbations can be carried out at a level that does not modify the stored value, but still enables it to be read out. Our techniques build on it number of recent advances in semi-invasive attack techniques, low temperature data remanence, electromagnetic analysis and eddy current induction. They can be used against a wide range of memory structures, from registers through RAM to FLASH. We have demonstrated their practicality by reading out DES keys stored in RAM without using the normal read-out circuits. This suggests that vendors of products such as smartcards and secure microcontrollers should review their memory encryption, access control and other storage security issues with care.},
author = {Samyde, D. and Skorobogatov, S. and Anderson, R. and Quisquater, J. J.},
doi = {10.1109/SISW.2002.1183512},
file = {:D$\backslash$:/Downloads/01183512.pdf:pdf},
isbn = {0769518885},
journal = {Proceedings - 1st International IEEE Security in Storage Workshop, SISW 2002},
keywords = {Smartcards,data remanence,eddy current attack,electromagnetic security,optical probing,semi-invasive attacks,tamper resistance},
pages = {65--69},
publisher = {IEEE},
title = {{On a new way to read data from memory}},
year = {2003}
}
@article{Chang2002,
abstract = {Protection of software code against illegitimate modifications by its users is a pressing issue to many software developers. Many software-based mechanisms for protecting program code are too weak (e.g., they have single points of failure) or too expensive to apply (e.g., they incur heavy runtime performance penalty to the protected programs). In this paper, we present and explore a methodology that we believe can protect program integrity in a more tamper-resilient and flexible manner. Our approach is based on a distributed scheme, in which protection and tamper-resistance of program code is achieved, not by a single security module, but by a network of (smaller) security units that work together in the program. These security units, or guards, can be programmed to do certain tasks (checksumming the program code is one example) and a network of them can reinforce the protection of each other by creating mutual-protection. We have implemented a system for automating the process of installing guards into Win32 executables. It is because our system operates on binaries that we are able to apply our protection mechanism to EXEs and DLLs. Experimental results show that memory space and runtime performance impacts incurred by guards can be kept very low (as explained later in the paper).},
author = {Chang, Hoi and Atallah, Mikhail J.},
doi = {10.1007/3-540-47870-1_10},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chang, Atallah - 2002 - Protecting software code by guards.pdf:pdf},
isbn = {3540436774},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {160--175},
title = {{Protecting software code by guards}},
volume = {2320},
year = {2002}
}
@article{Dang,
author = {Dang, Thurston H Y and Wagner, David},
file = {:D$\backslash$:/Downloads/p555-dang.pdf:pdf},
isbn = {9781450332453},
journal = {Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security},
pages = {555--566},
title = {{The Performance Cost of Shadow Stacks and Stack Canaries Time of Check to Time of Use}},
year = {2015}
}
@article{Asokan2014,
abstract = {Trusted computing technologies for mobile devices have been researched, developed, and deployed over the past decade. Although their use has been limited so far, ongoing standardization may change this by opening up these technologies for easy access by developers and users. In this survey, we describe the current state of trusted computing solutions for mobile devices from research, standardization, and deployment perspectives.},
author = {Asokan, N. and Ekberg, Jan Erik and Kostiainen, Kari and Rajan, Anand and Rozas, Carlos and Sadeghi, Ahmad Reza and Schulz, Steffen and Wachsmann, Christian},
doi = {10.1109/JPROC.2014.2332007},
file = {:D$\backslash$:/Downloads/06856168.pdf:pdf},
issn = {00189219},
journal = {Proceedings of the IEEE},
keywords = {Attestation,low-cost trusted execution,mobile security,physically unclonable functions (PUFs),trusted computing},
number = {8},
pages = {1189--1206},
publisher = {IEEE},
title = {{Mobile trusted computing}},
volume = {102},
year = {2014}
}
@article{Blum1995,
author = {Blum, Manuel},
doi = {10.1145/200836.200880},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Blum - 1995 - Designing programs that check their work.pdf:pdf},
journal = {Journal of the ACM},
number = {1},
pages = {269--291},
title = {{Designing programs that check their work}},
url = {http://portal.acm.org/citation.cfm?id=73015},
volume = {42},
year = {1995}
}
@incollection{Kohnhauser2015,
abstract = {Abstract. In recent years, low-end embedded devices have been used increasingly in various scenarios, ranging from consumer electronics to industrial equipment. However, this evolution made embedded devices profitable targets for software piracy and software manipulation. Aggra- vating this situation, low-end embedded devices typically lack secure hardware to effectively protect against such attacks. In this work, we present a novel software protection scheme, which is particularly suited for already deployed low-end embedded devices without secure hardware. Our approach combines techniques based on self-checksumming code with Physically Unclonable Functions (PUFs) to establish a hardware- assisted software protection. In this way, we can tie the execution of a software instance to a specific device and protect its program code against manipulations. We show that our software protection scheme offers a high level of security against static adversaries and demonstrate that dynamic adversaries require considerable resources to perform a successful attack. To explore the feasibility of our solution, we implemented the protection scheme on an ARM-based low-end commodity microcontroller. A further performance evaluation shows that the implemented solution exhibits a fair overhead of ten percent.},
archivePrefix = {arXiv},
arxivId = {arXiv:1506.07739v2},
author = {Kohnh{\"{a}}user, Florian and Schaller, Andr{\'{e}} and Katzenbeisser, Stefan},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-22846-4_1},
eprint = {arXiv:1506.07739v2},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kohnh{\"{a}}user, Schaller, Katzenbeisser - 2015 - PUF-Based Software Protection for Low-End Embedded Devices.pdf:pdf},
isbn = {9783319228457},
issn = {16113349},
pages = {3--21},
title = {{PUF-Based Software Protection for Low-End Embedded Devices}},
url = {http://link.springer.com/10.1007/978-3-319-22846-4{\_}1},
volume = {9229},
year = {2015}
}
@article{Nyman2015,
abstract = {New types of Trusted Execution Environment (TEE) architectures like TrustLite and Intel Software Guard Extensions (SGX) are emerging. They bring new features that can lead to innovative security and privacy solutions. But each new TEE environment comes with its own set of interfaces and programming paradigms, thus raising the barrier for entry for developers who want to make use of these TEEs. In this paper, we motivate the need for realizing standard TEE interfaces on such emerging TEE architectures and show that this exercise is not straightforward. We report on our on-going work in mapping GlobalPlatform standard interfaces to TrustLite and SGX.},
archivePrefix = {arXiv},
arxivId = {arXiv:1506.07739v2},
author = {Nyman, Thomas and McGillion, Brian and Asokan, N.},
doi = {10.1007/978-3-319-22846-4_4},
eprint = {arXiv:1506.07739v2},
file = {:D$\backslash$:/Downloads/1506.07739.pdf:pdf},
isbn = {9783319228457},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {58--67},
title = {{On making emerging trusted execution environments accessible to developers}},
volume = {9229},
year = {2015}
}
@article{Hu2016,
abstract = {As control-flow hijacking defenses gain adoption, it is important to understand the remaining capabilities of adversaries via memory exploits. Non-control data exploits are used to mount information leakage attacks or privilege escalation attacks program memory. Compared to control-flow hijacking attacks, such non-control data exploits have limited expressiveness, however, the question is: what is the real expressive power of non-control data attacks? In this paper we show that such attacks are Turing-complete. We present a systematic technique called data-oriented programming (DOP) to construct expressive non-control data exploits for arbitrary x86 programs. In the experimental evaluation using 9 programs, we identified 7518 data-oriented x86 gadgets and 5052 gadget dispatchers, which are the building blocks for DOP. 8 out of 9 real-world programs have gadgets to simulate arbitrary computations and 2 of them are confirmed to be able to build Turing-complete attacks. We build 3 end-to-end attacks to bypass randomization defenses without leaking addresses, to run a network bot which takes commands from the attacker, and to alter the memory permissions. All the attacks work in the presence of ASLR and DEP, demonstrating how the expressiveness offered by DOP significantly empowers the attacker.},
author = {Hu, Hong and Shinde, Shweta and Adrian, Sendroiu and Chua, Zheng Leong and Saxena, Prateek and Liang, Zhenkai},
doi = {10.1109/SP.2016.62},
file = {:D$\backslash$:/Downloads/07546545.pdf:pdf},
isbn = {9781509008247},
journal = {Proceedings - 2016 IEEE Symposium on Security and Privacy, SP 2016},
pages = {969--986},
publisher = {IEEE},
title = {{Data-Oriented Programming: On the Expressiveness of Non-control Data Attacks}},
year = {2016}
}
@article{Theissing2013,
abstract = {Fault tolerant software against fault attacks constitutes an important class of countermeasures for embedded systems. In this work, we implemented and systematically analyzed a comprehensive set of 19 different strategies for software countermeasures with respect to protection effectiveness as well as time and memory efficiency. We evaluated the performance and security of all implementations by fault injections into a microcontroller simulator based on an ARM Cortex-M3. Our results show that some rather simple countermeasures outperform other more sophisticated methods due to their low memory and/or performance overhead. Further, combinations of countermeasures show strong characteristics and can lead to a high fault coverage, while keeping additional resources at a minimum. The results obtained in this study provide developers of secure software for embedded systems with a solid basis to decide on the right type of fault attack countermeasure for their application.},
author = {Theissing, Nikolaus and Merli, Dominik and Smola, Michael and Stumpf, Frederic and Sigl, Georg},
doi = {10.7873/DATE.2013.092},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Theissing et al. - 2013 - Comprehensive Analysis of Software Countermeasures against Fault Attacks.pdf:pdf},
isbn = {9781467350716},
issn = {15301591},
journal = {Design, Automation {\&} Test in Europe Conference {\&} Exhibition (DATE), 2013},
pages = {404--409},
publisher = {IEEE},
title = {{Comprehensive Analysis of Software Countermeasures against Fault Attacks}},
url = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6513538},
year = {2013}
}
@article{Ott2018,
author = {Ott, Karl and Mahapatra, Rabi},
doi = {10.1109/DASC/PiCom/DataCom/CyberSciTec.2018.00101},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ott, Mahapatra - 2018 - Hardware performance counters for embedded software anomaly detection.pdf:pdf},
isbn = {9781538675182},
journal = {Proceedings - IEEE 16th International Conference on Dependable, Autonomic and Secure Computing, IEEE 16th International Conference on Pervasive Intelligence and Computing, IEEE 4th International Conference on Big Data Intelligence and Computing and IEEE 3},
keywords = {Embedded Systems,Hardware Performance Counters,Security},
pages = {528--535},
publisher = {IEEE},
title = {{Hardware performance counters for embedded software anomaly detection}},
year = {2018}
}
@article{Ekberg2014,
abstract = {A trusted execution environment (TEE) is a secure process- ing environment that is isolated from the “normal” process- ing environment where the device operating system and ap- plications run. The firstmobile phones with hardware-based TEEs appeared almost a decade ago, and today almost every smartphone and tablet contains a TEE like ARMTrustZone. Despite such a large-scale deployment, the use of TEE func- tionality has been limited for developers. With emerging standardization this situation is about to change. In this tutorial, we explain the security features provided by mo- bile TEEs and describe On-board Credentials (ObC) system that enables third-party TEE development. We discuss on- going TEE standardization activities, including the recent Global Platform standards and the Trusted Platform Mod- ule (TPM) 2.0 specification, and identify open problems for the near future of mobile hardware security.},
author = {Ekberg, Jan Erik and Kostiainen, Kari and Asokan, N.},
doi = {10.1109/MSP.2014.38},
file = {:D$\backslash$:/Downloads/06799152.pdf:pdf},
issn = {15407993},
journal = {IEEE Security and Privacy},
keywords = {mobile devices,security,trusted execution environments},
number = {4},
pages = {29--37},
publisher = {IEEE},
title = {{The untapped potential of trusted execution environments on mobile devices}},
volume = {12},
year = {2014}
}
@article{Kleber2015,
abstract = {A persistent problem with program execution, despite nu-merous mitigation attempts, is its inherent vulnerability to the injec-tion of malicious code. Equally unsolved is the susceptibility of firmware to reverse engineering, which undermines the manufacturer's code con-fidentiality. We propose an approach that solves both kinds of security problems employing instruction-level code encryption combined with the use of a physical unclonable function (PUF). Our novel Secure Execution PUF-based Processor (SEPP) architecture is designed to minimize the attack surface, as well as performance impact, and requires no significant changes to the development process. This is possible based on a tight integration of a PUF directly into the processor's instruction pipeline. Furthermore, cloud scenarios and distributed embedded systems alike inherently depend on remote execution; our approach supports this, as the secure execution environment needs not to be locally available at the developers site. We implemented an FPGA-based prototype based on the OpenRISC Reference Platform. To assess our results, we performed a security analysis of the processor and evaluated the performance im-pact of the encryption. We show that the attack surface is significantly reduced compared to previous approaches while the performance penalty is at a reasonable factor of about 1.5.},
author = {Kleber, Stephan and Unterstein, Florian and Matousek, Matthias and Kargl, Frank and Slomka, Frank and Hiller, Matthias},
doi = {cr.org/2015/651},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kleber et al. - 2015 - Secure Execution Architecture based on PUF-driven Instruction Level Code Encryption.pdf:pdf},
journal = {Cryptology ePrint Archive, Report 2015/651},
keywords = {and matthias hiller 3,encryption,florian unterstein 1,frank kargl 1,frank slomka 2,matthias matousek 1,on,puf-driven instruction level code,stephan kleber 1,ure execution architecture based},
title = {{Secure Execution Architecture based on PUF-driven Instruction Level Code Encryption}},
year = {2015}
}
@article{Harrison2019,
author = {Harrison, William L. and Allwein, Gerard},
doi = {10.1109/RECONFIG.2018.8641707},
file = {:D$\backslash$:/Downloads/08641707.pdf:pdf},
isbn = {9781728119687},
journal = {2018 International Conference on Reconfigurable Computing and FPGAs, ReConFig 2018},
keywords = {component,formatting,insert,style,styling},
pages = {1--6},
publisher = {IEEE},
title = {{Language abstractions for hardware-based control-flow integrity monitoring}},
year = {2019}
}
@article{Suh2005,
abstract = {Secure processors enable new applications by ensuring private and authentic program execution even in the face of physical attack. In this paper, we present the AEGIS secure processor architecture, and evaluate its RTL implementation on FPGAs. By using physical random functions, we propose a new way of reliably protecting and sharing secrets that is more secure than existing solutions based on non-volatile memory. Our architecture gives applications the flexibility of trusting and protecting only a portion of a given process, unlike prior proposals which require a process to be protected in entirety. We also put forward a specific model of how secure applications can be programmed in a high-level language and compiled to run on our system. Finally, we evaluate a fully functional FPGA implementation of our processor, assess the implementation tradeoffs, compare performance, and demonstrate the benefits of partially protecting a program.},
author = {Suh, G. Edward and O'Donnell, Charles W. and Sachdev, Ishan and Devadas, Srinivas},
doi = {10.1145/1080695.1069974},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Suh et al. - 2005 - Design and Implementation of the AEGIS Single-Chip Secure Processor Using Physical Random Functions.pdf:pdf},
issn = {01635964},
journal = {ACM SIGARCH Computer Architecture News},
number = {2},
pages = {25--36},
title = {{Design and Implementation of the AEGIS Single-Chip Secure Processor Using Physical Random Functions}},
volume = {33},
year = {2005}
}
@article{Ferguson2003,
abstract = {Helix is a high-speed stream cipher with a built-in MAC functionality. On a Pentium II CPU it is about twice as fast as Rijndael or Twofish, and comparable in speed to RC4. The overhead per encrypted/authenticated message is low, making it suitable for small messages. It is efficient in both hardware and software, and with some pre-computation can effectively switch keys on a per-message basis without additional overhead.},
author = {Ferguson, Niels and Whiting, Doug and Schneier, Brace and Kelsey, John and Lucks, Stefan and Kohno, Tadayoshi},
file = {:D$\backslash$:/Downloads/paper-helix.pdf:pdf},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {Authentication,Encryption,MAC,Stream cipher},
pages = {330--346},
title = {{Helix: Fast encryption and authentication in a single cryptographic primitive}},
volume = {2887},
year = {2003}
}
@article{Mahmood1988,
abstract = {Concurrent system-level error detection techniques using a watchdog processor are surveyed. A watchdog processor is a small and simple coprocessor that detects errors by monitoring the behavior of a system. Like replication, it does not depend on any fault model for error detection. However, it requires less hardware than replication. It is shown that a large number of errors can be detected by monitoring the control flow and memory-access behavior. Two techniques for control-flow checking are discussed and compared with current error-detection techniques. A scheme for memory-access checking based on capability-based addressing is described. The design of a watchdog for performing reasonable checks on the output of a main processor by executing assertions is discussed.},
author = {Mahmood, Aamer and Mccluskey, E. J.},
doi = {10.1109/12.2145},
file = {:D$\backslash$:/Downloads/00002145.pdf:pdf},
issn = {00189340},
journal = {IEEE Transactions on Computers},
keywords = {Capability-based addressing,concurrent checking,control flow checking coprocessor,distributed computing,executable assertions,microprogramming,parallel computing,signature analysis,system-level error detection,watchdog processor},
number = {2},
pages = {160--174},
publisher = {IEEE},
title = {{Concurrent Error Detection Using Watchdog Processors—A Survey}},
volume = {37},
year = {1988}
}
@article{Mccune2009,
author = {Mccune, Jonathan M and Qu, Ning and Li, Yanlin and Datta, Anupam and Gligor, Virgil D and Perrig, Adrian and Zhou, Zongwei},
file = {:D$\backslash$:/Downloads/10.1.1.168.6168.pdf:pdf},
journal = {Science},
title = {{TrustVisor : Efficient TCB Reduction and Attestation TrustVisor : Efficient TCB Reduction and Attestation ∗}},
volume = {2009},
year = {2009}
}
@article{Alkhalifa1999,
abstract = {This paper evaluates the concurrent error detection capabilities$\backslash$nof system-level checks, using fault and error injection. The checks$\backslash$ncomprise application and system level mechanisms to detect control flow$\backslash$nerrors. We propose Enhanced Control-Flow Checking Using Assertions$\backslash$n(ECCA). In ECCA, branch-free intervals (BFI) in a given high or$\backslash$nintermediate level program are identified and the entry and exit points$\backslash$nof the intervals are determined. BFls are then grouped into blocks, the$\backslash$nsize of which is determined through a performance/overhead analysis. The$\backslash$nblocks are then fortified with preinserted assertions. For the high$\backslash$nlevel ECCA, we describe an implementation of ECCA through a preprocessor$\backslash$nthat will automatically insert the necessary assertions into the$\backslash$nprogram. Then, we describe the intermediate implementation possible$\backslash$nthrough modifications made on gee to make it ECCA capable. The fault$\backslash$ndetection capabilities of the checks are evaluated both analytically and$\backslash$nexperimentally. Fault injection experiments are conducted using FERRARI$\backslash$nto determine the fault coverage of the proposed techniques},
author = {Alkhalifa, Z. and Nair, V. S.S. and Krishnamurthy, N. and Abraham, J. A.},
doi = {10.1109/71.774911},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Alkhalifa et al. - 1999 - Design and evaluation of system-level checks for on-line control flow error detection.pdf:pdf},
issn = {10459219},
journal = {IEEE Transactions on Parallel and Distributed Systems},
number = {6},
pages = {627--641},
title = {{Design and evaluation of system-level checks for on-line control flow error detection}},
volume = {10},
year = {1999}
}
@book{AhoAlfredV.2014C:pt,
annote = {Chapter 9 for Data-Flow Analysis},
author = {Aho, Alfred V},
edition = {Second edi},
isbn = {9781292024349},
keywords = {Compilers (Computer programs)},
publisher = {Pearson custom library},
title = {{Compilers : principles, techniques, and tools.}},
year = {2014}
}
@article{Cheng2019,
abstract = {Data-oriented attacks manipulate non-control data to alter a program's benign behavior without violating its control-flow integrity. It has been shown that such attacks can cause significant damage even in the presence of control-flow defense mechanisms. However, these threats have not been adequately addressed. In this SoK paper, we first map data-oriented exploits, including Data-Oriented Programming (DOP) attacks, to their assumptions/requirements and attack capabilities. We also compare known defenses against these attacks, in terms of approach, detection capabilities, overhead, and compatibility. Then, we experimentally assess the feasibility of a detection approach that is based on the Intel Processor Trace (PT) technology. PT only traces control flows, thus, is generally believed to be not useful for data-oriented security. However, our work reveals that data-oriented attacks (in particular the recent DOP attacks) may generate side-effects on control-flow behavior in multiple dimensions, which manifest in PT traces. Based on this evaluation, we discuss challenges for building deployable data-oriented defenses and open research questions.},
archivePrefix = {arXiv},
arxivId = {1902.08359},
author = {Cheng, Long and Liljestrand, Hans and Nyman, Thomas and Lee, Yu Tsung and Yao, Danfeng and Jaeger, Trent and Asokan, N.},
eprint = {1902.08359},
file = {:D$\backslash$:/Downloads/1902.08359.pdf:pdf},
title = {{Exploitation Techniques and Defenses for Data-Oriented Attacks}},
url = {http://arxiv.org/abs/1902.08359},
year = {2019}
}
@misc{MicrosoftCorporation2018,
author = {{Microsoft Corporation}},
title = {{Control Flow Guard}},
url = {https://docs.microsoft.com/en-gb/windows/win32/secbp/control-flow-guard},
urldate = {2019-08-19},
year = {2018}
}
@article{Davi2014,
abstract = {Return-oriented programming (ROP) offers a robust attack technique that has, not surprisingly, been extensively used to exploit bugs in modern software programs (e.g., web browsers and PDF readers). ROP attacks require no code injection, and have already been shown to be powerful enough to bypass fine-grained memory randomization (ASLR) defenses. To counter this ingenious attack strategy, several proposals for enforcement of (coarse-grained) control-flow integrity (CFI) have emerged. The key argument put forth by these works is that coarse-grained CFI policies are sufficient to prevent ROP attacks. As this reasoning has gained traction, ideas put forth in these proposals have even been incorporated into coarse-grained CFI defenses in widely adopted tools (e.g., Microsoft's EMET framework). In this paper, we provide the first comprehensive security analysis of various CFI solutions (covering kBouncer, ROPecker, CFI for COTS binaries, ROPGuard, and Microsoft EMET 4.1). A key contribution is in demonstrating that these techniques can be effectively undermined, even under weak adversarial assumptions. More specifically, we show that with bare minimum assumptions, turing-complete and real-world ROP attacks can still be launched even when the strictest of enforcement policies is in use. To do so, we introduce several new ROP attack primitives, and demonstrate the practicality of our approach by transforming existing real-world exploits into more stealthy attacks that bypass coarse-grained CFI defenses.},
author = {Davi, Lucas and Sadeghi, Ahmad-reza and Lehmann, Daniel and Monrose, Fabian},
file = {:D$\backslash$:/Downloads/eae2bb5641825e61a2ca5be3e75711929af8.pdf:pdf},
isbn = {978-1-931971-15-7},
journal = {Proceedings of the 23rd USENIX Security Symposium (USENIX Security 2014)},
pages = {401--416},
title = {{Stitching the Gadgets: On the Ineffectiveness of Coarse-Grained Control-Flow Integrity Protection}},
url = {https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/davi},
year = {2014}
}
@article{Shacham2007,
abstract = {We present new techniques that allow a return-into-libc attack to be mounted on x86 executables that calls no functions at all. Our attack combines a large number of short instruction sequences to build gadgets that allow arbitrary computation. We show how to discover such instruction sequences by means of static analysis. We make use, in an essential way, of the properties of the x86 instruction set.},
author = {Shacham, Hovav},
doi = {10.1145/1315245.1315313},
file = {:D$\backslash$:/Downloads/p552-shacham.pdf:pdf},
isbn = {9781595937032},
journal = {CCS '07 Proceedings of the 14th ACM conference on Computer and communications security},
keywords = {instruction set,return-into-libc,turing completeness},
pages = {552--561},
title = {{The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86)}},
year = {2007}
}
@article{Rubinfeld1992,
abstract = {We introduce the model of batch checking, which allows one to check the result of a program on many inputs at once. We show that one can batch check programs for linear functions with very little overhead in the running time. {\textcopyright} 1992.},
author = {Rubinfeld, Ronitt},
doi = {10.1016/0020-0190(92)90093-B},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Rubinfeld - 1992 - Batch checking with applications to linear functions.pdf:pdf},
issn = {00200190},
journal = {Information Processing Letters},
keywords = {Design of algorithms,program correctness},
number = {2},
pages = {77--80},
title = {{Batch checking with applications to linear functions}},
volume = {42},
year = {1992}
}
@article{Bresch2018,
abstract = {Connected medical devices are promising in medical area. However, these devices are known to be poor in security and strongly vulnerable to code injection attacks. These attacks aim at modifying the run-time behavior of an application by violating its control flow graph. Control flow hijacking can lead hackers to remotely control medical application and endanger patient's life. This article focuses on devices and provides an overview of the different countermeasures that mitigate run-time attacks. Finally, from this state of the art, we will expose the perspectives and the ongoing work to make medical devices inherently more secure.},
annote = {A good, simple overview},
author = {Bresch, Cyril and Chollet, St{\'{e}}phanie and H{\'{e}}ly, David},
doi = {10.1109/ICIOT.2018.00027},
file = {:D$\backslash$:/Downloads/08473452.pdf:pdf},
isbn = {9781538672440},
journal = {Proceedings - 2018 IEEE International Congress on Internet of Things, ICIOT 2018 - Part of the 2018 IEEE World Congress on Services},
keywords = {Component,Control flow integrity,Hardware architecture,Trust environment},
pages = {140--147},
title = {{Towards an inherently secure run-time environment for medical devices}},
year = {2018}
}
@article{Kennell2003,
abstract = {A fundamental problem in distributed computing environments involves determining whether a remote computer system can be trusted to autonomously access secure resources via a network. In this paper, we describe a means by which a remote computer system can be challenged to demonstrate that it is genuine and trustworthy. Upon passing a test, it can be granted access to distributed resources and can serve as a general-purpose host for distributed computation so long as it remains in contact with some certifying authority. The test we describe is applicable to consumer-grade computer systems with a conventional network interface and requires no additional hardware. The results of the test can be conveyed over an unsecured network; no trusted human intermediary is needed to relay the results. We examine potential attacks and weaknesses of the system and show how they can be avoided. Finally, we describe an implementation of a genuinity test for a representative set of computer systems.},
author = {Kennell, Rick and Jamieson, Leah H},
file = {:D$\backslash$:/Downloads/898be2cedb9e07aa78a21e996e8ae326dc2f.pdf:pdf},
issn = {03601315},
journal = {Proceedings of the 12th USENIX Security Symposium},
number = {3},
pages = {608--616},
title = {{Establishing the Genuinity of Remote Computer Systems}},
url = {http://www.sciencedirect.com/science/article/pii/S0360131508001668},
volume = {52},
year = {2003}
}
@article{Korner2012,
author = {Korner, Thomas William},
file = {:D$\backslash$:/Downloads/cpi.pdf:pdf},
isbn = {9781931971164},
journal = {Scepticism: Hero and Villain},
number = {October},
pages = {47--56},
title = {{Code-Pointer Integrity}},
url = {https://infoscience.epfl.ch/record/204783},
year = {2012}
}
@article{Al-Wosabi2015,
abstract = {Embedded systems (ES) become available anywhere and anytime as an established part of our daily routine. Developers of these systems face significant challenges in code and information security. Whereas, software tampering is one of these challenges, code integrity detection is one of the main approaches used to defeat it. Checking code integrity achieves tamper proofing by method of identification of unauthorized alteration to recognize any tampered code is executed or tampered data are used. Our research objective is to propose an applicable framework for tampering detection in ES and this paper introduces the exploratory outcomes so far.},
author = {Al-Wosabi, Abdo Ali Abdullah and Shukur, Zarina and Ibrahim, Muhammad Azwan},
doi = {10.1109/ICEEI.2015.7352507},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Al-Wosabi, Shukur, Ibrahim - 2015 - Framework for software tampering detection in embedded systems.pdf:pdf},
isbn = {9781467373197},
journal = {Proceedings - 5th International Conference on Electrical Engineering and Informatics: Bridging the Knowledge between Academic, Industry, and Community, ICEEI 2015},
keywords = {Embedded Systems,Software Integrity,Software Tampering,Tampering Detection},
number = {January 2016},
pages = {259--264},
title = {{Framework for software tampering detection in embedded systems}},
year = {2015}
}
@article{Anderson1996bad,
author = {Anderson, R. and Kuhn, M.},
file = {:D$\backslash$:/Downloads/57508cf35d8762e152eb3d4f0e872ae79ba6.pdf:pdf},
isbn = {1880446839},
pages = {1--11},
title = {{Tamper Resistance — a Cautionary Note}},
url = {http://www.cl.cam.ac.uk/{~}rja14/Papers/tamper.pdf https://dl.acm.org/citation.cfm?id=1267168},
year = {1996}
}
@article{Davi2012,
abstract = {Runtime and control-flow attacks (such as code injection or return-oriented programming) constitute one of the most severe threats to software programs. These attacks are prevalent and have been recently applied to smartphone applications as well, of which hundreds of thousands are downloaded by users every day. While a framework for control-flow integrity (CFI) enforcement, an approach to prohibit this kind of attacks, exists for the Intel x86 platform, there is no such a solution for smartphones. In this paper, we present a novel framework, MoCFI (Mobile CFI), that provides a general countermeasure against control-flow attacks on smartphone platforms by enforcing CFI. We show that CFI on typical smartphone platforms powered by an ARM processor is technically involved due to architectural differences between ARMand Intel x86, as well as the specifics of smartphone OSes. Our framework performs CFI on-the-fly during runtime without requiring the application's source code. For our reference implementation we chose Apple's iOS, because it has been an attractive target for control-flow attacks. Nevertheless, our framework is also applicable to other ARM-based devices such as Google's Android. Our performance evaluation demonstrates that MoCFI is efficient and does not induce notable overhead when applied to popular iOS applications.},
author = {Davi, Lucas and Dmitrienko, Alexandra and Egele, Manuel and Thomas, Fischer and Holz, Thorsten and Hund, Ralf and Nurnberger, Stefan and Sadeghi, Ahmad-Reza},
file = {:D$\backslash$:/Downloads/699356089cca6bcf063af6841228afaa0f3e.pdf:pdf},
journal = {Symposium on Network and Distributed System Security},
title = {{MoCFI: A framework to mitigate control-flow attacks on smartphones}},
url = {https://pdfs.semanticscholar.org/fb43/699356089cca6bcf063af6841228afaa0f3e.pdf},
year = {2012}
}
@inproceedings{Christoulakis2016,
address = {New York, New York, USA},
author = {Christoulakis, Nick and Christou, George and Athanasopoulos, Elias and Ioannidis, Sotiris},
booktitle = {Proceedings of the Sixth ACM on Conference on Data and Application Security and Privacy - CODASPY '16},
doi = {10.1145/2857705.2857722},
file = {:D$\backslash$:/Downloads/codaspy{\_}submission.pdf:pdf},
isbn = {9781450339353},
pages = {38--49},
publisher = {ACM Press},
title = {{HCFI}},
url = {http://dl.acm.org/citation.cfm?doid=2857705.2857722},
year = {2016}
}
@article{Bletsch2011,
abstract = {Code-reuse attacks are software exploits in which an attacker directs control flow through existing code with a malicious result. One such technique, return-oriented programming, is based on "gadgets" (short pre-existing sequences of code ending in a ret instruction) being executed in arbitrary order as a result of a stack corruption exploit. Many existing codereuse defenses have relied upon a particular attribute of the attack in question (e.g., the frequency of ret instructions in a return-oriented attack), which leads to an incomplete protection, while a smaller number of efforts in protecting all exploitable control flow transfers suffer from limited deploy-ability due to high performance overhead. In this paper, we present a novel cost-effective defense technique called control flow locking, which allows for effective enforcement of control flow integrity with a small performance overhead. Specifically, instead of immediately determining whether a control flow violation happens before the control flow transfer takes place, control flow locking lazily detects the violation after the transfer. To still restrict attackers' capability, our scheme guarantees that the deviation of the normal control flow graph will only occur at most once. Further, our scheme ensures that this deviation cannot be used to craft a malicious system call, which denies any potential gains an attacker might obtain from what is permitted in the threat model. We have developed a proof-of-concept prototype in Linux and our evaluation demonstrates desirable effectiveness and competitive performance overhead with existing techniques. In several benchmarks, our scheme is able to achieve significant gains.},
author = {Bletsch, Tyler and Jiang, Xuxian and Freeh, Vince},
doi = {10.1145/2076732.2076783},
file = {:D$\backslash$:/Downloads/p353-bletsch.pdf:pdf},
pages = {353},
title = {{Mitigating code-reuse attacks with control-flow locking}},
year = {2011}
}
@article{Dijk2013,
abstract = {This paper investigates secure ways to interact with tamper-resistant hardware leaking a strictly bounded amount of information. Architectural support for the interaction mechanisms is studied and performance implications are evaluated. The interaction mechanisms are built on top of a recently-proposed secure processor Ascend[ascend-stc12]. Ascend is chosen because unlike other tamper-resistant hardware systems, Ascend completely obfuscates pin traffic through the use of Oblivious RAM (ORAM) and periodic ORAM accesses. However, the original Ascend proposal, with the exception of main memory, can only communicate with the outside world at the beginning or end of program execution; no intermediate information transfer is allowed. Our system, Stream-Ascend, is an extension of Ascend that enables intermediate interaction with the outside world. Stream-Ascend significantly improves the generality and efficiency of Ascend in supporting many applications that fit into a streaming model, while maintaining the same security level.Simulation results show that with smart scheduling algorithms, the performance overhead of Stream-Ascend relative to an insecure and idealized baseline processor is only 24.5{\%}, 0.7{\%}, and 3.9{\%} for a set of streaming benchmarks in a large dataset processing application. Stream-Ascend is able to achieve a very high security level with small overheads for a large class of applications. {\textcopyright} 2013 ACM.},
author = {van Dijk, Marten and Yu, Xiangyao and Ren, Ling and Fletcher, Christopher W. and Devadas, Srinivas},
doi = {10.1145/2517488.2517498},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Dijk et al. - 2013 - Generalized external interaction with tamper-resistant hardware with bounded information leakage.pdf:pdf},
isbn = {9781450324908},
keywords = {ascend,interaction,pin traffic,tamper-resistant hardware},
pages = {23--34},
title = {{Generalized external interaction with tamper-resistant hardware with bounded information leakage}},
year = {2013}
}
@article{TCG2007,
author = {TCG},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/TCG - 2007 - TCG TCG Specification Architecture Overview Specification Revision 1.4 2 nd.pdf:pdf},
number = {August},
title = {{TCG TCG Specification Architecture Overview Specification Revision 1.4 2 nd}},
url = {https://trustedcomputinggroup.org/wp-content/uploads/TCG{\_}1{\_}4{\_}Architecture{\_}Overview.pdf},
year = {2007}
}
@incollection{Werner2016,
abstract = {Massively deploying RFID systems while preserving people's privacy and data integrity is a major security challenge of the$\backslash$r coming years. Up to now, it was commonly believed that, due to the very limited computational resources of RFID tags, only$\backslash$r ad hoc methods could be used to address this problem. Unfortunately, not only those methods generally provide a weak level$\backslash$r of security and practicality, but they also require to revise the synopsis of communications between the tag and the reader.$\backslash$r In this paper, we give evidence that highly secure solutions can be used in the RFID environment, without substantially impacting$\backslash$r the current communication protocols, by adequately choosing and combining low-cost cryptographic algorithms. The main ingredients$\backslash$r of our basic scheme are a probabilistic (symmetric or asymmetric) encryption function, e.g. AES, and a coupon-based signature$\backslash$r function, e.g. GPS. We also propose a dedicated method allowing the tag to authenticate the reader, which is of independent$\backslash$r interest. On the whole, this leads to a privacy-preserving protocol well suited for RFID tags, which is very flexible in the$\backslash$r sense that each reader can read and process all and only all the data it is authorized to.},
archivePrefix = {arXiv},
arxivId = {9780201398298},
author = {Werner, Mario and Wenger, Erich and Mangard, Stefan},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-31271-2_10},
eprint = {9780201398298},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Werner, Wenger, Mangard - 2016 - Protecting the Control Flow of Embedded Processors against Fault Attacks.pdf:pdf},
isbn = {978-3-642-37287-2},
issn = {03029743},
keywords = {control-flow integrity,countermeasures,fault attacks},
pages = {161--176},
pmid = {4520227},
title = {{Protecting the Control Flow of Embedded Processors against Fault Attacks}},
url = {http://link.springer.com/10.1007/978-3-319-31271-2{\_}10},
volume = {9514},
year = {2016}
}
@inproceedings{Gandolfi2007,
abstract = {Although the possibility of attacking smart-cards by analyzing their electromagnetic power radiation repeatedly appears in research papers, all accessible references evade the essence of reporting conclusive experiments where actual cryptographic algorithms such as des or rsa were successfully attacked.},
address = {Berlin, Heidelberg},
author = {Gandolfi, Karine and Mourtel, Christophe and Olivier, Francis},
booktitle = {Cryptographic Hardware and Embedded Systems --- CHES 2001},
editor = {Ko{\c{c}}, {\c{C}}etin K and Naccache, David and Paar, Christof},
isbn = {978-3-540-44709-2},
pages = {251--261},
publisher = {Springer Berlin Heidelberg},
title = {{Electromagnetic Analysis: Concrete Results}},
year = {2001}
}
@article{Kuznetsov:204783,
abstract = {Systems code is often written in low-level languages like C/C++, which offer many benefits but also delegate memory management to programmers. This invites memory safety bugs that attackers can exploit to divert control flow and compromise the system. Deployed defense mechanisms (e.g., ASLR, DEP) are incomplete, and stronger defense mechanisms (e.g., CFI) often have high overhead and limited guarantees [19, 15, 9]. We introduce code-pointer integrity (CPI), a new design point that guarantees the integrity of all code pointers in a program (e.g., function pointers, saved return addresses) and thereby prevents all control-flow hijack attacks, including return-oriented programming. We also introduce code-pointer separation (CPS), a relaxation of CPI with better performance properties. CPI and CPS offer substantially better security-to-overhead ratios than the state of the art, they are practical (we protect a complete FreeBSD system and over 100 packages like apache and postgresql), effective (prevent all attacks in the RIPE benchmark), and efficient: on SPEC CPU2006, CPS averages 1.2{\%} overhead for C and 1.9{\%} for C/C++, while CPI's overhead is 2.9{\%} for C and 8.4{\%} for C/C++. A prototype implementation of CPI and CPS can be obtained from http://levee.epfl.ch.},
author = {Kuznetsov, Volodymyr and Szekeres, L{\'{a}}szl{\'{o}} and Payer, Mathias and Candea, George and Sekar, R and Song, Dawn},
journal = {Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation},
pages = {147--163},
title = {{Code-Pointer Integrity}},
url = {https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-kuznetsov.pdf},
year = {2014}
}
@book{MangardStefan2007Paa:,
address = {New York},
author = {Mangard, Stefan},
isbn = {0387308571},
keywords = {Smart cards -- Security measures},
publisher = {Springer},
title = {{Power analysis attacks : revealing the secrets of smart cards}},
year = {2007}
}
@article{Nguyen2018,
abstract = {To date, industrial antivirus tools are mostly using signature-based methods to detect malware occurrences. However, sophisticated malware, such as metamorphic or polymorphic virus, can effectively evade those tools by using some advanced obfuscation techniques, including mutation and the dynamically executed contents (DEC) methods, which dynamically produce new executable code in the run-time. Common DEC methods used by malware programs are packing or calling external code. In the research community, the approach of program analysis to detect suspicious behaviors has been emerging recently to handle this problem. Control flow graph (CFG) is a suitable representation to capture common behaviors from various mutated samples of virus. However, the current typical CFG forms generated by state-of-the-art binary analysis tools, such as IDA Pro, do not precisely reflect the behaviors of DEC methods. Moreover, this approach suffers from an extremely heavy cost to conduct and analyze the CFGs from binaries. This drawback causes the method of formal behavior analysis to be virtually not applicable with real-world applications. In this paper, we propose an enhanced form of CFG, known as lazy-binding CFG to reflect the DEC behaviors. Then, with the recent advancement of the deep learning techniques, we present a method of producing image-based representation from the generated CFG. As deep learning is very popular to perform image classification on very large dataset, our proposed technique can be applied for malware detection on real-world computer programs and thus enjoying very high accuracy. We also illustrate our analysis results with some well-known malware samples, including WannaCry, Kasperagent and Sality, one of the most sophisticated polymorphic viruses.},
author = {Nguyen, Minh Hai and Nguyen, Dung Le and Nguyen, Xuan Mao and Quan, Tho Thanh},
doi = {10.1016/j.cose.2018.02.006},
file = {:D$\backslash$:/Downloads/1-s2.0-S0167404818300889-main.pdf:pdf},
issn = {01674048},
journal = {Computers and Security},
keywords = {Binary-based control,Deep learning,Dynamically executed contents,Flow graph,Lazy-binding CFG,Malware,Metamorphic virus,Mutation,Packing techniques,Polymorphic virus},
pages = {128--155},
publisher = {Elsevier Ltd},
title = {{Auto-detection of sophisticated malware using lazy-binding control flow graph and deep learning}},
url = {https://doi.org/10.1016/j.cose.2018.02.006},
volume = {76},
year = {2018}
}
@inproceedings{Chielle2015,
abstract = {{\textcopyright} 1963-2012 IEEE. Software-based techniques offer several advantages to increase the reliability of processor-based systems at very low cost, but they cause performance degradation and an increase of the code size. To meet constraints in performance and memory, we propose SETA, a new control-flow software-only technique that uses assertions to detect errors affecting the program flow. SETA is an independent technique, but it was conceived to work together with previously proposed data-flow techniques that aim at reducing performance and memory overheads. Thus, SETA is combined with such data-flow techniques and submitted to a fault injection campaign. Simulation and neutron induced SEE tests show high fault coverage at performance and memory overheads inferior to the state-of-the-art.},
author = {Chielle, Eduardo and Rodrigues, Gennaro S. and Kastensmidt, Fernanda L. and Cuenca-Asensi, Sergio and Tambara, Lucas A. and Rech, Paolo and Quinn, Heather},
booktitle = {IEEE Transactions on Nuclear Science},
doi = {10.1109/TNS.2015.2484842},
issn = {00189499},
number = {6},
title = {{S-SETA: Selective Software-Only Error-Detection Technique Using Assertions}},
volume = {62},
year = {2015}
}
@article{Yuce2016,
abstract = {Fault attacks are a known serious threat to embedded software security. We propose FAME, a low-cost and flexible approach to defend embedded software against fault attacks. FAME offers a combination of fault detection in hardware and fault response in software. A hardware fault detection unit continuously monitors the system status. When a fault injection is detected, an alarm signal triggers a secure trap mechanism that passes the control to a software trap handler. The trap handler applies a suitable fault response policy, which may include a broad variety of responses such as clearing sensitive data or issuing system-wide alerts. This enables a targeted, fast fault detection as well as an application-dependent, user-defined fault response. FAME requires much lower overhead than traditional countermeasure techniques in software or hardware. We demonstrate a prototype implementation of FAME using a modified LEON3 processor, and we analyze the hardware and software overhead to thwart setup-time violation attacks. The hardware area overhead is 7.4{\%} and 14.2{\%} in the number of LUTs and registers, respectively. The overhead of the software trap handler on top of an AES-128 program is 0.59{\%}--0.71{\%} in footprint and 1.01{\%}--2.35{\%} in performance, depending on the security policy. In contrast, traditional countermeasures that use redundant hardware or software against similar faults have at least double overhead.},
author = {Yuce, Bilgiday and Ghalaty, Nahid F and Deshpande, Chinmay and Patrick, Conor and Nazhandali, Leyla and Schaumont, Patrick},
doi = {10.1145/2948618.2948626},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yuce et al. - 2016 - FAME Fault-attack Aware Microprocessor Extensions for Hardware Fault Detection and Software Fault Response.pdf:pdf},
isbn = {978-1-4503-4769-3},
journal = {Proceedings of the Hardware and Architectural Support for Security and Privacy 2016},
keywords = {Embedded Software Security,Fault-attack Aware Microprocessor Extensions},
pages = {8:1----8:8},
title = {{FAME: Fault-attack Aware Microprocessor Extensions for Hardware Fault Detection and Software Fault Response}},
url = {http://doi.acm.org/10.1145/2948618.2948626},
year = {2016}
}
@inproceedings{Davi2009,
abstract = {Despite the many efforts made in recent years to mitigate runtime attacks such as stack and heap based buffer overflows, these attacks are still a common security concern in today's computing platforms. Attackers have even found new ways to enforce runtime attacks including use of a technique called return-oriented programming. Trusted Computing provides mechanisms to verify the integrity of all executable content in an operating system. But they only provide integrity at load-time and are not able to prevent or detect runtime attacks. To mitigate return-oriented programming attacks, we propose new runtime integrity monitoring techniques that use tracking instrumentation of program binaries based on taint analysis and dynamic tracing. We also describe how these techniques can be employed in a dynamic integrity measurement architecture (DynIMA). In this way we fill the gap between static load-time and dynamic runtime attestation and, in particular, extend trusted computing techniques to effectively defend against return-oriented programming attacks.},
address = {New York, New York, USA},
author = {Davi, Lucas and Sadeghi, Ahmad-Reza and Winandy, Marcel},
booktitle = {Proceedings of the 2009 ACM workshop on Scalable trusted computing - STC '09},
doi = {10.1145/1655108.1655117},
file = {:D$\backslash$:/Downloads/DynIMA-anti-ROP.pdf:pdf},
isbn = {9781605587882},
keywords = {attesta-,integrity monitoring,return-oriented programming},
pages = {49},
publisher = {ACM Press},
title = {{Dynamic integrity measurement and attestation}},
url = {http://portal.acm.org/citation.cfm?doid=1655108.1655117},
year = {2009}
}
@article{Conti2018,
abstract = {Remote attestation is a security technique by which a potentially untrusted device called Prover can evidence its current state to an external trusted party called Verifier. The main goal of a remote attestation protocol is to guarantee the reliability of the evidence, such that the Verifier can verify remotely the trustworthiness of the Prover. In the Internet of Things (IoT) systems, which are increasingly becoming exposed to a broad range of exploitations, the existing remote attestation protocols aim to check the integrity of each individual IoT device by detecting the modified softwares and physical tampering attacks. However, in an interconnected IoT system, in which IoT devices interact autonomously among themselves, a compromised IoT service can influence the genuine operation of other invoked service, without changing the software. In this paper, we show how a compromised service in a distributed IoT service can induce malicious behavior on genuine services, and we highlight the need for distributed services attestation. We propose a protocol for Remote Attestation of Distributed IoT Services (RADIS), which provides a complete evidence about the trustworthiness of distributed IoT services. RADIS relies on a control-flow attestation technique to detect IoT services that perform an unexpected operation due to their interactions with a malicious remote service. Additionally, RADIS traces the interactions between IoT distributed services, allowing the Verifier to check whether the activities follow a legitimate interaction model. We discuss the effectiveness of our protocol in validating the integrity status of a distributed IoT service.},
archivePrefix = {arXiv},
arxivId = {1807.10234},
author = {Conti, Mauro and Dushku, Edlira and Mancini, Luigi V.},
eprint = {1807.10234},
file = {:D$\backslash$:/Downloads/1807.10234.pdf:pdf},
keywords = {-remote attestation,distributed iot services,ser-},
title = {{RADIS: Remote Attestation of Distributed IoT Services}},
url = {http://arxiv.org/abs/1807.10234},
year = {2018}
}
@article{Kommerling1999,
abstract = {We describe techniques for extracting protected software and data from smartcard processors. This includes manual microprobing, laser cutting, fo- cused ion-beam manipulation, glitch attacks, and power analysis. Many of these methods have already been used to compromise widely-fielded conditional- access systems, and current smartcards offer little protection against them. We give examples of low- cost protection concepts thatmake such attacks con- siderably more difficult.},
author = {K{\"{o}}mmerling, Oliver and Kuhn, Markus G},
file = {:D$\backslash$:/Downloads/sc99-tamper.pdf:pdf},
isbn = {1880446340},
journal = {USENIX Workshop on Smartcard Technology},
pages = {9--20},
title = {{Design Principles for Tamper-Resistant Smartcard Processors}},
year = {1999}
}
@article{McCune2008,
abstract = {We present Flicker, an infrastructure for executing security-sensitive code in complete isolation while trusting as few as 250 lines of additional code. Flicker can also provide meaningful, fine-grained attestation of the code executed (as well as its inputs and outputs) to a remote party. Flicker guarantees these properties even if the BIOS, OS and DMA-enabled devices are all malicious. Flicker leverages new commodity processors from AMD and Intel and does not require a new OS or VMM. We demonstrate a full implementation of Flicker on an AMD platform and describe our development environment for simplifying the construction of Flicker-enabled code.},
author = {McCune, Jonathan M and Parno, Bryan J and Perrig, Adrian and Reiter, Michael K and Isozaki, Hiroshi},
doi = {10.1145/1352592.1352625},
file = {:D$\backslash$:/Downloads/EuroSys.pdf:pdf},
isbn = {9781605580135},
issn = {01635980},
journal = {Proceedings of the 3rd ACM SIGOPS/EuroSys European Conference on Computer Systems 2008 - Eurosys '08},
keywords = {late launch,secure execution,trusted computing},
pages = {315},
title = {{Flicker: an execution infrastructure for tcb minimization}},
url = {http://portal.acm.org/citation.cfm?doid=1352592.1352625},
year = {2008}
}
@article{Fletcher2012,
abstract = {This paper considers encrypted computation where the user specifies encrypted inputs to an untrusted program, and the server computes on those encrypted inputs. To this end we propose a secure processor architecture, called Ascend, that guarantees privacy of data when arbitrary programs use the data running in a cloud-like environment (e.g., an untrusted server running an untrusted software stack). The key idea to guarantee privacy is obfuscated instruction execution; Ascend does not disclose what instruction is being run at any given time, be it an arithmetic instruction or a memory instruction. Periodic accesses to external instruction and data memory are performed through an Oblivious RAM (ORAM) interface to prevent leakage through memory access patterns. We evaluate the processor architecture on SPEC benchmarks running on encrypted data and quantify overheads.},
author = {Fletcher, Christopher W. and van Dijk, Marten and Devadas, Srinivas},
doi = {10.1145/2382536.2382540},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Fletcher, Dijk, Devadas - 2012 - A secure processor architecture for encrypted computation on untrusted programs.pdf:pdf},
isbn = {9781450316620},
keywords = {encrypted computation,secure processors},
pages = {3},
title = {{A secure processor architecture for encrypted computation on untrusted programs}},
year = {2012}
}
@article{Arora2006,
author = {Arora, Divya and Ravi, Srivaths and Raghunathan, Anand and Jha, Niraj K},
doi = {10.1109/TVLSI.2006.887799},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Arora et al. - 2006 - Hardware-Assisted Run-Time Monitoring for Secure Program Execution on Embedded Processors.pdf:pdf},
issn = {1063-8210},
journal = {IEEE Transactions on Very Large Scale Integration (VLSI) Systems},
month = {dec},
number = {12},
pages = {1295--1308},
title = {{Hardware-Assisted Run-Time Monitoring for Secure Program Execution on Embedded Processors}},
url = {http://ieeexplore.ieee.org/document/4052340/},
volume = {14},
year = {2006}
}
@article{Srivastava1994,
abstract = {ATOM (Analysis Tools with OM) is a single framework for building a wide range of customized program analysis tools. It provides the common infrastructure present in all code-instrumenting tools; this is the difficult and time-consuming part. The user simply defines the tool-specific details in instrumentation and analysis routines. Building a basic block counting tool like Pixie with ATOM requires only a page of code.ATOM, using OM link-time technology, organizes the final executable such that the application program and user's analysis routines run in the same address space. Information is directly passed from the application program to the analysis routines through simple procedure calls instead of inter-process communication or files on disk. ATOM takes care that analysis routines do not interfere with the program's execution, and precise information about the program is presented to the analysis routines at all times. ATOM uses no simulation or interpretation.ATOM has been implemented on the Alpha AXP under OSF/1. It is efficient and has been used to build a diverse set of tools for basic block counting, profiling, dynamic memory recording, instruction and data cache simulation, pipeline simulation, evaluating branch prediction, and instruction scheduling.$\backslash$n$\backslash$n},
author = {Srivastava, Amitabh and Eustace, Alan},
doi = {10.1145/773473.178260},
file = {:D$\backslash$:/Downloads/srivastava94atom.pdf:pdf},
isbn = {0-89791-662-X},
issn = {03621340},
journal = {WRL Research Report (ACM SIGPLAN Notices)},
number = {6},
pages = {196--205},
title = {{ATOM: a system for building customized program analysis tools}},
url = {http://dl.acm.org/citation.cfm?id=773473.178260},
volume = {29},
year = {1994}
}
@article{USENIXAssociation.2003,
author = {{USENIX Association.}, Andrei and Zaddach, Jonas and Francillon, Aur{\'{e}}lien and Balzarotti, Davide},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/USENIX Association. et al. - 2003 - Proceedings of the seventeenth Large Installation Systems Administration Conference (LISA XVII) Oct.pdf:pdf},
isbn = {9781931971157},
pages = {256},
title = {{Proceedings of the seventeenth Large Installation Systems Administration Conference (LISA XVII) : October 26-31, 2003 San Diego, CA, USA}},
year = {2003}
}
@inproceedings{Street,
abstract = {There has been considerable recent interest in the level of tamper resistance that can be provided by low cost devices such as smart-cards. It is known that such devices can be reverse engineered using chip testing equipment, but a state of the art semiconductor laboratory costs millions of dollars. In this paper, we describe a number of attacks that can be mounted by opponents with much shallower pockets.},
address = {Berlin, Heidelberg},
author = {Anderson, Ross and Kuhn, Markus},
booktitle = {Security Protocols},
editor = {Christianson, Bruce and Crispo, Bruno and Lomas, Mark and Roe, Michael},
isbn = {978-3-540-69688-9},
pages = {125--136},
publisher = {Springer Berlin Heidelberg},
title = {{Low cost attacks on tamper resistant devices}},
year = {1998}
}
@article{DeClercq2017b,
abstract = {Software components are frequently used in cyber-physical systems (CPSes) to control a physical mechanism, such as a valve or brakes on a car. These systems are extremely sensitive to software vulnerabilities, as their exploitation could lead to injury, damage to equipment, or environmental catastrophe. This paper proposes a hardware-based security architecture called SOFIA, which protects software running on microprocessors used in CPSes. SOFIA provides mechanisms to protect software integrity and control flow integrity. This allows the processor to defend against a large number of attacks, including code injection, code reuse, and fault-based attacks on the program counter. In addition, the architecture also defends against software copyright infringement and reverse engineering. All protection mechanisms are enforced in hardware using cryptographic techniques. We are the first to propose a mechanism to enforce control flow integrity at the finest possible granularity using cryptographic techniques. A SOFIA core has been created by implementing the proposed architectural features on a LEON3 microprocessor. The SOFIA core requires that its software conforms to a strict format. To this end, we additionally designed and implemented a software toolchain to compile source code that adheres to the formatting rules. Several benchmarks were compiled with the SOFIA toolchain, and were executed on a SOFIA core running on an FPGA, showing an average total execution time overhead of 106{\%} compared to an unmodified LEON3 core. Our hardware evaluation shows a clock speed reduction of 23.2{\%}.},
author = {de Clercq, Ruan and G{\"{o}}tzfried, Johannes and {\"{U}}bler, David and Maene, Pieter and Verbauwhede, Ingrid},
doi = {10.1016/j.cose.2017.03.013},
file = {:D$\backslash$:/Downloads/2017 - SOFIA Software and control flow integrity architecture - de Clercq et al.pdf:pdf},
isbn = {9783981537079},
issn = {01674048},
journal = {Computers and Security},
keywords = {Computer architecture,Control flow integrity,Hardware,Instruction set randomization,Security},
number = {2},
pages = {16--35},
publisher = {EDAA},
title = {{SOFIA: Software and control flow integrity architecture}},
volume = {68},
year = {2017}
}
@article{Hagberg2008,
abstract = {NetworkX is a Python language package for exploration and analysis of networks and network algorithms. The core package provides data structures for representing many types of networks, or graphs, including simple graphs, directed graphs, and graphs with parallel edges and self-loops. The nodes in NetworkX graphs can be any (hashable) Python object and edges can contain arbitrary data; this flexibility makes NetworkX ideal for representing networks found in many different scientific fields. In addition to the basic data structures many graph algorithms are implemented for calculating network properties and structure measures: shortest paths, betweenness centrality, clustering, and degree distribution and many more. NetworkX can read and write various graph formats for easy exchange with existing data, and provides generators for many classic graphs and popular graph models, such as the Erdos-Renyi, Small World, and Barabasi-Albert models. The ease-of-use and flexibility of the Python programming language together with connection to the SciPy tools make NetworkX a powerful tool for scientific computations. We discuss some of our recent work studying synchronization of coupled oscillators to demonstrate how NetworkX enables research in the field of computational networks.},
author = {Hagberg, A A and Schult, D A and Swart, P J},
file = {:D$\backslash$:/Downloads/full{\_}text.pdf:pdf},
isbn = {3333333333},
journal = {7th Python in Science Conference (SciPy 2008)},
number = {SciPy},
pages = {11--15},
title = {{Exploring network structure, dynamics, and function using NetworkX}},
year = {2008}
}
@incollection{Fang2012,
abstract = {Mobile phone use – and mobile phone piracy – have increased dramatically during the last decade. Because of the profits that can be made, more than four hundred pirated brands of mobile phones are available in China. These pirated phones, referred to as “Shanzhai phones,” are often used by criminals because they are inexpensive and easy to obtain. However, the variety of pirated phones and the absence of documentation hinder the forensic analysis of these phones. This paper provides key details about the storage of the phonebook and call records in popular MediaTek Shanzhai mobile phones. This information can help investigators retrieve deleted call records and assist them in reconstructing the sequence of user activities.},
author = {Fang, Junbin and Jiang, Zoe and Chow, Kam-pui and Yiu, Siu-ming and Hui, Lucas and Zhou, Gang and He, Mengfei and Tang, Yanbin},
doi = {10.1007/978-3-642-33962-2_9},
file = {:D$\backslash$:/Downloads/Fang2012{\_}Chapter{\_}ForensicAnalysisOfPiratedChine.pdf:pdf},
isbn = {978-3-642-33962-2},
keywords = {chinese shanzhai phones,deleted data,forensic analysis,phonebook},
pages = {129--142},
title = {{Forensic Analysis of Pirated Chinese Shanzhai Mobile Phones}},
url = {http://link.springer.com/10.1007/978-3-642-33962-2{\_}9},
year = {2012}
}
@article{Chen2017,
author = {Chen, Zhi and Shen, Junjie and Nicolau, Alex and Veidenbaum, Alex and Ghalaty, Nahid Farhady and Cammarota, Rosario},
doi = {10.1109/FDTC.2017.10},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chen et al. - 2017 - CAMFAS A Compiler Approach to Mitigate Fault Attacks via Enhanced SIMDization.pdf:pdf},
isbn = {9781538629482},
journal = {Proceedings - 2017 Workshop on Fault Diagnosis and Tolerance in Cryptography, FDTC 2017},
pages = {57--64},
title = {{CAMFAS: A Compiler Approach to Mitigate Fault Attacks via Enhanced SIMDization}},
volume = {2017-Janua},
year = {2017}
}
@article{Dessouky2018,
author = {Dessouky, Ghada and Abera, Tigist and Ibrahim, Ahmad and Sadeghi, Ahmad-Reza},
doi = {10.1145/3240765.3240821},
file = {:D$\backslash$:/Downloads/08587757.pdf:pdf},
isbn = {9781450359504},
journal = {2018 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)},
pages = {1--8},
publisher = {ACM},
title = {{LiteHAX}},
year = {2018}
}
@article{Aumasson2013,
abstract = {We present the hash function BLAKE2, an improved version of the SHA-3 finalist BLAKE optimized for speed in software. Target applications include cloud storage, intrusion detection, or version control systems. BLAKE2 comes in two main flavors: BLAKE2b is optimized for 64-bit platforms, and BLAKE2s for smaller architectures. On 64-bit platforms, BLAKE2 is often faster than MD5, yet provides security similar to that of SHA-3: up to 256-bit collision resistance, immunity to length extension, indifferentiability from a random oracle, etc. We specify parallel versions BLAKE2bp and BLAKE2sp that are up to 4 and 8 times faster, by taking advantage of SIMD and/or multiple cores. BLAKE2 reduces the RAM requirements of BLAKE down to 168 bytes, making it smaller than any of the five SHA-3 finalists, and 32{\%} smaller than BLAKE. Finally, BLAKE2 provides a comprehensive support for tree-hashing as well as keyed hashing (be it in sequential or tree mode). {\textcopyright} 2013 Springer-Verlag.},
author = {Aumasson, Jean Philippe and Neves, Samuel and Wilcox-O'Hearn, Zooko and Winnerlein, Christian},
doi = {10.1007/978-3-642-38980-1_8},
file = {:D$\backslash$:/Downloads/Aumasson2013{\_}Chapter{\_}BLAKE2SimplerSmallerFastAsMD5.pdf:pdf},
isbn = {9783642389795},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {119--135},
title = {{BLAKE2: Simpler, smaller, fast as MD5}},
volume = {7954 LNCS},
year = {2013}
}
@incollection{Gandolfi2007Old,
abstract = {Although the possibility of attacking smart-cards by analyzing their electromagnetic power radiation repeatedly appears in research papers, all accessible references evade the essence of reporting conclusive experiments where actual cryptographic algorithms such as des or rsa were successfully attacked. This work describes electromagnetic experiments conducted on three different cmos chips, featuring different hardware protections and executing a des, an alleged COMP128 and an RSA. In all cases the complete key material was successfully retrieved.},
author = {Gandolfi, Karine and Mourtel, Christophe and Olivier, Francis},
doi = {10.1007/3-540-44709-1_21},
file = {:D$\backslash$:/Downloads/Gandolfi2001{\_}Chapter{\_}ElectromagneticAnalysisConcret.pdf:pdf},
keywords = {dema,dpa,electromagnetic analysis,sema,side channel leakage,smart cards,spa},
pages = {251--261},
title = {{Electromagnetic Analysis: Concrete Results}},
url = {http://link.springer.com/10.1007/3-540-44709-1{\_}21},
year = {2001}
}
@article{Lee2016a,
author = {Lee, Jinyong and Heo, Ingoo and Lee, Yongje and Paek, Yunheung},
doi = {10.1145/2907611},
file = {:D$\backslash$:/Downloads/a8-lee.pdf:pdf},
issn = {10844309},
journal = {ACM Transactions on Design Automation of Electronic Systems},
number = {1},
pages = {1--29},
title = {{Efficient Security Monitoring with the Core Debug Interface in an Embedded Processor}},
volume = {22},
year = {2016}
}
@inproceedings{Sharma2012,
author = {Reis, G.A. and Chang, J. and Vachharajani, N. and Rangan, R. and August, D.I.},
booktitle = {International Symposium on Code Generation and Optimization},
doi = {10.1109/CGO.2005.34},
file = {:D$\backslash$:/Downloads/01402092.pdf:pdf},
isbn = {0-7695-2298-X},
pages = {243--254},
publisher = {IEEE},
title = {{SWIFT: Software Implemented Fault Tolerance}},
url = {http://ieeexplore.ieee.org/document/1402092/},
year = {2012}
}
@article{Koutsofios1991,
author = {Koutsofios, E and North, S},
file = {:D$\backslash$:/Downloads/dotguide.pdf:pdf},
number = {910904-59113-08TM},
pages = {1--40},
title = {{Drawing graphs with {\{}$\backslash$em dot{\}}}},
year = {1991}
}
@inproceedings{Carlini2015,
address = {Washington, D.C.},
author = {Carlini, Nicholas and Barresi, Antonio and Payer, Mathias and Wagner, David and Gross, Thomas R},
booktitle = {24th {\{}USENIX{\}} Security Symposium ({\{}USENIX{\}} Security 15)},
isbn = {978-1-931971-232},
month = {aug},
pages = {161--176},
publisher = {{\{}USENIX{\}} Association},
title = {{Control-Flow Bending: On the Effectiveness of Control-Flow Integrity}},
url = {https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/carlini},
year = {2015}
}
@article{Chen2007,
abstract = {[1] Y. Chen, R. Venkatesan, M. Cary, R. Pang, S. Sinha, and M. H. Jakubowski, “Oblivious Hashing : A Stealthy Software Integrity Verification Primitive,” in 5th International Workshop on Information Hiding, 2002, pp. 400–414.},
author = {Chen, Yuqun and Sinha, Saurabh and Venkatesan, Ramarathnam and Pang, Ruoming and Jakubowski, Mariusz H. and Cary, Matthew},
doi = {10.1007/3-540-36415-3_26},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chen et al. - 2007 - Oblivious Hashing A Stealthy Software Integrity Verification Primitive.pdf:pdf},
pages = {400--414},
title = {{Oblivious Hashing: A Stealthy Software Integrity Verification Primitive}},
year = {2007}
}
@article{Feng2003,
abstract = {{\textcopyright} 2003 IEEE. The call stack of a program execution can be a very good information source for intrusion detection. There is no prior work on dynamically extracting information from the call stack and effectively using it to detect exploits. In this paper we propose a new method to do anomaly detection using call stack information. The basic idea is to extract return addresses from the call stack, and generate an abstract execution path between two program execution points. Experiments show that our method can detect some attacks that cannot be detected by other approaches, while its convergence and false positive performance is comparable to or better than the other approaches. We compare our method with other approaches by analyzing their underlying principles and thus achieve a better characterization of their performance, in particular on what and why attacks will be missed by the various approaches.},
author = {Feng, H. H. and Kolesnikov, O. M. and Fogla, P. and Lee, W. and Gong, Weibo},
doi = {10.1109/SECPRI.2003.1199328},
file = {:D$\backslash$:/Downloads/01199328.pdf:pdf},
isbn = {0769519407},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {62--75},
publisher = {IEEE},
title = {{Anomaly detection using call stack information}},
volume = {2003-Janua},
year = {2003}
}
@inproceedings{Anderson1996,
address = {Berkeley, CA, USA},
author = {Anderson, Ross and Kuhn, Markus},
booktitle = {Proceedings of the 2Nd Conference on Proceedings of the Second USENIX Workshop on Electronic Commerce - Volume 2},
pages = {1},
publisher = {USENIX Association},
series = {WOEC'96},
title = {{Tamper Resistance: A Cautionary Note}},
url = {http://dl.acm.org/citation.cfm?id=1267167.1267168},
year = {1996}
}
@article{Yang2013,
abstract = {This paper proposes a generic high-performance and low-time-overhead software control flow checking solution, graph-tree-based control flow checking (GTCFC) for space-borne commercial-off-the-shelf (COTS) processors. A graph tree data structure with a topology similar to common trees is introduced to transform the control flow graphs of target programs. This together with design of IDs and signatures of its vertices and edges allows for an easy check of legality of actual branching during target program execution. As a result, the algorithm not only is capable of detecting all single and multiple branching errors with low latency and time overheads along with a linear-complexity space overhead, but also remains generic among arbitrary instruction sets and independent of any specific hardware. Tests of the algorithm using a COTS-processor-based on-board computer (OBC) of in-service ZDPS-1A pico-satellite products show that GTCFC can detect over 90{\%} of the randomly injected and all-pattern-covering branching errors for different types of target programs, with performance and overheads consistent with the theoretical analysis; and beats well-established preeminent control flow checking algorithms in these dimensions. Furthermore, it is validated that GTCGC not only can be accommodated in pico-satellites conveniently with still sufficient system margins left, but also has the ability to minimize the risk of control flow errors being undetected in their space missions. Therefore, due to its effectiveness, efficiency, and compatibility, the GTCFC solution is ready for applications on COTS processors on pico-satellites in their real space missions. {\textcopyright} 2013 Production and hosting by Elsevier Ltd. on behalf of CSAA and BUAA.},
annote = {Good descriptions/lists of cfg techniques},
author = {Yang, Mu and Wang, Hao and Zheng, Yangming and Jin, Zhonghe},
doi = {10.1016/j.cja.2013.02.019},
file = {:D$\backslash$:/Downloads/1-s2.0-S1000936113000319-main.pdf:pdf},
issn = {10009361},
journal = {Chinese Journal of Aeronautics},
keywords = {Branching error,Commercial-off-the-shelf (COTS),Control flow checking,Error injection,Graph tree,On-board computer,Pico-satellite},
number = {2},
pages = {413--422},
publisher = {Chinese Society of Aeronautics and Astronautics},
title = {{Graph-tree-based software control flow checking for COTS processors on pico-satellites}},
url = {http://dx.doi.org/10.1016/j.cja.2013.02.019},
volume = {26},
year = {2013}
}
@article{Yuce2017,
author = {Yuce, Bilgiday and Hsiao, Michael S and Nazhandali, Leyla and Patterson, Cameron D and Yao, Danfeng},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yuce et al. - 2017 - Fault Attacks on Embedded Software New Directions in Modeling, Design, and Mitigation.pdf:pdf},
keywords = {bilgiday yuce,copyright 2018,countermeasures,embedded systems,fault attacks,fault mitigation,fault models,fault simulation},
title = {{Fault Attacks on Embedded Software: New Directions in Modeling, Design, and Mitigation}},
url = {https://vtechworks.lib.vt.edu/bitstream/handle/10919/81824/Yuce{\_}B{\_}D{\_}2018.pdf?sequence=1{\&}isAllowed=y},
year = {2017}
}
@article{Castro2006,
abstract = {Title from The ACM Digital Library.},
annote = {Phoenix compiler framework to do static analysis - 29. Now defunct. Look at LLVN instead.

Traversin static single-assignment representation - 10

Anderson point-to analysis set of objects each pointer can point to - 9 (similar technique to 21)

12 Has better precision... maybe???

HIR = high-level intermediate representation

Benchmark containing control-data attacks - 40 (5 and 34 prevent all attacks in this benchmark)

27, 5 Control flow graph stuff, also 6. 14 points out flaws in CFG

Dynamic taint analysis},
author = {Castro, Miguel and Costa, Manuel and Harris, Tim},
file = {:D$\backslash$:/Downloads/p147-castro.pdf:pdf;:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Castro, Costa, Harris - 2006 - Securing software by enforcing data-flow integrity.pdf:pdf},
journal = {OSDI '06: 7th USENIX Symposium on Operating Systems Design and Implementation},
pages = {147 -- 160},
title = {{Securing software by enforcing data-flow integrity}},
url = {https://dl.acm.org/citation.cfm?id=1298470},
year = {2006}
}
@book{SeacordRobertC2013SciC,
address = {Upper Saddle River, NJ},
annote = {Chapter 3 - Pointer Subterfuge},
author = {Seacord, Robert C},
edition = {2nd ed.},
isbn = {9780132981989},
keywords = {Computer security; C (Computer program language);},
publisher = {Addison-Wesley},
series = {SEI series in software engineering},
title = {{Secure coding in C and C++}},
year = {2013}
}
@article{Breier2016,
author = {Breier, Jakub},
doi = {10.1109/ARES.2016.4},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Breier - 2016 - On analyzing program behavior under fault injection attacks.pdf:pdf},
isbn = {9781509009909},
journal = {Proceedings - 2016 11th International Conference on Availability, Reliability and Security, ARES 2016},
keywords = {Code analysis,Fault attacks,Fault simulator,Instruction set simulator},
pages = {474--479},
publisher = {IEEE},
title = {{On analyzing program behavior under fault injection attacks}},
year = {2016}
}
@article{Hada2007,
abstract = {In this paper, we investigate the gap between auxiliary-input zero-knowledge (AIZK) and blackbox-simulation zero-knowledge (BSZK). It is an interestingop en problem whether or not there exists a protocol which achieves AIZK, but not BSZK. We show that the existence of such a protocol is closely related to the existence of secure code obfuscators. A code obfuscator is used to convert a code into an equivalent one that is difficult to reverse-engineer. This paper provides security definitions of code obfuscation. By their definitions, it is easy to see that the existence of the gap implies the existence of a cheating verifier such that it is impossible to obfuscate any code of it. Intuitively, this means that it is possible to reverse-engineer any code of such a cheating verifier. Furthermore, we consider the actual behavior of such a cheating verifier. In order to do so, we focus on two special cases in which the gap exists: (1) there exists a constant round public-coin AIZK interactive argument for a language outside of BPP. (2) there exists a 3-round secret-coinAIZK interactive argument for a language outside of BPP. In the former case, we show that it is impossible to securely obfuscate a code of a cheating verifier behaving as a pseudorandom function. A similar result is shown also in the latter case. Our results imply that any construction of constant round public-coin or 3-round secret-coin AIZK arguments for non-trivial languages essentially requires a computational assumption with a reverse-engineering property.},
author = {Hada, Satoshi},
doi = {10.1007/3-540-44448-3_34},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hada - 2007 - Zero-Knowledge and Code Obfuscation.pdf:pdf},
keywords = {code obfuscation,interactive,interactive argument,proof,reverse-engineering,zero-knowledge},
pages = {443--457},
title = {{Zero-Knowledge and Code Obfuscation}},
year = {2007}
}
@article{Song2017,
abstract = {—The operation system kernel is the foundation of the whole system and is often the de facto trusted computing base for many higher level security mechanisms. Unfortunately, kernel vulnerabilities are not rare and are continuously being introduced with new kernel features. Once the kernel is compromised, attack-ers can bypass any access control checks, escalate their privileges, and hide the evidence of attacks. Many protection mechanisms have been proposed and deployed to prevent kernel exploits. However, a majority of these techniques only focus on preventing control-flow hijacking attacks; techniques that can mitigate non-control-data attacks either only apply to drivers/modules or im-pose too much overhead. The goal of our research is to develop a principled defense mechanism against memory-corruption-based privilege escalation attacks. Toward this end, we leverage data-flow integrity to enforce security invariants of the kernel access control system. In order for our protection mechanism to be practical, we develop two new techniques: one for automatically inferring data that are critical to the access control system without manual annotation, and the other for efficient DFI enforcement over the inference results. We have implemented a prototype of our technology for the ARM64 Linux kernel on an Android device. The evaluation results of our prototype implementation show that our technology can mitigate a majority of privilege escalation attacks, while imposing a moderate amount of performance overhead.},
author = {Song, Chengyu and Lee, Byoungyoung and Lu, Kangjie and Harris, William and Kim, Taesoo and Lee, Wenke},
doi = {10.14722/ndss.2016.23218},
file = {:D$\backslash$:/Downloads/kenali.pdf:pdf},
isbn = {189156241X},
number = {February},
pages = {21--24},
title = {{Enforcing Kernel Security Invariants with Data Flow Integrity}},
year = {2017}
}
@article{Venkatasubramanian2003,
abstract = {A control flow fault occurs when a processor fetches and executes an incorrect next instruction. Executable assertions, i.e., special instructions that check some invariant properties of a program, provide a powerful and low-cost method for on-line detection of hardware-induced control flow faults. We propose a technique called ACFC (Assertions for Control Flow Checking) that assigns an execution parity to a basic block, and uses the parity bit to detect faults. Using a graph model of a program, we classify control flow faults into skip, re-execute and multi-path faults. We derive some necessary conditions for these faults to manifest themselves as execution parity errors. To force a control flow fault to excite a parity error, the target program is instrumented with additional instructions. Special assertions are inserted to detect such parity errors. We have a developed a preprocessor that takes a C program as input and inserts ACFC assertions automatically. We have implemented a software-based fault injection tool SFIG which takes advantage of the GNU debugger. Fault injection experiments show that ACFC incurs less performance overhead (around 47{\%}) and memory overhead (around 30{\%}) than previous techniques, with no significant loss in fault coverage.},
author = {Venkatasubramanian, Rajesh and Hayes, J. P. and Murray, B. T.},
doi = {10.1109/OLT.2003.1214380},
file = {:D$\backslash$:/Downloads/01214380.pdf:pdf},
isbn = {0769519687},
journal = {Proceedings - 9th IEEE International On-Line Testing Symposium, IOLTS 2003},
keywords = {Automotive engineering,Computer architecture,Costs,Fault detection,Instruments,Laboratories,Performance loss,Registers,Rivers,Testing},
pages = {137--143},
title = {{Low-cost on-line fault detection using control flow assertions}},
year = {2003}
}
@article{Collberg2002,
abstract = {We identify three types of attack on the intellectual property contained in software and three corresponding technical defenses. A defense against reverse engineering is obfuscation, a process that renders software unintelligible but still functional. A defense against software piracy is watermarking, a process that makes it possible to determine the origin of software. A defense against tampering is tamper-proofing, so that unauthorized modifications to software (for example, to remove a watermark) will result in nonfunctional code. We briefly survey the available technology for each type of defense.},
annote = {4 Tamper-Proofing is a good section},
author = {Collberg, Christian S. and Thomborson, Clark},
doi = {10.1109/TSE.2002.1027797},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Collberg, Thomborson - 2002 - Watermarking, tamper-proofing, and obfuscation - Tools for software protection.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Intellectual property protection,Obfuscation,Tamper-proofing,Watermarking},
number = {8},
pages = {735--746},
publisher = {IEEE},
title = {{Watermarking, tamper-proofing, and obfuscation - Tools for software protection}},
volume = {28},
year = {2002}
}
@article{Asokan2018a,
abstract = {Secure firmware update is an important stage in the IoT device life-cycle. Prior techniques, designed for other computational settings, are not readily suitable for IoT devices, since they do not consider idiosyncrasies of a realistic large-scale IoT deployment. This motivates our design of ASSURED, a secure and scalable update framework for IoT. ASSURED includes all stakeholders in a typical IoT update ecosystem, while providing end-to-end security between manufacturers and devices. To demonstrate its feasibility and practicality, ASSURED is instantiated and experimentally evaluated on two commodity hardware platforms. Results show that ASSURED is considerably faster than current update mechanisms in realistic settings.},
author = {Asokan, N. and Nyman, Thomas and Rattanavipanon, Norrathep and Sadeghi, Ahmad Reza and Tsudik, Gene},
doi = {10.1109/TCAD.2018.2858422},
file = {:D$\backslash$:/Downloads/08493602.pdf:pdf},
issn = {02780070},
journal = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
keywords = {Computer security,Internet of Things (IoT),embedded software,embedded systems},
number = {11},
pages = {2290--2300},
publisher = {IEEE},
title = {{ASSURED: Architecture for secure software update of realistic embedded devices}},
volume = {37},
year = {2018}
}
@article{Gora2010,
abstract = {Software intellectual property (SWIP) is a critical component of increasingly complex field programmable gate arrays (FPGA)-based system-on-chip (SOC) designs. As a result, developers want to ensure that their Software Intellectual Property (SWIP) is protected from being exposed to or tampered with by unauthorized parties. By restricting the execution of SWIP to a single trusted FPGA platform, SWIP binding addresses developers' concerns about maintaining control of their intellectual property and the market position it affords. This work proposes a novel design flow for SWIP binding on a commodity FPGA platform lacking specialized hardcore security facilities. We accomplish this by leveraging the qualities of a Physical Unclonable Function (PUF) and a tight integration of hardware and software security features. A prototype implementation demonstrates our design flow's ability to successfully protect software by encryption using a 128 bit FPGA-unique key extracted from a PUF. Based on this proof of concept, a solution to perform secure remote software updates, a common challenge in embedded systems, is proposed to showcase the practicality and flexibility of the design flow.},
author = {Gora, Michael A. and Maiti, Abhranil and Schaumont, Patrick},
doi = {10.1109/TII.2010.2068303},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Gora, Maiti, Schaumont - 2010 - A flexible design flow for software IP binding in FPGA.pdf:pdf},
isbn = {9781424441105},
issn = {15513203},
journal = {IEEE Transactions on Industrial Informatics},
keywords = {Design flow,field programmable gate arrays (FPGA),firmware,intellectual property,physical unclonable function,secure embedded systems,security,software binding},
number = {4},
pages = {719--728},
pmid = {14637044},
publisher = {IEEE},
title = {{A flexible design flow for software IP binding in FPGA}},
volume = {6},
year = {2010}
}
@inproceedings{Shoshitaishvili2016,
abstract = {Finding and exploiting vulnerabilities in binary code is a challenging task. The lack of high-level, semantically rich information about data structures and control constructs makes the analysis of program properties harder to scale. However, the importance of binary analysis is on the rise. In many situations binary analysis is the only possible way to prove (or disprove) properties about the code that is actually executed. In this paper, we present a binary analysis framework that implements a number of analysis techniques that have been proposed in the past. We present a systematized implementation of these techniques, which allows other researchers to compose them and develop new approaches. In addition, the implementation of these techniques in a unifying framework allows for the direct comparison of these approaches and the identification of their advantages and disadvantages. The evaluation included in this paper is performed using a recent dataset created by DARPA for evaluating the effectiveness of binary vulnerability analysis techniques. Our framework has been open-sourced and is available to the security community.},
author = {Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and Stephens, Nick and Polino, Mario and Dutcher, Andrew and Grosen, John and Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
booktitle = {2016 IEEE Symposium on Security and Privacy (SP)},
doi = {10.1109/SP.2016.17},
file = {:D$\backslash$:/Downloads/2016{\_}SP{\_}angrSoK.pdf:pdf},
isbn = {978-1-5090-0824-7},
month = {may},
pages = {138--157},
publisher = {IEEE},
title = {{SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis}},
url = {http://ieeexplore.ieee.org/document/7546500/},
year = {2016}
}
@article{Moro2014,
abstract = {Fault attacks against embedded circuits enabled to define many new attack paths against secure circuits. Every attack path relies on a specific fault model which defines the type of faults that the attacker can perform. On embedded processors, a fault model consisting in an assembly instruction skip can be very useful for an attacker and has been obtained by using several fault injection means. To avoid this threat, some countermeasure schemes which rely on temporal redundancy have been proposed. Nevertheless, double fault injection in a long enough time interval is practical and can bypass those countermeasure schemes. Some fine-grained countermeasure schemes have also been proposed for specific instructions. However, to the best of our knowledge, no approach that enables to secure a generic assembly program in order to make it fault-tolerant to instruction skip attacks has been formally proven yet. In this paper, we provide a fault-tolerant replacement sequence for almost all the instructions of the Thumb-2 instruction set and provide a formal verification for this fault tolerance. This simple transformation enables to add a reasonably good security level to an embedded program and makes practical fault injection attacks much harder to achieve.},
annote = {Interesting and simple idea, but seems to rely on lots of code duplication (100{\%} - 200{\%} execution / program size overhead)},
archivePrefix = {arXiv},
arxivId = {1402.6461},
author = {Moro, N. and Heydemann, K. and Encrenaz, E. and Robisson, B.},
doi = {10.1007/s13389-014-0077-7},
eprint = {1402.6461},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Moro et al. - 2014 - Formal verification of a software countermeasure against instruction skip attacks.pdf:pdf},
isbn = {1338901400},
issn = {21908516},
journal = {Journal of Cryptographic Engineering},
keywords = {Countermeasure,Fault attack,Formal verification,Instruction skip,Microcontroller},
number = {3},
pages = {145--156},
title = {{Formal verification of a software countermeasure against instruction skip attacks}},
volume = {4},
year = {2014}
}
@inproceedings{Skorobogatov2007,
abstract = {We describe a new class of attacks on secure microcontrollers and smartcards. Illumination of a target transistor causes it to conduct, thereby inducing a transient fault. Such attacks are practical; they do not even require expensive laser equipment. We have carried them out using a flashgun bought second-hand from a camera store for {\$}30 and with an {\$}8 laser pointer. As an illustration of the power of this attack, we developed techniques to set or reset any individual bit of SRAM in a microcontroller. Unless suitable countermeasures are taken, optical probing may also be used to induce errors in cryptographic computations or protocols, and to disrupt the processor's control flow. It thus provides a powerful extension of existing glitching and fault analysis techniques. This vulnerability may pose a big problem for the industry, similar to those resulting from probing attacks in the mid-1990s and power analysis attacks in the late 1990s.},
address = {Berlin, Heidelberg},
author = {Skorobogatov, Sergei P and Anderson, Ross J},
booktitle = {Cryptographic Hardware and Embedded Systems - CHES 2002},
editor = {Kaliski, Burton S and Ko{\c{c}}, {\c{c}}etin K and Paar, Christof},
isbn = {978-3-540-36400-9},
pages = {2--12},
publisher = {Springer Berlin Heidelberg},
title = {{Optical Fault Induction Attacks}},
year = {2003}
}
@incollection{Skorobogatov2007old,
abstract = {We describe a new class of attacks on secure microcontrollers and smartcards. Illumination of a target transistor causes it to conduct, thereby inducing a transient fault. Such attacks are practical; they do not even require expensive laser equipment. We have carried them out using a flashgun bought second-hand from a camera store for {\$}30 and with an {\$}8 laser pointer. As an illustration of the power of this attack, we developed techniques to set or reset any individual bit of SRAM in a microcontroller. Unless suitable countermeasures are taken, optical probing may also be used to induce errors in cryptographic computations or protocols, and to disrupt the processor's control flow. It thus provides a powerful extension of existing glitching and fault analysis techniques. This vulnerability may pose a big problem for the industry, similar to those resulting from probing attacks in the mid-1990s and power analysis attacks in the late 1990s. We have therefore developed a technology to block these attacks.We use self-timed dual-rail circuit design techniques whereby a logical 1 or 0 is not encoded by a high or low voltage on a single line, but by (HL) or (LH) on a pair of lines. The combination (HH) signals an alarm, which will typically reset the processor. Circuits can be designed so that single- transistor failures do not lead to security failure. This technology may also make power analysis attacks very much harder too.},
author = {Skorobogatov, Sergei P. and Anderson, Ross J.},
doi = {10.1007/3-540-36400-5_2},
file = {:D$\backslash$:/Downloads/Skorobogatov-Anderson2003{\_}Chapter{\_}OpticalFaultInductionAttacks.pdf:pdf},
isbn = {978-3-540-36400-9},
pages = {2--12},
title = {{Optical Fault Induction Attacks}},
url = {http://link.springer.com/10.1007/3-540-36400-5{\_}2},
year = {2003}
}
@inproceedings{Kelly2017,
abstract = {Abstract—Effective software defences against errors created by fault attacks need to anticipate the probable error response of the target micro-controller. The range of errors and their probability of occurrence is referred to as the Fault Model. Software defences are necessarily a compromise between the impact of an error, its likelihood of occurrence, and the cost of the defence in terms of code size and execution time. In this work we first create a fault insertion system and then use it to demonstrate a technique for precisely triggering and capturing individual error responses within a running micro-controller. This enables a more realistic calibration of a micro-controller's fault model. We apply the system to a representative micro-controller and the results show that error insertion is far more predictable than anticipated, and is consistent over a wide range of experimental tolerances. This observation undermines some widely deployed software defences recommended for fault attack protection.},
annote = {Shows that software runtime checking does not necessarity work},
author = {Kelly, Martin S and Mayes, Keith and Walker, John F},
booktitle = {2017 IEEE International Symposium on Hardware Oriented Security and Trust (HOST)},
doi = {10.1109/HST.2017.7951802},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kelly, Mayes, Walker - 2017 - Characterising a CPU fault attack model via run-time data analysis.pdf:pdf},
isbn = {978-1-5386-3929-0},
month = {may},
pages = {79--84},
publisher = {IEEE},
title = {{Characterising a CPU fault attack model via run-time data analysis}},
url = {http://ieeexplore.ieee.org/document/7951802/},
year = {2017}
}
@article{Kleber2015a,
author = {Kleber, Stephan and Unterstein, Florian and Matousek, Matthias and Kargl, Frank and Slomka, Frank and Hiller, Matthias},
doi = {10.18725/OPARU-3255},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kleber et al. - 2015 - Design of the Secure Execution PUF-based Processor ( SEPP ).pdf:pdf},
journal = {Workshop on Trustworthy Manufacturing and Utilization of Secure Devices, TRUDEVICE 2015},
number = {2},
pages = {1--5},
title = {{Design of the Secure Execution PUF-based Processor ( SEPP )}},
year = {2015}
}
@article{Owusu2013,
abstract = {We present OASIS, a CPU instruction set extension for ex- ternally verifiable initiation, execution, and termination of an isolated execution environment with a trusted computing base consisting solely of the CPU. OASIS leverages the hard- ware components available on commodity CPUs to achieve a low-cost, low-overhead design.},
author = {Owusu, Emmanuel and Guajardo, Jorge and Mccune, Jonathan M. and Newsome, Jim and Perrig, Adrian and Vasudevan, Amit},
doi = {10.1145/2508859.2516678},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Owusu et al. - 2013 - OASIS On Achieving a Sanctuary for Integrity and Secrecy on Untrusted Platforms.pdf:pdf},
isbn = {9781450324779},
issn = {15437221},
journal = {Proceedings of the 2013 ACM SIGSAC conference on Computer and communications security (CCS'13)},
keywords = {instruction set extension,remote attestation,secure execution},
number = {i},
pages = {13--24},
title = {{OASIS: On Achieving a Sanctuary for Integrity and Secrecy on Untrusted Platforms}},
year = {2013}
}
@inproceedings{DiNatale2017,
abstract = {{\textcopyright} 2017 IEEE. Many techniques have been proposed in literature to cope with transient, permanent and malicious faults in computing systems. Among these techniques for reliability improvement and fault tolerance, Control Flow Checking allows covering any fault affecting the part of the storing elements containing the executable program, as well as all the hardware components handling the program itself and its flow. In [1] the authors proposed a low-overhead solution implementing hardware based control flow monitoring technique. They suggested that control flow error detection could be also used as a solution for enhancing the security of a computing system, preventing the insertion of malicious code in an application. In this paper we present a technique to map a malicious program into another one without structure violation and thus bypassing the control flow detection method.},
author = {{Di Natale}, Giorgio and Flottes, Marie Lise and Dupuis, Sophie and Rouzeyre, Bruno},
booktitle = {2017 2nd International Verification and Security Workshop, IVSW 2017},
doi = {10.1109/IVSW.2017.8031544},
isbn = {9781538617083},
title = {{Hacking the Control Flow error detection mechanism}},
year = {2017}
}
@inproceedings{Dolev1981,
author = {Dolev, Danny and Yao, A. C.},
booktitle = {22nd Annual Symposium on Foundations of Computer Science (sfcs 1981)},
doi = {10.1109/SFCS.1981.32},
file = {:D$\backslash$:/Downloads/dolev-yao-ieee-01056650.pdf:pdf},
month = {oct},
number = {M},
pages = {350--357},
publisher = {IEEE},
title = {{On the security of public key protocols}},
url = {http://ieeexplore.ieee.org/document/4568353/},
year = {1981}
}
@article{Nyman2017a,
abstract = {With the increasing scale of deployment of Internet of Things (IoT), concerns about IoT security have become more urgent. In particular, memory corruption attacks play a predominant role as they allow remote compromise of IoT devices. Control-flow integrity (CFI) is a promising and generic defense technique against these attacks. However, given the nature of IoT deployments, existing protection mechanisms for traditional computing environments (including CFI) need to be adapted to the IoT setting. In this paper, we describe the challenges of enabling CFI on microcontroller (MCU) based IoT devices. We then present CaRE, the first interrupt-aware CFI scheme for low-end MCUs. CaRE uses a novel way of protecting the CFI metadata by leveraging TrustZone-M security extensions introduced in the ARMv8-M architecture. Its binary instrumentation approach preserves the memory layout of the target MCU software, allowing pre-built bare-metal binary code to be protected by CaRE. We describe our implementation on a Cortex-M Prototyping System and demonstrate that CaRE is secure while imposing acceptable performance and memory impact.},
archivePrefix = {arXiv},
arxivId = {arXiv:1706.05715v1},
author = {Nyman, Thomas and Ekberg, Jan Erik and Davi, Lucas and Asokan, N.},
doi = {10.1007/978-3-319-66332-6_12},
eprint = {arXiv:1706.05715v1},
file = {:D$\backslash$:/Downloads/1706.05715.pdf:pdf},
isbn = {9783319663319},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {259--284},
title = {{CFI CaRE: Hardware-Supported Call and, Return Enforcement for Commercial Microcontrollers}},
volume = {10453 LNCS},
year = {2017}
}
@book{GebotysCatherineH2010Sied,
abstract = {Design for security not only involves the design of security functionswhichmeet price, performance, power, and other constraints, but also resistance to attacks. An attack may be successful in extracting the secret key solely from the side channel signals recorded from a device executing a cryptographic algorithm. In many cases the plaintext of an encryption algorithm additionally may be required by the at- tacker (known plaintext attack) ormay have to be controlled by the attacker (chosen plaintext attack). In some cases the knowledge of the ciphertext (ciphertext attack) alongwith the side channel signals may be sufficient for an attack. This chapter will introduce the side channel attack and the following chapter will discuss resistance techniques. 8.1},
address = {New York ; London},
author = {Gebotys, Catherine H.},
booktitle = {Security in Embedded Devices},
doi = {10.1007/978-1-4419-1530-6},
isbn = {144191529x},
keywords = {Computer security,Embedded computer systems -- Se},
publisher = {Springer},
series = {Embedded systems},
title = {{Security in Embedded Devices}},
year = {2010}
}
@article{Habing1965,
abstract = {High levels of ionization can be created in semiconductor devices by irradiating the devices with short pulses of light. If the light frequency is properly selected, sufficient and relatively uniform energy deposition is obtained which results in ionization rates orders of magnitude above those presently attainable from other sources. It is shown that a pulsed-infrared laser can be used as a relatively simple, inexpensive, and effective means of simulating the effects caused by intense gamma ray sources on semiconductors. Experimental results are presented which show that the transients induced in various types of silicon transistors when exposed to a neodymium laser are essentially identical to those obtained when the transistors are exposed to pulses of 25 MeV electrons from a linear accelerator and 600 kvp flash X-ray machine. Good agreement exists between the peak photocurrents obtained using these three sources over a dose range of 10-1 to 104 rads. Calculations based upon published as well as experimental absorption data for silicon show that energy deposition is very nearly uniform for the wavelength of light obtained from neodymium lasers (1. 06 microns - 1. 17 ev photons). By defocusing the laser light beam, dose rates in excess of 10R12 rads/ sec (silicon) in 40 x 1-99 seconds over an area of 50 cm2 have been obtained from a Q-switched 10 megawatt neodymium laser. This greatly exceeds the maximum dose rate of 1011{\textless} rads/ sec silicon) over approximately 1 c2m attainable from linear accelerators.},
author = {Habing, D. H.},
doi = {10.1109/TNS.1965.4323904},
file = {:D$\backslash$:/Downloads/04323904.pdf:pdf},
issn = {15581578},
journal = {IEEE Transactions on Nuclear Science},
number = {5},
pages = {91--100},
title = {{The use of lasers to simulate radiation-induced transients in semiconductor devices and circuits}},
volume = {12},
year = {1965}
}
@article{Gopalakrishna2005,
abstract = {Host-based intrusion detection systems attempt to identify attacks by discovering program behaviors that deviate from expected patterns. While the idea of performing behavior validation on-the-fly and terminating errant tasks as soon as a violation is detected is appealing, existing systems exhibit serious shortcomings in terms of accuracy and/or efficiency. To gain acceptance, a number of technical advances are needed. In this paper we focus on automated, conservative, intrusion detection techniques, i.e. techniques which do not require human intervention and do not suffer from false positives. We present a static analysis algorithm for constructing a flow- and context-sensitive model of a program that allows for efficient online validation. Context-sensitivity is essential to reduce the number of impossible control-flow paths accepted by the intrusion detection system because such paths provide opportunities for attackers to evade detection. An important consideration for on-the-fly intrusion detection is to reduce the performance overhead caused by monitoring. Compared to the existing approaches, our inlined automaton model (JAM) presents a good tradeoff between accuracy and performance. On a 32K line program, the monitoring overhead is negligible. While the space requirements of a naive IAM implementation can be quite high, compaction techniques can be employed to substantially reduce that footprint. {\textcopyright} 2005 IEEE.},
author = {Gopalakrishna, Rajeev and Spafford, Eugene H. and Vitek, Jan},
doi = {10.1109/SP.2005.1},
file = {:D$\backslash$:/Downloads/01425056.pdf:pdf},
isbn = {0769523390},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {18--31},
title = {{Efficient intrusion detection using automaton inlining}},
year = {2005}
}
@inproceedings{Castelluccia2009,
address = {New York, New York, USA},
author = {Castelluccia, Claude and Francillon, Aur{\'{e}}lien and Perito, Daniele and Soriente, Claudio},
booktitle = {Proceedings of the 16th ACM conference on Computer and communications security - CCS '09},
doi = {10.1145/1653662.1653711},
file = {:D$\backslash$:/Downloads/CCS09{\_}Software{\_}based{\_}attestation.pdf:pdf},
isbn = {9781605588940},
keywords = {code compression,embedded systems,indisputable code execution,networks,return-oriented programming,software-based attestation,swatt,wireless sensor},
pages = {400},
publisher = {ACM Press},
title = {{On the difficulty of software-based attestation of embedded devices}},
url = {http://portal.acm.org/citation.cfm?doid=1653662.1653711},
year = {2009}
}
@article{Mysore2008,
abstract = {It is not uncommon for modern systems to be composed of a variety of interacting services, running across multiple machines in such a way that most developers do not really understand the whole sys- tem. As abstraction is layered atop abstraction, developers gain the ability to compose systems of extraordinary complexity with rela- tive ease. However, many software properties, especially those that cut across abstraction layers, become very difficult to understand in such compositions. The communication patterns involved, the privacy of critical data, and the provenance of information, can be difficult to find and understand, even with access to all of the source code. The goal of Data Flow Tomography is to use the inherent in- formation flow of such systems to help visualize the interactions between complex and interwoven components across multiple lay- ers of abstraction. In the same way that the injection of short-lived radioactive isotopes help doctors trace problems in the cardiovas- cular system, the use of “data tagging” can help developers slice through the extraneous layers of software and pin-point those por- tions of the system interacting with the data of interest. To demon- strate the feasibility of this approach we have developed a proto- type system in which tags are tracked both through the machine and in between machines over the network, and from which novel visualizations of the whole system can be derived.We describe the system-level challenges in creating a working system tomography tool and we qualitatively evaluate our system by examining several example real world scenarios.},
author = {Mysore, Shashidhar and Mazloom, Bita and Agrawal, Banit and Sherwood, Timothy},
doi = {10.1145/1353536.1346308},
file = {:D$\backslash$:/Downloads/p211-mysore.pdf:pdf},
isbn = {9781595939586},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {c-0,computer systems or-},
number = {3},
pages = {211},
title = {{Understanding and visualizing full systems with data flow tomography}},
volume = {43},
year = {2008}
}
@book{MayesKeithE2008SCTS,
address = {Boston, MA},
author = {Mayes, Keith E and Markantonakis, Konstantinos},
isbn = {9780387721972},
keywords = {Computer Science ; Data Encryption ; Systems and D,Cryptology and Information Theory ; Computer Comm},
publisher = {Springer US},
title = {{Smart Cards, Tokens, Security and Applications}},
year = {2008}
}
@article{Oh2002,
abstract = {This paper presents a new signature monitoring technique, CFCSS$\backslash$n(control flow checking by software signatures); CFCSS is a pure software$\backslash$nmethod that checks the control flow of a program using assigned$\backslash$nsignatures. An algorithm assigns a unique signature to each node in the$\backslash$nprogram graph and adds instructions for error detection. Signatures are$\backslash$nembedded in the program during compilation time using the constant field$\backslash$nof the instructions and compared with run-time signatures when the$\backslash$nprogram is executed. Another algorithm reduces the code size and$\backslash$nexecution time overhead caused by checking instructions in CFCSS. A$\backslash$n"branching fault injection experiment" was performed with benchmark$\backslash$nprograms. Without CFCSS, an average of 33.7 {\%} of the injected branching$\backslash$nfaults produced undetected incorrect outputs; however, with CFCSS, only$\backslash$n3.1 {\%} of branching faults produced undetected incorrect outputs. Thus it$\backslash$nis possible to increase error detection coverage for control flow errors$\backslash$nby an order of magnitude using CFCSS. The distinctive advantage of CFCSS$\backslash$nover previous signature monitoring techniques is that CFCSS is a pure$\backslash$nsoftware method, i.e., it needs no dedicated hardware such as a watchdog$\backslash$nprocessor for control flow checking. A watchdog task in multitasking$\backslash$nenvironment also needs no extra hardware, but the advantage of CFCSS$\backslash$nover a watchdog task is that CFCSS can be used even when the operating$\backslash$nsystem does not support multitasking},
author = {Oh, Nahmsuk and Shirvani, Philip P. and McCluskey, Edward J.},
doi = {10.1109/24.994926},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Oh, Shirvani, McCluskey - 2002 - Control-flow checking by software signatures.pdf:pdf},
issn = {00189529},
journal = {IEEE Transactions on Reliability},
keywords = {Assigned signatures,Control flow checking,Fault injection experiments,Signature monitoring,Software error detection},
number = {1},
pages = {111--122},
title = {{Control-flow checking by software signatures}},
volume = {51},
year = {2002}
}
@article{Rahmatian2012,
abstract = {One of the critical security threats to computer systems is the execution of malware or malicious software. Several intrusion detection systems have been proposed which perform detection analysis in the software using the audit files generated by the operating system. Software-based solutions to this problem are relatively slow, so these techniques can be used forensically, but not in real-time to stop an exploit before it has an opportunity to do damage. We present a technique to implement intrusion detection for secure embedded systems by detecting behavioral differences between the correct system and the malware. The system is implemented using FPGA logic to enable the detection process to be regularly updated to adapt to new malware and changing system behavior.},
author = {Rahmatian, Mehryar and Kooti, Hessam and Harris, Ian G. and Bozorgzadeh, Elaheh},
doi = {10.1109/LES.2012.2218630},
file = {:D$\backslash$:/Downloads/06301679.pdf:pdf},
issn = {19430663},
journal = {IEEE Embedded Systems Letters},
keywords = {Embedded system security,FPGA,intrusion detection},
number = {4},
pages = {94--97},
publisher = {IEEE},
title = {{Hardware-assisted detection of malicious software in embedded systems}},
volume = {4},
year = {2012}
}
@article{McGillion2015,
abstract = {Hardware-based Trusted Execution Environments (TEEs) are widely deployed in mobile devices. Yet their use has been limited primarily to applications developed by the device vendors. Recent standardization of TEE interfaces by GlobalPlatform (GP) promises to partially address this problem by enabling GP-compliant trusted applications to run on TEEs from different vendors. Nevertheless ordinary developers wishing to develop trusted applications face significant challenges. Access to hardware TEE interfaces are difficult to obtain without support from vendors. Tools and software needed to develop and debug trusted applications may be expensive or non-existent. In this paper, we describe Open-TEE, a virtual, hardware-independent TEE implemented in software. Open-TEE conforms to GP specifications. It allows developers to develop and debug trusted applications with the same tools they use for developing software in general. Once a trusted application is fully debugged, it can be compiled for any actual hardware TEE. Through performance measurements and a user study we demonstrate that Open-TEE is efficient and easy to use. We have made Open- TEE freely available as open source.},
archivePrefix = {arXiv},
arxivId = {arXiv:1506.07367v2},
author = {McGillion, Brian and Dettenborn, Tanel and Nyman, Thomas and Asokan, N.},
doi = {10.1109/Trustcom.2015.400},
eprint = {arXiv:1506.07367v2},
file = {:D$\backslash$:/Downloads/1506.07367.pdf:pdf},
isbn = {9781467379519},
journal = {Proceedings - 14th IEEE International Conference on Trust, Security and Privacy in Computing and Communications, TrustCom 2015},
keywords = {GlobalPlatform,Hardware security,Open source,Software development,Trusted Execution Environments,Usability},
pages = {400--407},
title = {{Open-TEE - An open virtual trusted execution environment}},
volume = {1},
year = {2015}
}
@inproceedings{10.1007/978-0-387-35691-4_7,
abstract = {Secure perimeter schemes (e.g. DRM) and tracing traitor schemes (e.g. watermarking, audit logging) strive to mitigate the problems of content escaping the control of the rights holder. Secure audit logging records the user's actions on content and enables detection of some forms of tampering with the logs. We implement the Schneier and Kelsey's secure audit logging protocol [6], strengthening the protocol by using tamper-resistant hardware (an iButton) in three ways: Firstly, our implementation of the protocol works offline as well as online. Secondly, we use unforgeable timestamps to increase the possibilities of fraud detection. Lastly, we generate the authentication keys, core security of Schneier and Kelsey's protocol on the iButton to alleviate the possibilities of malicious client generating the bad keys. We provide a performance assessment of our implementation to show under which circumstances the protocol is practical to use.},
address = {Boston, MA},
author = {Chong, Cheun Ngen and Peng, Zhonghong and Hartel, Pieter H},
booktitle = {Security and Privacy in the Age of Uncertainty},
editor = {Gritzalis, Dimitris and di Vimercati, Sabrina and Samarati, Pierangela and Katsikas, Sokratis},
isbn = {978-0-387-35691-4},
pages = {73--84},
publisher = {Springer US},
title = {{Secure Audit Logging with Tamper-Resistant Hardware}},
year = {2003}
}
@article{Jacob2007,
abstract = {Executing binaries without interference by an outside adversary has been an ongoing duel between protection methods and at- tacks. Recently, an efficient kernel-patch attack has been pre- sented against commonly used self-checking code techniques that use checksumming ahead of execution. While methods based on self-modifying code can defend against this attack, such techniques depend on low-level architectural details and may not be practical in the long run. An alternative defense is to use oblivious hashing (OH). Instead of checking code integrity prior to execution, OH can verify untampered runtime behavior continuously. However, earlier OH approaches have some weaknesses, particularly with binary code: Physical instruction bytes cannot be easily checked during execution, and an attacker may be able to detect and remove OH checks, since OH alone does not provide tamper-resistance or obfuscation. In our approach, we deliberately overlap a program's basic blocks so that they share instruction bytes. This increases tamper- resistance implicitly because malicious modifications affect mul- tiple instructions simultaneously. Also, our scheme facilitates explicit anti-tampering checks via injection of OH instructions overlapped with target code, enabling OH that can verify in- tegrity of both runtime state and executing instructions. Thus, our method addresses anti-checksum attacks without resorting to self-modifying code, and also extends OH to verify physical code, not only program state. In addition, overlapping facilitates resis- tance against disassembly and decompilation. Our approach works on processor architectures and byte-codes that support variable- length instructions. To our knowledge, this is the first technique that blends tamper-resistance into architecture and therefore sig- nificantly improves robustness of binaries.},
author = {Jacob, Matthias and Jakubowski, Mariusz H and Venkatesan, Ramarathnam},
doi = {10.1145/1288869.1288887},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Jacob, Jakubowski, Venkatesan - 2007 - Towards Integral Binary Execution Implementing Oblivious Hashing Using Overlapped Instruction Enc.pdf:pdf},
isbn = {978-1-59593-857-2},
journal = {Proceedings of the 9th Workshop on Multimedia {\&} Security},
keywords = {anti-disassembly,integrity checking,obfuscation,oblivious hashing,overlapped code,tamper-resistance},
pages = {129--140},
title = {{Towards Integral Binary Execution: Implementing Oblivious Hashing Using Overlapped Instruction Encodings}},
url = {http://doi.acm.org/10.1145/1288869.1288887},
year = {2007}
}
@article{Wilander,
author = {Wilander, John and Kamkar, Mariam},
file = {:D$\backslash$:/Downloads/wilander-comparison.pdf:pdf},
keywords = {buffer overflow,dynamic analysis,figure 1,intrusion,prevention,security intrusion,software vulnerabilities reported to},
title = {{Wilander-Comparison (1)}}
}
@article{Wang2016,
abstract = {Critical infrastructure components nowadays use microprocessor-based embedded control systems. It is often infeasible, however, to employ the same level of security measures used in general purpose computing systems, due to the stringent performance and resource constraints of embedded control systems. Furthermore, as software sits atop and relies on the firmware for proper operation, software-level techniques cannot detect malicious behavior of the firmware. In this work, we propose ConFirm, a low-cost technique to detect malicious modifications in the firmware of embedded control systems by measuring the number of low-level hardware events that occur during the execution of the firmware. In order to count these events, ConFirm leverages the Hardware Performance Counters (HPCs), which readily exist in many embedded processors. We evaluate the detection capability and performance overhead of the proposed technique on various types of firmware running on ARM- and PowerPC-based embedded processors. Experimental results demonstrate that ConFirm can detect all the tested modifications with low performance overhead. {\textcopyright} 2015 IEEE.},
annote = {Combination of checkpoint checking and secure boot},
author = {Wang, Xueyang and Konstantinou, Charalambos and Maniatakos, Michail and Karri, Ramesh},
doi = {10.1109/ICCAD.2015.7372617},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Wang et al. - 2016 - ConFirm Detecting firmware modifications in embedded systems using Hardware Performance Counters.pdf:pdf},
isbn = {9781467383882},
issn = {1933-7760},
journal = {2015 IEEE/ACM International Conference on Computer-Aided Design, ICCAD 2015},
pages = {544--551},
publisher = {IEEE},
title = {{ConFirm: Detecting firmware modifications in embedded systems using Hardware Performance Counters}},
year = {2016}
}
@article{Ekberg2013,
abstract = {A trusted execution environment (TEE) is a secure process- ing environment that is isolated from the “normal” process- ing environment where the device operating system and ap- plications run. The firstmobile phones with hardware-based TEEs appeared almost a decade ago, and today almost every smartphone and tablet contains a TEE like ARMTrustZone. Despite such a large-scale deployment, the use of TEE func- tionality has been limited for developers. With emerging standardization this situation is about to change. In this tutorial, we explain the security features provided by mo- bile TEEs and describe On-board Credentials (ObC) system that enables third-party TEE development. We discuss on- going TEE standardization activities, including the recent Global Platform standards and the Trusted Platform Mod- ule (TPM) 2.0 specification, and identify open problems for the near future of mobile hardware security.},
author = {Ekberg, Jan-Erik and Kostiainen, Kari and Asokan, N.},
doi = {10.1145/2508859.2516758},
file = {:D$\backslash$:/Downloads/p1497-ekberg.pdf:pdf},
isbn = {9781450324779},
keywords = {mobile devices,trusted execution environments},
pages = {1497--1498},
title = {{Trusted execution environments on mobile devices}},
year = {2013}
}
@article{Nguyen2013,
abstract = {—Binary code analysis has attracted much attention. The difficulty lies in constructing a Control Flow Graph (CFG), which is dynamically generated and modified, such as mutations. Typical examples are handling dynamic jump instructions, in which destinations may be directly modified by rewriting loaded instructions on memory. In this paper, we describe a PhD project proposal on a hybrid approach that combines static analysis and dynamic testing to construct CFG from binary code. Our aim is to minimize false targets produced when processing indirect jumps during CFG construction. To evaluate the potential of our approach, we preliminarily compare results between our method and Jakstab, a state-of-the-art tool in this field.},
author = {Nguyen, Minh Hai and Nguyen, Thien Binh and Quan, Thanh Tho and Ogawa, Mizuhito},
doi = {10.1109/APSEC.2013.132},
file = {:D$\backslash$:/Downloads/06754371.pdf:pdf},
issn = {15301362},
journal = {Proceedings - Asia-Pacific Software Engineering Conference, APSEC},
keywords = {SMT,binary code analysis,control flow graph construction,dynamic analysis,static analysis,symbolic execution},
number = {2},
pages = {159--164},
publisher = {IEEE},
title = {{A hybrid approach for control flow graph construction from binary code}},
volume = {2},
year = {2013}
}
@article{Koeberl2014,
abstract = {Embedded systems are increasingly pervasive, interdependent and in many cases critical to our every day life and safety. Tiny devices that cannot afford sophisticated hardware security mechanisms are embedded in complex control infrastructures, medical support systems and entertainment products [51]. As such devices are increasingly subject to attacks, new hardware protection mechanisms are needed to provide the required resilience and dependency at low cost. In this work, we present the TrustLite security architecture for flexible, hardware-enforced isolation of software modules. We describe mechanisms for secure exception handling and communication between protected modules, enabling seamless interoperability with untrusted operating systems and tasks. TrustLite scales from providing a simple protected firmware runtime to advanced functionality such as attestation and trusted execution of userspace tasks. Our FPGA prototype shows that these capabilities are achievable even on low-cost embedded systems.},
author = {Koeberl, Patrick and Schulz, Steffen and Sadeghi, Ahmad-Reza and Varadharajan, Vijay},
doi = {10.1145/2592798.2592824},
file = {:D$\backslash$:/Downloads/trustlite.pdf:pdf},
isbn = {9781450327046},
pages = {1--14},
title = {{TrustLite}},
year = {2014}
}
@article{ARM2009,
abstract = {This document provides an overview of the ARM TrustZone technology and how this can provide a practical level of security through careful System-on-a-Chip (SoC) configuration and software design.$\backslash$nARM TrustZone technology includes the ARM Security Extensions to the processor, the security signals added to the AMBA{\textregistered}3 bus infrastructure, and a number of pieces of peripheral Intellectual Property (IP) which can be used to build security on top of the$\backslash$nprocessor architecture and system architecture.},
author = {ARM},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/ARM - 2009 - Building a Secure System using TrustZone Technology.pdf:pdf},
journal = {Manual},
pages = {108},
title = {{Building a Secure System using TrustZone Technology}},
year = {2009}
}
@inproceedings{Blomer2010,
abstract = {In this paper we describe several fault attacks on the Advanced Encryption Standard (AES). First, using optical/eddy current fault induction attacks as recently publicly presented by Skorobogatov, Anderson and Quisquater, Samyde [SA, QS], we present an implementation independent fault attack on AES. This attack is able to determine the complete 128-bit secret key of a sealed tamper-proof smartcard by generating 128 faulty cipher texts. Second, we present several implementation-dependent fault attacks on AES. These attacks rely on the observation that due to the AES's known timing analysis vulnerability (as pointed out by Koeune and Quisquater [KQ]), any implementation of the AES must ensure a data independent timing behavior for the so called AES's xtime operation. We present fault attacks on AES based on various timing analysis resistant implementations of the xtime-operation. Our strongest attack in this direction uses a very liberal fault model and requires only 256 faulty encryptions to determine a 128-bit key.},
address = {Berlin, Heidelberg},
author = {Bl{\"{o}}mer, Johannes and Seifert, Jean-Pierre},
booktitle = {Financial Cryptography},
editor = {Wright, Rebecca N},
isbn = {978-3-540-45126-6},
pages = {162--181},
publisher = {Springer Berlin Heidelberg},
title = {{Fault Based Cryptanalysis of the Advanced Encryption Standard (AES)}},
year = {2003}
}
@phdthesis{Nyberg2018,
author = {Nyberg, Ralph Heinz-erik},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Nyberg - 2018 - New Techniques for Emulating Fault Attacks.pdf:pdf},
school = {Technische Universitat M ¨ unchen},
title = {{New Techniques for Emulating Fault Attacks}},
year = {2018}
}
@incollection{Blomer2010old,
abstract = {In this paper we describe several,fault attacks on the Advanced Encryption Standard (AES). First, using optical/eddy current fault induction attacks as recently publicly presented by Skorobogatov, Anderson and Quisquater, Samyde SA,QS, we-present an implementation independent fault attack on AES. This attack is able to determine the complete 128-bit secret key of a sealed tamper-proof smart-card by generating 128 faulty cipher texts. Second, we present several implementation-dependent fault attacks on AES. These attacks rely on the observation that due to the AES's known timing analysis vulnerability (as pointed out by Koeune and Quisquater KQ), any implementation of the AES must ensure a data independent timing behavior for the so called AES's xtime operation. We present fault attacks on AES based on various timing analysis resistant implementations of the xtime-operation. Our strongest attack in this direction uses a very liberal fault model and requires only 256 faulty encryptions to determine a 128-bit key.},
author = {Bl{\"{o}}mer, Johannes and Seifert, Jean-Pierre},
doi = {10.1007/978-3-540-45126-6_12},
file = {:D$\backslash$:/Downloads/Bl{\"{o}}mer-Seifert2003{\_}Chapter{\_}FaultBasedCryptanalysisOfTheAd.pdf:pdf},
keywords = {aes,fault attacks,implementation issues,secure bank-},
pages = {162--181},
title = {{Fault Based Cryptanalysis of the Advanced Encryption Standard (AES)}},
url = {http://link.springer.com/10.1007/978-3-540-45126-6{\_}12},
year = {2003}
}
@article{Jahankhani2011,
abstract = {The increasing use of distributed authentication architecture has made interoperability of systems an important issue. Interoperabil- ity of systems reflects the maturity of the technology and also improves confidence of users in the technology. Biometric systems are not im- mune to the concerns of interoperability. Interoperability of fingerprint sensors and its effect on the overall performance of the recognition sys- tem is an area of interest with a considerable amount of work directed towards it. This research analyzed effects of interoperability on error rates for fingerprint datasets captured from two optical sensors and a capacitive sensor when using a single commercially available fingerprint matching algorithm. The main aim of this research was to emulate a centralized storage and matching architecture with multiple acquisition stations. Fingerprints were collected from 44 individuals on all three sen- sors and interoperable False Reject Rates of less than .31{\%} were achieved using two different enrolment strategies.},
author = {Jahankhani, Hamid and Fernando, Shantha and Nkhoma, Mathews Z. and Mouratidis, Haralambos},
doi = {10.4018/jisp.2007070102},
file = {:D$\backslash$:/Downloads/Jain2016{\_}Chapter{\_}DiscoveringVulnerableFunctions.pdf:pdf},
isbn = {9783319498065},
issn = {1930-1650},
journal = {International Journal of Information Security and Privacy},
keywords = {code similarity,control flow graph,extrapolation,graph kernel,software vulnerability},
number = {3},
pages = {13--25},
title = {{Information Systems Security}},
volume = {1},
year = {2011}
}
@article{Simpson2006,
abstract = {Many Field-Programmable Gate Array (FPGA) based systems uti-lize third-party intellectual property (IP) in their development. When they are deployed in non-networked environments, the question raises how this IP can be protected against non-authorized use. We de-scribe an offline authentication scheme for IP modules. The scheme implements mutual authentication of the IP modules and the hard-ware platform, and enables us to provide authentication and integrity assurances to both the system developer and IP provider. Compared to the Trusted Computing Platform's approach to hardware, software authentication, our solution is more lightweight and tightly integrates with existing FPGA security features. We are able to demonstrate an implementation of the authentication scheme that requires a symmet-ric cipher and a Physically Unclonable Function (PUF). In addition to the low hardware requirements, our implementation does not require any on-chip, non-volatile storage.},
author = {Simpson, Eric and Schaumont, Patrick},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Simpson, Schaumont - 2006 - Offline HW SW Authentication for Reconfigurable Platforms.pdf:pdf},
journal = {Cryptographic Hardware and Embedded Systems (CHES)},
pages = {1--13},
title = {{Offline HW / SW Authentication for Reconfigurable Platforms}},
year = {2006}
}
@article{Khiyal2010,
author = {Khiyal, Malik Sikandar Hayat and Khan, Aihab and Amjad, Sehrish and Khalil, M. Shahid},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Khiyal et al. - 2010 - Evaluating Effectiveness of Tamper Proofing on Dynamic Graph Software Watermarks.pdf:pdf},
journal = {CoRR},
number = {July 2014},
title = {{Evaluating Effectiveness of Tamper Proofing on Dynamic Graph Software Watermarks}},
volume = {abs/1001.1},
year = {2010}
}
@incollection{Streetold,
author = {Anderson, Ross and Kuhn, Markus},
doi = {10.1007/BFb0028165},
file = {:D$\backslash$:/Downloads/Anderson-Kuhn1998{\_}Chapter{\_}LowCostAttacksOnTamperResistan.pdf:pdf},
pages = {125--136},
title = {{Low cost attacks on tamper resistant devices}},
url = {http://link.springer.com/10.1007/BFb0028165},
year = {1998}
}
@article{Kurnikov2018,
abstract = {Personal cryptographic keys are the foundation of many secure services, but storing these keys securely is a challenge, especially if they are used from multiple devices. Storing keys in a centralized location, like an Internet-accessible server, raises serious security concerns (e.g. server compromise). Hardware-based Trusted Execution Environments (TEEs) are a well-known solution for protecting sensitive data in untrusted environments, and are now becoming available on commodity server platforms. Although the idea of protecting keys using a server-side TEE is straight-forward, in this paper we validate this approach and show that it enables new desirable functionality. We describe the design, implementation, and evaluation of a TEE-based Cloud Key Store (CKS), an online service for securely generating, storing, and using personal cryptographic keys. Using remote attestation, users receive strong assurance about the behaviour of the CKS, and can authenticate themselves using passwords while avoiding typical risks of password-based authentication like password theft or phishing. In addition, this design allows users to i) define policy-based access controls for keys; ii) delegate keys to other CKS users for a specified time and/or a limited number of uses; and iii) audit all key usages via a secure audit log. We have implemented a proof of concept CKS using Intel SGX and integrated this into GnuPG on Linux and OpenKeychain on Android. Our CKS implementation performs approximately 6,000 signature operations per second on a single desktop PC. The latency is in the same order of magnitude as using locally-stored keys, and 20x faster than smart cards.},
archivePrefix = {arXiv},
arxivId = {1804.08569},
author = {Kurnikov, Arseny and Paverd, Andrew and Mannan, Mohammad and Asokan, N.},
doi = {10.1145/3230833.3234518},
eprint = {1804.08569},
file = {:D$\backslash$:/Downloads/a40-Kurnikov.pdf:pdf},
isbn = {9781450364485},
keywords = {Cloud, Intel SGX, Key management,all or part of,classroom use is granted,cloud,copies are not made,intel sgx,key management,or,or distributed,or hard copies of,permission to make digital,this work for personal,without fee provided that},
title = {{Keys in the Clouds: Auditable Multi-device Access to Cryptographic Credentials}},
url = {http://arxiv.org/abs/1804.08569{\%}0Ahttp://dx.doi.org/10.1145/3230833.3234518},
year = {2018}
}
@article{Klimov2004,
abstract = {A  T-function is a mapping from  n-bit words to  n-bit words in which for each 0 ≤ i n bit  i of the output can depend only on bits 0,1,..., i of the input. All the boolean operations and most of the numeric operations in modern processors are T-functions, and their compositions are also T-functions. In earlier papers we considered ‘crazy' T-functions such as f( x)= x+( x 2 ∨ 5), proved that they are invertible mappings which contain all the 2 n possible states on a single cycle for any word size  n, and proposed to use them as primitive building blocks in a new class of software-oriented cryptographic schemes. The main practical drawback of this approach is that most processors have either 32 or 64 bit words, and thus even a maximal length cycle (of size 2 32 or 2 64) may be too short. In this paper we develop new ways to construct invertible T-functions on multiword states whose iteration is guaranteed to yield a single cycle of arbitrary length (say, 2 256). Such mappings can lead to stream ciphers whose software implementation on a standard Pentium 4 processor can encrypt more than 5 gigabits of data per second, which is an order of magnitude faster than previous designs such as RC4.},
author = {Klimov, Alexander and Shamir, Adi},
file = {:D$\backslash$:/Downloads/30170001.pdf:pdf},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {1--15},
title = {{New cryptographic primitives based on multiword T-functions}},
volume = {3017},
year = {2004}
}
@inproceedings{Eldefrawy2017,
abstract = {Remote Attestation (RA) allows a trusted entity (verifier) to securely measure internal state of a remote untrusted hardware platform (prover). RA can be used to establish a static or dynamic root of trust in embedded and cyber-physical systems. It can also be used as a building block for other security services and primitives, such as software updates and patches, verifiable deletion and memory resetting. There are three major classes of RA designs: hardware-based, software-based, and hybrid, each with its own set of benefits and drawbacks. This paper presents the first hybrid RA design, called HYDRA, that builds upon formally verified software components that ensure memory isolation and protection, as well as enforce access control to memory and other resources. HYDRA obtains these properties by using the formally verified seL4 microkernel. (Until now, this was only attainable with purely hardware-based designs.) Using seL4 requires fewer hardware modifications to the underlying microprocessor. Building upon a formally verified software component increases confidence in security of the overall design of HYDRA and its implementation. We instantiate HYDRA on two commodity hardware platforms and assess the performance and overhead of performing RA on such platforms via experimentation; we show that HYDRA can attest 10MB of memory in less than 500msec when using a Speck-based message authentication code (MAC) to compute a cryptographic checksum over the memory to be attested.},
author = {Eldefrawy, Karim and Rattanavipanon, Norrathep and Tsudik, Gene},
booktitle = {Proceedings - 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks Workshops, DSN-W 2017},
doi = {10.1109/DSN-W.2017.31},
isbn = {9781538622728},
title = {{FUsing Hybrid Remote Attestation with a Formally Verified Microkernel: Lessons Learned}},
year = {2017}
}
@article{Guin2014,
abstract = {As the electronic component supply chain grows more complex due to globalization, with parts coming from a diverse set of suppliers, counterfeit electronics have become a major challenge that calls for immediate solutions. Currently, there are a few standards and programs available that address the testing for such counterfeit parts. However, not enough research has yet addressed the detection and avoidance of all counterfeit partsVrecycled, remarked, overproduced, cloned, out-of-spec/defective, and forged documentationVcurrently infiltrating the electronic component supply chain. Even if they work initially, all these parts may have reduced lifetime and pose reliability risks. In this tutorial, we will provide a review of some of the existing counterfeit detection and avoidance methods. We will also discuss the challenges ahead for implementing these methods, as well as the development of new detection and avoidance mechanisms.},
author = {Guin, Ujjwal and Dimase, Daniel and Tehranipoor, Mohammad},
doi = {10.1007/s10836-013-5430-8},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Guin, Dimase, Tehranipoor - 2014 - Counterfeit integrated circuits Detection, avoidance, and the challenges ahead.pdf:pdf},
issn = {15730727},
journal = {Journal of Electronic Testing: Theory and Applications (JETTA)},
keywords = {Counterfeit ICs,Counterfeit detection and avoidance,Electronic component supply chain},
number = {1},
pages = {9--23},
title = {{Counterfeit integrated circuits: Detection, avoidance, and the challenges ahead}},
volume = {30},
year = {2014}
}
@article{VanderVeen,
abstract = {Current Control-Flow Integrity (CFI) implementations track control edges individually, insensitive to the context of preceding edges. Recent work demonstrates that this leaves sufficient leeway for powerful ROP attacks. Context-sensitive CFI, which can provide enhanced security, is widely considered impractical for real-world adoption. Our work shows that Context-sensitive CFI (CCFI) for both the backward and forward edge can be implemented efficiently on commodity hardware. We present PathArmor, a binary-level CCFI implementation which tracks paths to sensitive program states, and defines the set of valid control edges within the state context to yield higher precision than existing CFI implementations. Even with simple context-sensitive policies , PathArmor yields significantly stronger CFI invariants than context-insensitive CFI, with similar performance.},
author = {van der Veen, Victor and Andriesse, Dennis and G{\"{o}}kta, Enes and Gras, Ben and Sambuc, Lionel and Slowinska, Asia and Bos, Herbert and Barbara, Santa},
doi = {10.1145/2810103.2813673},
file = {:D$\backslash$:/Downloads/patharmor{\_}ccs15.pdf:pdf},
isbn = {9781450338325},
keywords = {()},
title = {{Practical Context-Sensitive CFI Cristiano Giuffrida ‡ † Equal contribution joint first authors}},
url = {http://dx.doi.org/10.1145/2810103.2813673.}
}
@article{Wagner2002,
abstract = {One of the primary challenges in intrusion detection is modelling$\backslash$ntypical application behavior so that we can recognize attacks by$\backslash$ntheir atypical effects without raising too many false alarms. We$\backslash$nshow how static analysis may be used to automatically derive a model$\backslash$nof application behavior. The result is a host-based intrusion detection$\backslash$nsystem with three advantages: a high degree of automation, protection$\backslash$nagainst a broad class of attacks based on corrupted code, and the$\backslash$nelimination of false alarms. We report on our experience with a prototype$\backslash$nimplementation of this technique},
author = {Wagner, David and Dean, Drew},
doi = {10.1109/secpri.2001.924296},
file = {:D$\backslash$:/Downloads/00924296.pdf:pdf},
issn = {10637109},
journal = {Proceedings of the IEEE Computer Society Symposium on Research in Security and Privacy},
pages = {156--168},
title = {{Intrusion detection via static analysis}},
year = {2001}
}
@article{Burow2018,
abstract = {Control-Flow Hijacking attacks are the dominant attack vector against C/C++ programs. Control-Flow Integrity (CFI) solutions mitigate these attacks on the forward edge,i.e., indirect calls through function pointers and virtual calls. Protecting the backward edge is left to stack canaries, which are easily bypassed through information leaks. Shadow Stacks are a fully precise mechanism for protecting backwards edges, and should be deployed with CFI mitigations. We present a comprehensive analysis of all possible shadow stack mechanisms along three axes: performance, compatibility, and security. For performance comparisons we use SPEC CPU2006, while security and compatibility are qualitatively analyzed. Based on our study, we renew calls for a shadow stack design that leverages a dedicated register, resulting in low performance overhead, and minimal memory overhead, but sacrifices compatibility. We present case studies of our implementation of such a design, Shadesmar, on Phoronix and Apache to demonstrate the feasibility of dedicating a general purpose register to a security monitor on modern architectures, and the deployability of Shadesmar. Our comprehensive analysis, including detailed case studies for our novel design, allows compiler designers and practitioners to select the correct shadow stack design for different usage scenarios.},
archivePrefix = {arXiv},
arxivId = {1811.03165},
author = {Burow, Nathan and Zhang, Xinping and Payer, Mathias},
eprint = {1811.03165},
file = {:D$\backslash$:/Downloads/a223-Liljestrand.pdf:pdf},
isbn = {9781450367257},
pages = {1--2},
title = {{Shining Light On Shadow Stacks}},
url = {http://arxiv.org/abs/1811.03165},
year = {2018}
}
@article{Sullivan2016,
author = {Sullivan, Dean and Arias, Orlando and Davi, Lucas and Larsen, Per and Sadeghi, Ahmad-Reza and Jin, Yier},
doi = {10.1145/2897937.2898098},
file = {:D$\backslash$:/Downloads/07544404.pdf:pdf},
isbn = {9781450342360},
journal = {2016 53nd ACM/EDAC/IEEE Design Automation Conference (DAC)},
pages = {1--6},
publisher = {IEEE},
title = {{Strategy without tactics}},
year = {2016}
}
@article{Rauter2015,
abstract = {{\textcopyright} 2015 EDAA. Although software fault prevention techniques improve continually, faults remain in every complex software system. Thus safety-critical embedded systems need mechanisms to tolerate software faults. Typically, these systems use static redundancy to detect hardware faults during operation. However, the reliability of a redundant system not only depends on the reliability of each version, but also on the dissimilarity between them. Thus, researchers have investigated ways to automatically add cost-efficient diversity to software to increase the efficiency of redundancy strategies. One of these automated software diversification methods is diverse compiling, which exploits the diversity introduced by different compilers and different optimization flags. Today, diverse compiling is used to improve the hardware fault tolerance and to avoid common defects from compilers. However, in this paper we show that diverse compiling also enhances the software fault tolerance by increasing the chance of finding defects in the source code of the executed software during runtime. More precisely, the memory is organized differently, when using different compilers and compiler flags. This enhances the chance of detecting memory-related software bugs, such as missing memory initialization, during runtime. Here we experimentally quantify the efficiency of diverse compiling for software fault tolerance and we show that diverse compiling can help to detect up to about 70{\%} of memory-related software bugs.},
author = {Rauter, Tobias and H{\"{o}}ller, Andrea and Kreiner, Christian and Kajtazovic, Nermin and R{\"{o}}mer, Kay},
doi = {10.7873/date.2015.0118},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Rauter et al. - 2015 - Evaluation of Diverse Compiling for Software-Fault Detection.pdf:pdf},
isbn = {9783981537048},
pages = {531--536},
title = {{Evaluation of Diverse Compiling for Software-Fault Detection}},
year = {2015}
}
@article{Song2016,
abstract = {—Memory corruption vulnerabilities are the root cause of many modern attacks. Existing defense mechanisms are inadequate; in general, the software-based approaches are not efficient and the hardware-based approaches are not flexible. In this paper, we present hardware-assisted data-flow isolation, or, HDFI, a new fine-grained data isolation mechanism that is broadly applicable and very efficient. HDFI enforces isolation at the machine word granularity by virtually extending each memory unit with an additional tag that is defined by data-flow. This capability allows HDFI to enforce a variety of security models such as the Biba Integrity Model and the Bell–LaPadula Model. We implemented HDFI by extending the RISC-V instruc-tion set architecture (ISA) and instantiating it on the Xilinx Zynq ZC706 evaluation board. We ran several benchmarks including the SPEC CINT 2000 benchmark suite. Evaluation results show that the performance overhead caused by our modification to the hardware is low ({\textless} 2{\%}). We also developed or ported several security mechanisms to leverage HDFI, including stack protection, standard library enhancement, virtual function table protection, code pointer protection, kernel data protection, and information leak prevention. Our results show that HDFI is easy to use, imposes low performance overhead, and allows us to create more elegant and more secure solutions.},
author = {Song, Chengyu and Moon, Hyungon and Alam, Monjur and Yun, Insu and Lee, Byoungyoung and Kim, Taesoo and Lee, Wenke and Paek, Yunheung},
doi = {10.1109/SP.2016.9},
file = {:D$\backslash$:/Downloads/07546472.pdf:pdf},
isbn = {9781509008247},
journal = {Proceedings - 2016 IEEE Symposium on Security and Privacy, SP 2016},
pages = {1--17},
publisher = {IEEE},
title = {{HDFI: Hardware-Assisted Data-Flow Isolation}},
year = {2016}
}
@inproceedings{Shepherd2016,
abstract = {Notions like security, trust, and privacy are crucial in the digital environment and in the future, with the advent of technologies like the Internet of Things (IoT) and Cyber-Physical Systems (CPS), their importance is only going to increase. Trust has different definitions, some situations rely on real-world relationships between entities while others depend on robust technologies to gain trust after deployment. In this paper we focus on these robust technologies, their evolution in past decades and their scope in the near future. The evolution of robust trust technologies has involved diverse approaches, as a consequence trust is defined, understood and ascertained differently across heterogeneous domains and technologies. In this paper we look at digital trust technologies from the point of view of security and examine how they are making secure computing an attainable reality. The paper also revisits and analyses the Trusted Platform Module (TPM), Secure Elements (SE), Hypervisors and Virtualisation, Intel TXT, Trusted Execution Environments (TEE) like GlobalPlatform TEE, Intel SGX, along with Host Card Emulation, and Encrypted Execution Environment (E3). In our analysis we focus on these technologies and their application to the emerging domains of the IoT and CPS.},
annote = {Breif review into Secure and Trusted Execution, does not mention various other encrypted execution environments. Has a good set of properties},
author = {Shepherd, Carlton and Arfaoui, Ghada and Gurulian, Iakovos and Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem and Sauveron, Damien and Conchon, Emmanuel},
booktitle = {2016 IEEE Trustcom/BigDataSE/ISPA},
doi = {10.1109/TrustCom.2016.0060},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Shepherd et al. - 2016 - Secure and Trusted Execution Past, Present, and Future - A Critical Review in the Context of the Internet of Th.pdf:pdf},
isbn = {978-1-5090-3205-1},
issn = {2324-9013},
keywords = {Cyber-physical system,Encrypted execution environment,GlobalPlatform,Host card emulation,Intel SGX,Internet of things,Java card,Trust,Trusted computing,Trusted execution environment,Trusted platform module,Trustworthiness},
month = {aug},
pages = {168--177},
publisher = {IEEE},
title = {{Secure and Trusted Execution: Past, Present, and Future - A Critical Review in the Context of the Internet of Things and Cyber-Physical Systems}},
url = {http://ieeexplore.ieee.org/document/7846943/},
year = {2016}
}
@article{Holler2015,
abstract = {{\textcopyright} 2015 IEEE.Physical attacks, such as fault attacks, pose a decisive threat for the security of devices in the Internet of Things. An important class of countermeasures for fault attacks is fault tolerant software that is applicable for systems based on COTS hardware. In order to evaluate software countermeasures against fault attacks, fault injection is needed. However, established fault injection approaches require manufactured products or hardware details (e.g. netlists, RTL models), which are not available when using COTS hardware. In this paper, we present a QEMU-based fault injection platform that supports commercial COTS processors that are widely-used in the embedded domain. This framework allows a system-level analysis of software countermeasures by featuring the simulation of high-level hardware faults targeting, for example, memory cells, register cells, or the correct execution of instructions. The framework supports the generation of realistic fault attack scenarios. We illustrate the practicability of the approach by presenting two exemplary use cases.},
author = {Holler, Andrea and Krieg, Armin and Rauter, Tobias and Iber, Johannes and Kreiner, Christian},
doi = {10.1109/DSD.2015.79},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Holler et al. - 2015 - QEMU-based fault injection for a system-level analysis of software countermeasures against fault attacks.pdf:pdf},
isbn = {9781467380355},
journal = {Proceedings - 18th Euromicro Conference on Digital System Design, DSD 2015},
keywords = {COTS,Fault attacks,Fault injection,QEMU,Security},
pages = {530--533},
title = {{QEMU-based fault injection for a system-level analysis of software countermeasures against fault attacks}},
year = {2015}
}
@article{Bryant2004,
annote = {No references for "Encryption Wrappers"},
author = {Bryant, Eric D and Atallah, Mikhail J and Stytz, Martin R and Atallah, Mikhail J and Bryant, Eric D and Stytz, Martin R},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bryant et al. - 2004 - A Survey of Anti-Tamper Technologies.pdf:pdf},
journal = {The Journal of Defense Software Engineering},
number = {November},
pages = {12 -- 16},
title = {{A Survey of Anti-Tamper Technologies}},
year = {2004}
}
@article{Kostiainen2010,
abstract = {Credential platforms implemented on top of Trusted Execution Environments (TrEEs) allow users to store and use their credentials, e.g., cryptographic keys or user passwords, securely. One important requirement for a TrEE-based credential platform is the ability to attest that a credential has been created and is kept within the TrEE. Credential properties, such as usage permissions, should be also attested. Existing attestation mechanisms are limited to attesting which applications outside the TrEE are authorized to use the credential. In this paper we describe a novel key attestation mechanism that allows attestation of both TrEE internal and external key usage permissions. We have implemented this attestation mechanism for mobile phones with M-Shield TrEE.},
author = {Kostiainen, Kari and Dmitrienko, Alexandra and Ekberg, Jan Erik and Sadeghi, Ahmad Reza and Asokan, N.},
doi = {10.1007/978-3-642-13869-0_3},
file = {:D$\backslash$:/Downloads/Kostiainen2010{\_}Chapter{\_}KeyAttestationFromTrustedExecu.pdf:pdf},
isbn = {3642138683},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {30--46},
title = {{Key attestation from trusted execution environments}},
volume = {6101 LNCS},
year = {2010}
}
@article{Naccache2007,
abstract = {This paper introduces a method for tracking different copies of functionally equivalent algorithms containing identification$\backslash$nmarks known to the attacker. Unlike all previous solutions, the new technique does not rely on any marking assumption and$\backslash$nleads to a situation where each copy is either traceable or so severely damaged that it becomes impossible to store in polynomial$\backslash$nspace or run in polynomial time.$\backslash$n$\backslash$nAlthough RSA-related, the construction is particularly applicable to confidential block-ciphers such as SkipJack, RC4, GOST$\backslash$n2814789, GSM A5, COMP128, TIA CAVE or other proprietary executables distributed to potentially distrusted users.},
author = {Naccache, David and Shamir, Adi and Stern, Julien P.},
doi = {10.1007/3-540-49162-7_14},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Naccache, Shamir, Stern - 2007 - How to Copyright a Function.pdf:pdf},
number = {August 2004},
pages = {188--196},
title = {{How to Copyright a Function?}},
year = {2007}
}
@article{Zhang2019,
abstract = {Recently, code reuse attacks (CRAs), such as return-oriented programming (ROP) and jump-oriented programming (JOP), have emerged as a new class of ingenious security threatens. Attackers can utilize CRAs to hijack the control flow of programs to perform malicious actions without injecting any codes. Many defenses, classed into software-based and hardware-based, have been proposed. However, software-based methods are difficult to be deployed in practical systems due to high performance overhead. Hardware-based methods can reduce performance overhead but may require extending instruction set architectures (ISAs) and modifying compiler or suffer the vulnerability of key leakage. To tackle these issues, this paper proposes a new hardware-based control flow checking method to resist CRAs with negligible performance overhead without extending ISAs, modifying compiler and leaking the encryption/decryption key. The key technique involves two control flow checking mechanisms. The first one is the encrypted Hamming distances (EHDs) matching between the physical unclonable function (PUF) response and the return addresses, which prevents attackers from returning between gadgets so long as the PUF response is secret, thus resisting ROP attacks. The second one is the liner encryption/decryption operation (XOR) between PUF response and the instructions at target addresses of call and jmp instructions to defeat JOP attacks. Advanced return-based full-function reuse attacks will be prevented with the dynamic key-updating method. Experimental evaluations on benchmarks demonstrate that the proposed method introduces negligible 0.95{\%} run-time overhead and 0.78{\%} binary size overhead on average.},
annote = {I don't really like this one. Talks of Hamming distances to do stuff. Nope},
author = {Zhang, Jiliang and Qi, Binhang and Qin, Zheng and Qu, Gang},
doi = {10.1109/JIOT.2018.2866164},
file = {:D$\backslash$:/Downloads/08440029.pdf:pdf},
issn = {23274662},
journal = {IEEE Internet of Things Journal},
keywords = {Code reuse attacks (CRAs),control flow integrity (CFI),hardware-assisted security,physical unclonable function (PUF)},
number = {1},
pages = {458--471},
publisher = {IEEE},
title = {{HCIC: Hardware-Assisted Control-Flow Integrity Checking}},
volume = {6},
year = {2019}
}
@article{Suh2005a,
abstract = {We present a simple architectural mechanism called dynamic information flow tracking that can significantly improve the security of computing systems with negligible performance overhead. Dynamic information flow tracking protects programs against malicious software attacks by identifying spurious information flows from untrusted I/O and restricting the usage of the spurious information.Every security attack to take control of a program needs to transfer the program's control to malevolent code. In our approach, the operating system identifies a set of input channels as spurious, and the processor tracks all information flows from those inputs. A broad range of attacks are effectively defeated by checking the use of the spurious values as instructions and pointers.Our protection is transparent to users or application programmers; the executables can be used without any modification. Also, our scheme only incurs, on average, a memory overhead of 1.4 and a performance overhead of 1.1.},
author = {Suh, G. Edward and Lee, Jae W. and Zhang, David and Devadas, Srinivas},
doi = {10.1145/1037949.1024404},
file = {:D$\backslash$:/Downloads/memo-467.pdf:pdf},
issn = {01635980},
journal = {ACM SIGOPS Operating Systems Review},
number = {5},
pages = {85},
title = {{Secure program execution via dynamic information flow tracking}},
volume = {38},
year = {2005}
}
@book{BergerArnold2002Esd:,
address = {Lawrence, Kan. : Berkeley, CA :},
author = {Berger, Arnold},
isbn = {1578200733},
keywords = {Embedded computer systems -- Programming},
publisher = {CMP Books ;},
title = {{Embedded systems design : an introduction to processes, tools, and techniques}},
year = {2002}
}
@article{Ahmadvand2019,
abstract = {Tampering with software by man-at-the-end (MATE) attackers is an attack that can lead to security circumvention, privacy violation, reputation damage, and revenue loss. In this model, adversaries are end users who have full control over software as well as its execution environment. This full control enables them to tamper with programs to their benefit and to the detriment of software vendors or other end users. Software integrity protection research seeks for means to mitigate those attacks. Since the seminal work of Aucsmith, a great deal of research effort has been devoted to fight MATE attacks, and many protection schemes were designed by both academia and industry. Advances in trusted hardware, such as TPM and Intel SGX, have also enabled researchers to utilize such technologies for additional protection. Despite the introduction of various protection schemes, there is no comprehensive comparison study that points out advantages and disadvantages of different schemes. Constraints of different schemes and their applicability in various industrial settings have not been studied. More importantly, except for some partial classifications, to the best of our knowledge, there is no taxonomy of integrity protection techniques. These limitations have left practitioners in doubt about effectiveness and applicability of such schemes to their infrastructure. In this work, we propose a taxonomy that captures protection processes by encompassing system, defense and attack perspectives. Later, we carry out a survey and map reviewed papers on our taxonomy. Finally, we correlate different dimensions of the taxonomy and discuss observations along with research gaps in the field.},
author = {Ahmadvand, Mohsen and Pretschner, Alexander and Kelbert, Florian},
doi = {10.1016/bs.adcom.2017.12.007},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ahmadvand, Pretschner, Kelbert - 2019 - A Taxonomy of Software Integrity Protection Techniques.pdf:pdf},
isbn = {9780128151211},
issn = {00652458},
journal = {Advances in Computers},
keywords = {Integrity protection,Software monetization,Software protection,Tamper-proofing,Taxonomy},
pages = {413--486},
title = {{A Taxonomy of Software Integrity Protection Techniques}},
volume = {112},
year = {2019}
}
@article{Schaller2014,
abstract = {This paper presents a lightweight anti-counterfeiting solution using intrinsic Physically Unclonable Functions (PUFs), which are already embedded in most commodity hardware platforms. The presented solution is particularly suitable for low-end computing devices without on-board security features. Our anti-counterfeiting approach is based on extracting a unique fingerprint for individual devices exploiting inherent PUF characteristics from the on-chip static random-access memory (SRAM), which in turn allows to bind software to a particular hardware platform. Our solution does not require additional hardware, making it flexible as well as cost efficient. In a first step, we statistically analyze the characteristics of the intrinsic PUF instances found in two device types, both based on a widely used ARM Cortex-M microcontroller. We show that the quality of the PUF characteristics is almost ideal. Subsequently, we propose a security architecture to protect the platform's firmware by using a modified boot loader. In a proof of concept, we embed our solution on a state-of-the-art commodity system-on-a-chip platform equipped with an MCU similar to the ones previously analyzed. {\textcopyright} 2014 Springer International Publishing.},
author = {Schaller, Andr{\'{e}} and Arul, Tolga and {Van Der Leest}, Vincent and Katzenbeisser, Stefan},
doi = {10.1007/978-3-319-08593-7_6},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Schaller et al. - 2014 - Lightweight anti-counterfeiting solution for low-end commodity hardware using inherent PUFs.pdf:pdf},
isbn = {9783319085920},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {83--100},
title = {{Lightweight anti-counterfeiting solution for low-end commodity hardware using inherent PUFs}},
volume = {8564 LNCS},
year = {2014}
}
@article{Benso2003,
abstract = {{\textcopyright} 2003 IEEE. A watchdog processor for the MOTOROLA M68040 microprocessor is presented. Its main task is to protect from transient faults caused by SEUs the transmission of data between the processor and the system memory, and to ensure a correct instructions' flow, just monitoring the external bus, without modifying the internal architecture of the M68040. A description of the principal procedures is given, together with the method used for monitoring the instructions' flow.},
author = {Benso, A. and {Di Carlo}, S. and {Di Natale}, G. and Prinetto, P.},
doi = {10.1109/OLT.2003.1214381},
file = {:D$\backslash$:/Downloads/11384490.pdf:pdf},
isbn = {0769519687},
journal = {Proceedings - 9th IEEE International On-Line Testing Symposium, IOLTS 2003},
keywords = {Aerospace electronics,Circuit faults,Electromagnetic interference,Electromagnetic radiation,Electromagnetic radiative interference,Error correction,Microprocessors,Monitoring,Protection,Wiring},
pages = {144--148},
title = {{A watchdog processor to detect data and control flow errors}},
year = {2003}
}
@article{Skorobogatov2005,
abstract = {Semiconductor chips are used today not only to control systems, but also to protect them against security threats. A continuous battle is waged between manufacturers who invent new security solutions, learning their lessons from previous mistakes, and the hacker community, constantly trying to break implemented protections. Some chip manufacturers do not pay enough attention to the proper design and testing of protection mechanisms. Even where they claim their products are highly secure, they do not guarantee this and do not take any responsibility if a device is compromised. In this situation, it is crucial for the design engineer to have a convenient and reliable method of testing secure chips. This thesis presents a wide range of attacks on hardware security in microcontrollers and smartcards. This includes already known non-invasive attacks, such as power analysis and glitching, and invasive attacks, such as reverse engineering and microprobing. A new class of attacks – semi-invasive attacks – is introduced. Like invasive attacks, they require depackaging the chip to get access to its surface. But the passivation layer remains intact, as these methods do not require electrical contact to internal lines. Semi-invasive attacks stand between noninvasive and invasive attacks. They represent a greater threat to hardware security, as they are almost as effective as invasive attacks but can be low-cost like non-invasive attacks. This thesis' contribution includes practical fault-injection attacks to modify SRAM and EEPROM content, or change the state of any individual CMOS transistor on a chip. This leads to almost unlimited capabilities to control chip operation and circumvent protection mechanisms. A second contribution consist of experiments on data remanence, which show that it is feasible to extract information from powered-off SRAM and erased EPROM, EEPROM and Flash memory devices. A brief introduction to copy protection in microcontrollers is given. Hardware security evaluation techniques using semi-invasive methods are introduced. They should help developers to make a proper selection of components according to the required level of security. Various defence technologies are discussed, from low-cost obscurity methods to new approaches in silicon design.},
author = {Skorobogatov, Sergei P.},
file = {:D$\backslash$:/Downloads/UCAM-CL-TR-630.pdf:pdf},
issn = {1476-2986},
journal = {Technical report, University of Cambridge, Computer Laboratory},
number = {630},
pages = {144},
title = {{Semi-invasive attacks-a new approach to hardware security analysis}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.228.2204{\&}rep=rep1{\&}type=pdf},
year = {2005}
}
@article{Asokan2015,
abstract = {Today, large numbers of smart interconnected devices provide safety and security critical services for energy grids, industrial control systems, gas and oil search robots, home/office automation, transportation, and critical infrastructure. These devices often operate in swarms -- large, dynamic, and self-organizing networks. Software integrity verification of device swarms is necessary to ensure their correct and safe operation as well as to protect them against attacks. However, current device attestation schemes assume a single prover device and do not scale to swarms. We present SEDA, the first attestation scheme for device swarms. We introduce a formal security model for swarm attestation and show security of our approach in this model. We demonstrate two proof-of-concept implementations based on two recent (remote) attestation architectures for embedded systems, including an Intel research platform. We assess performance of SEDA based on these implementations and simulations of large swarms. SEDA can efficiently attest swarms with dynamic and static topologies common in automotive, avionic, industrial control and critical infrastructures settings.},
author = {Asokan, N and Brasser, Ferdinand and Ibrahim, Ahmad and Sadeghi, Ahmad-Reza and Schunter, Matthias and Tsudik, Gene and Wachsmann, Christian},
doi = {10.1145/2810103.2813670},
file = {:D$\backslash$:/Downloads/p964-asokan.pdf:pdf},
isbn = {978-1-4503-3832-5},
journal = {Proceedings of the 22Nd ACM SIGSAC Conference on Computer and Communications Security},
keywords = {device swarms,remote attestation,security},
pages = {964--975},
title = {{SEDA: Scalable Embedded Device Attestation}},
url = {http://doi.acm.org/10.1145/2810103.2813670},
year = {2015}
}
@inproceedings{Lee2017,
address = {New York, New York, USA},
author = {Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem},
booktitle = {Proceedings of the 12th International Conference on Availability, Reliability and Security - ARES '17},
doi = {10.1145/3098954.3103158},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Markantonakis, Akram - 2017 - Provisioning Software with Hardware-Software Binding.pdf:pdf},
isbn = {9781450352574},
pages = {1--9},
publisher = {ACM Press},
title = {{Provisioning Software with Hardware-Software Binding}},
url = {http://dl.acm.org/citation.cfm?doid=3098954.3103158},
year = {2017}
}
@article{Nyman,
author = {Nyman, Thomas and Paverd, Andrew},
file = {:D$\backslash$:/Downloads/a63-Nyman.pdf:pdf},
isbn = {9781450367257},
title = {{HardScope : Hardening Embedded Systems Against Data-Oriented Attacks}}
}
@article{SrivastavaA.2004,
abstract = {ATOM (Analysis Tools with OM) is a single framework for building a wide range of customized program analysis tools. It provides the common infrastructure present in all code-instrumenting tools; this is the difficult and time-consuming part. The user simply defines the tool-specific details in instrumentation and analysis routines. Building a basic block counting tool like Pixie with ATOM requires only a page of code. ATOM, using OM link-time technology, organizes the final executable such that the application program and user's analysis routines run in the same address space. Information is directly passed from the application program to the analysis routines through simple procedure calls instead of inter-process communication or files on disk. ATOM takes care that analysis routines do not interfere with the program's execution, and precise information about the program is presented to the analysis routines at all times. ATOM uses no simulation or interpretation. ATOM has been implemented on the Alpha AXP under OSF/1. It is efficient and has been used to build a diverse set of tools for basic block counting, profiling, dynamic memory recording, instruction and data cache simulation, pipeline simulation, evaluating branch prediction, and instruction scheduling.},
author = {{Srivastava A.}, Eustace A},
file = {:D$\backslash$:/Downloads/atom.pdf:pdf},
isbn = {1581136234},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {Algorithms; Block codes; Buffer storage; Computer,Analysis tools with OM (ATOM); Instruction schedu,Computer programming languages},
number = {4},
pages = {530--539},
title = {{ATOM: A system for building customized program analysis tools}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-3142675108{\&}partnerID=40{\&}md5=c19e7fb8e2ca6e5c7307bccefee400bb},
volume = {39},
year = {2004}
}
@article{Fritz,
author = {Fritz, Jason and Bonato, Michael and French, David and Scally, Larry},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Fritz et al. - Unknown - A Reconfigurable Advanced Tamper Resistant Embedded Processing Platform Anti-Tamper Technologies.pdf:pdf},
title = {{A Reconfigurable Advanced Tamper Resistant Embedded Processing Platform Anti-Tamper Technologies}}
}
@article{Asokan2018,
abstract = {Secure firmware update is an important stage in the IoT device life-cycle. Prior techniques, designed for other computational settings, are not readily suitable for IoT devices, since they do not consider idiosyncrasies of a realistic large-scale IoT deployment. This motivates our design of ASSURED, a secure and scalable update framework for IoT. ASSURED includes all stakeholders in a typical IoT update ecosystem, while providing end-to-end security between manufacturers and devices. To demonstrate its feasibility and practicality, ASSURED is instantiated and experimentally evaluated on two commodity hardware platforms. Results show that ASSURED is considerably faster than current update mechanisms in realistic settings.},
archivePrefix = {arXiv},
arxivId = {1807.05002v2},
author = {Asokan, N. and Nyman, Thomas and Rattanavipanon, Norrathep and Sadeghi, Ahmad Reza and Tsudik, Gene},
doi = {10.1109/TCAD.2018.2858422},
eprint = {1807.05002v2},
file = {:D$\backslash$:/Downloads/1807.05002.pdf:pdf},
issn = {02780070},
journal = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
keywords = {Computer security,Internet of Things (IoT),embedded software,embedded systems},
number = {11},
pages = {2290--2300},
title = {{ASSURED: Architecture for secure software update of realistic embedded devices}},
volume = {37},
year = {2018}
}
@article{Danger2018,
abstract = {In this paper we present a hardware based solution to verify simultaneously Code and Control-Flow Integrity (CCFI), aiming at protecting microcontrollers against both cyber-and physical attacks. This solution is non-intrusive as it does not require any modification of the CPU core. It relies on two additional hardware blocks external to the CPU: The first one - called CCFI-cache - acts as a dedicated cache for the storage of information to check the code and control-flow integrity, and the second one - CCFI-checker - performs control-flow and code integrity verification. Based on a RISC-V platform implementation, we show that the proposed scheme is able to perform online CCFI validation at the price of a small hardware area overhead and doubling the size of the. text section. In most cases, the impact on the run-time performance is on average 32 percent, offering for the first time a generic and practical hardware-enabled cyber-security solution. {\textcopyright} 2018 IEEE.},
author = {Danger, Jean Luc and Facon, Adrien and Guilley, Sylvain and Heydemann, Karine and Kuhne, Ulrich and {Si Merabet}, Abdelmalek and Timbert, Michael},
doi = {10.1109/DSD.2018.00093},
file = {:D$\backslash$:/Downloads/08491864.pdf:pdf},
isbn = {9781538673768},
journal = {Proceedings - 21st Euromicro Conference on Digital System Design, DSD 2018},
keywords = {Code Integrity,Control Flow Graph,Control-Flow Integrity,Cybersecurity,Hardware Protection,Hardware security,Instruction Hashing},
pages = {529--536},
publisher = {IEEE},
title = {{CCFI-Cache: A transparent and flexible hardware protection for code and control-flow integrity}},
year = {2018}
}
@article{Al-Kuwaiti2006,
abstract = {A number of qualitative and quantitative terms are used to describe the performance of what has come to be known as information systems, networks or infrastructures. However, some of these terms either have overlapping meanings or contain ambiguities in their definitions presenting problems to those who attempt a rigorous evaluation of the performance of such systems. The phenomenon arises because the wide range of disciplines covered by the term information technology have developed their own distinct terminologies. This paper presents a systematic approach for determining common and complementary characteristics of five widely-used concepts, dependability, fault-tolerance, reliability, security, and survivability. The approach consists of comparing definitions, attributes, and evaluation measures for each of the five concepts and developing corresponding relations. Removing redundancies and clarifying ambiguities will help the mapping of broad user-specified requirements into objective performance parameters for analyzing and designing information infrastructures},
author = {Al-Kuwaiti, M. and Kyriakopoulos, N. and Hussein, S.},
doi = {10.1109/ICCES.2006.320462},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Al-Kuwaiti, Kyriakopoulos, Hussein - 2006 - Network dependability, fault-tolerance, reliability, security, survivability A framework for.pdf:pdf},
isbn = {1424402719},
journal = {2006 International Conference on Computer Engineering and Systems, ICCES'06},
number = {December},
pages = {282--287},
title = {{Network dependability, fault-tolerance, reliability, security, survivability: A framework for comparative analysis}},
year = {2006}
}
@article{Serpanos2018,
abstract = {Embedded systems security is a significant requirement in emerging environments, considering the increasing deployment of embedded systems in several application domains. The large number of deployed embedded systems, their limited resources and their increasing complexity render systems vulnerable to an increasing number of threats. Additionally, the involvement of sensitive, often private, information and the expectation for safe and dependable embedded platforms lead to strong security requirements, even legal ones, which require new technologies for their provision. In this article, we provide an overview of embedded security issues, used methods and technologies, identifying important challenges in this emerging field.},
author = {Serpanos, Dimitrios N. and Voyiatzis, Artemios G.},
doi = {10.1145/2435227.2435262},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Serpanos, Voyiatzis - 2018 - Security challenges in embedded systems.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
number = {1s},
pages = {1--10},
title = {{Security challenges in embedded systems}},
volume = {12},
year = {2018}
}
@article{Alam2014,
abstract = {{\textcopyright} 2014 The British Computer Society 2014. All rights reserved.Metamorphism is a technique that mutates the binary code using different obfuscations and never keeps the same sequence of opcodes in the memory. This stealth technique provides the capability to a malware for evading detection by simple signature-based (such as instruction sequences, byte sequences and string signatures) anti-malware programs. In this paper, we present a new scheme named Annotated Control Flow Graph (ACFG) to efficiently detect such kinds of malware. ACFG is built by annotating CFG of a binary program and is used for graph and pattern matching to analyse and detect metamorphic malware. We also optimize the runtime of malware detection through parallelization and ACFG reduction, maintaining the same accuracy (without ACFG reduction) for malware detection. ACFG proposed in this paper: (i) captures the control flow semantics of a program; (ii) provides a faster matching of ACFGs and can handle malware with smaller CFGs, compared with other such techniques, without compromising the accuracy; (iii) contains more information and hence provides more accuracy than a CFG. Experimental evaluation of the proposed scheme using an existing dataset yields malware detection rate of 98.9{\%} and false positive rate of 4.5{\%}.},
author = {Alam, Shahid and Traore, Issa and Sogukpinar, Ibrahim},
doi = {10.1093/comjnl/bxu148},
file = {:D$\backslash$:/Downloads/bxu148.pdf:pdf},
issn = {14602067},
journal = {Computer Journal},
keywords = {annotated control flow graph,malware detection,optimizations,static binary analysis},
number = {10},
pages = {2608--2621},
title = {{Annotated Control Flow Graph for Metamorphic Malware Detection}},
volume = {58},
year = {2014}
}
@article{Atkinson,
author = {Atkinson, Darren C and Clara, Santa},
file = {:D$\backslash$:/Downloads/serp-02.pdf:pdf},
journal = {Proceedings of the 2002 International Conference on Software Engineering Research and Practice (SERP'02)},
keywords = {pointer analysis,program analysis,software maintenance},
title = {{Call Graph Extraction in the Presence of Function Pointers}},
year = {2002}
}
@article{Krawiecka2017,
abstract = {Passwords are undoubtedly the most dominant user authentication mechanism on the web today. Although they are inexpensive and easy-to-use, security concerns of password-based authentication are serious. Phishing and theft of password databases are two critical concerns. The tendency of users to re-use passwords across different services exacerbates the impact of these two concerns. Current solutions addressing these concerns are not fully satisfactory: they typically address only one of the two concerns; they do not protect passwords from rogue servers; they do not provide any verifiable evidence of their (server-side) adoption to users; and they face deployability challenges in terms of the cost for service providers and/or ease-of-use for end users. We present SafeKeeper, a comprehensive approach to protect the confidentiality of passwords in web authentication systems. Unlike previous approaches, SafeKeeper protects user passwords against very strong adversaries, including rogue servers and sophisticated external phishers. It is relatively inexpensive to deploy as it (i) uses widely available hardware security mechanisms like Intel SGX, (ii) is integrated into popular web platforms like WordPress, and (iii) has small performance overhead. We describe a variety of challenges in designing and implementing such a system, and how we overcome them. Through an 86-participant user study, and systematic analysis and experiments, we demonstrate the usability, security and deployability of SafeKeeper, which is available as open-source.},
archivePrefix = {arXiv},
arxivId = {1709.01261},
author = {Krawiecka, Klaudia and Kurnikov, Arseny and Paverd, Andrew and Mannan, Mohammad and Asokan, N.},
doi = {10.1145/3178876.3186101},
eprint = {1709.01261},
file = {:D$\backslash$:/Downloads/p349-krawiecka.pdf:pdf},
isbn = {9781450356398},
keywords = {Passwords, Phishing, Intel SGX, Trusted Execution,acm reference format,andrew paverd,arseny kurnikov,intel sgx,klaudia krawiecka,mohammad mannan,passwords,phishing,trusted execution environment},
pages = {349--358},
title = {{SafeKeeper: Protecting Web Passwords using Trusted Execution Environments}},
url = {http://arxiv.org/abs/1709.01261{\%}0Ahttp://dx.doi.org/10.1145/3178876.3186101},
year = {2017}
}
@inproceedings{Goloubeva2003,
abstract = {Over the last years, an increasing number of safety-critical tasks have been demanded to computer systems. In this paper, a software-based approach for developing safety-critical applications is analyzed. The technique is based on the introduction of additional executable assertions to check the correct execution of the program control flow. By applying the proposed technique, several benchmark applications have been hardened against transient errors. Fault Injection campaigns have been performed to evaluate the fault detection capability of the proposed technique in comparison with state-of-the-art alternative assertion- based methods. Experimental results show that the proposed approach is far more effective than the other considered techniques in terms of fault detection capability, at the cost of a limited increase in memory requirements and in performance overhead.},
author = {Goloubeva, O. and Rebaudengo, M. and {Sonza Reorda}, M. and Violante, M.},
booktitle = {Proceedings. 16th IEEE Symposium on Computer Arithmetic},
doi = {10.1109/DFTVS.2003.1250158},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Goloubeva et al. - 2003 - Soft-error detection using control flow assertions.pdf:pdf},
isbn = {0-7695-2042-1},
issn = {0887-2171},
month = {nov},
number = {2},
pages = {581--588},
publisher = {IEEE Comput. Soc},
title = {{Soft-error detection using control flow assertions}},
url = {http://ieeexplore.ieee.org/document/1250158/},
volume = {16},
year = {2003}
}
@article{Szekeres2013,
abstract = {Memory corruption bugs in software written in low-level languages like C or C++ are one of the oldest problems in computer security. The lack of safety in these languages allows attackers to alter the program's behavior or take full control over it by hijacking its control flow. This problem has existed for more than 30 years and a vast number of potential solutions have been proposed, yet memory corruption attacks continue to pose a serious threat. Real world exploits show that all currently deployed protections can be defeated. This paper sheds light on the primary reasons for this by describing attacks that succeed on today's systems. We systematize the current knowledge about various protection techniques by setting up a general model for memory corrup- tion attacks. Using this model we show what policies can stop which attacks. The model identifies weaknesses of currently deployed techniques, as well as other proposed protections enforcing stricter policies. We analyze the reasons why protection mechanisms imple- menting stricter polices are not deployed. To achieve wide adoption, protection mechanisms must support a multitude of features and must satisfy a host of requirements. Especially important is performance, as experience shows that only solutions whose overhead is in reasonable bounds get deployed. A comparison of different enforceable policies helps de- signers of new protection mechanisms in finding the balance between effectiveness (security) and efficiency.We identify some open research problems, and provide suggestions on improving the adoption of newer techniques.},
author = {Szekeres, L{\'{a}}szl{\'{o}} and Payer, Mathias and Wei, Tao and Song, Dawn},
doi = {10.1109/SP.2013.13},
file = {:D$\backslash$:/Downloads/06547101.pdf:pdf},
isbn = {9780769549774},
issn = {10816011},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {48--62},
title = {{SoK: Eternal war in memory}},
year = {2013}
}
@article{Jaeger2006,
abstract = {We propose an integrity measurement approach based on information flow integrity, which we call the Policy-Reduced Integrity Measurement Architecture (PRIMA). The recent availability of secure hardware has made it practical for a system to measure its own integrity, such that it can generate an integrity proof for remote parties. Various approaches have been proposed, but most simply measure the loaded code and static data to approximate runtime system integrity. We find that these approaches suffer from two problems: (1) the load-time measurements of code alone do not accurately reflect runtime behaviors, such as the use of untrusted network data, and (2) they are inefficient, requiring all measured entities to be known and fully trusted even if they have no impact on the target application. Classical integrity models are based on information flow, so we design the PRIMA approach to enable measurement of information flow integrity and prove that it achieves these goals. We prove how a remote party can verify useful information flow integrity properties using PRIMA. A PRIMA prototype has been built based on the open-source Linux Integrity Measurement Architecture (IMA) using SELinux policies to provide the information flow. Copyright 2006 ACM.},
author = {Jaeger, T.a and Sailer, R.b and Shankar, U.c},
doi = {http://doi.acm.org/10.1145/1133058.1133063},
file = {:D$\backslash$:/Downloads/p19-jaeger.pdf:pdf},
isbn = {1595933549},
journal = {Proceedings of ACM Symposium on Access Control Models and Technologies, SACMAT},
keywords = {clark-wilson lite in-,information flow,remote attestation},
pages = {19--28},
title = {{PRIMA: Policy-Reduced Integrity Measurement Architecture}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-33748062337{\&}partnerID=40{\&}md5=df2fcca76c14582b39ee7c050b08e22b},
volume = {2006},
year = {2006}
}
@inproceedings{For,
author = {Defrawy, Karim El and Perito, Daniele and Tsudik, Gene and Et al.},
booktitle = {Processings of the 19th Annual Network and Distributed System Security Symposium},
pages = {5--8},
title = {{SMART: Secure and Minimal Architecture for (Establishing a Dynamic) Root of Trust}}
}
@inproceedings{LLVM:CGO04,
address = {San Jose, CA, USA},
author = {Lattner, Chris and Adve, Vikram},
month = {mar},
pages = {75--88},
title = {{{\{}LLVM{\}}: A Compilation Framework for Lifelong Program Analysis and Transformation}},
year = {2004}
}
@article{Edwards2001old,
abstract = {Distributed computing on the Internet presents new challenges and$\backslash$nopportunities for tools that inspect and modify program binaries.$\backslash$nThe dynamic and heterogeneous nature of the Internet environment$\backslash$nextends the traditional product development process by requiring$\backslash$nprogram development tools like these, which were once used only internally,$\backslash$nto work in live environments too. The concept of compilation process$\backslash$nmust be expanded along with the capabilities of the binary tools.$\backslash$nThis paper presents Vulcan, a second-generation technology that addresses$\backslash$nmany of these challenges. Vulcan provides both static and dynamic$\backslash$ncode modification and provides a framework for cross-component analysis$\backslash$nand optimization. It provides system-level analysis for heterogeneous$\backslash$nbinaries across instruction sets. Vulcan works in the Win32 environment$\backslash$nand can process x86, IA64, and MSIL binaries. Vulcan scales to large$\backslash$ncommercial applications and has been used to improve performance$\backslash$nand reliability of Microsoft products in a production environment.},
author = {Edwards, Andrew and Srivastava, Amitabh and Vo, Hoi},
file = {:D$\backslash$:/Downloads/tr-2001-50.pdf:pdf},
pages = {12},
title = {{Vulcan: Binary transformation in a distributed environment}},
url = {https://www.microsoft.com/en-us/research/publication/vulcan-binary-transformation-in-a-distributed-environment/},
year = {2001}
}
@phdthesis{Kinder2010,
author = {Kinder, Dipl.-Inf Johannes},
file = {:D$\backslash$:/Downloads/Kinder{\_}-{\_}Static{\_}Analysis{\_}of{\_}x86{\_}Executables.pdf:pdf},
keywords = {binaries,binary,control flow,disassembly,executables,static analysis,x86},
number = {November},
school = {Technische Universitat Darmstadt},
title = {{Static Analysis of x86 Executables}},
url = {https://infoscience.epfl.ch/record/167546/files/thesis.pdf},
year = {2010}
}
@article{Kinder2009,
abstract = {Due to indirect branch instructions, analyses on executables commonly suffer from the problem that a complete control flow graph of the program is not available. Data flow analysis has been proposed before to statically determine branch targets in many cases, yet a generic strategy without assumptions on compiler idioms or debug information is lacking. We have devised an abstract interpretation-based framework for generic low level programs with indirect jumps which safely combines a pluggable abstract domain with the notion of partial control flow graphs. Using our framework, we are able to show that the control flow reconstruction algorithm of our disassembly tool Jakstab produces the most precise overapproximation of the control flow graph with respect to the used abstract domain. {\textcopyright} 2009 Springer Berlin Heidelberg.},
author = {Kinder, Johannes and Zuleger, Florian and Veith, Helmut},
doi = {10.1007/978-3-540-93900-9_19},
file = {:D$\backslash$:/Downloads/vmcai09.pdf:pdf},
isbn = {3540938990},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {214--228},
title = {{An abstract interpretation-based framework for control flow reconstruction from binaries}},
volume = {5403 LNCS},
year = {2009}
}
@article{Kinder2008,
abstract = {For processing compiled code, model checkers require accurate model extraction from binaries. We present our fully configurable binary analysis platform Jakstab, which resolves indirect branches by multiple rounds of disassembly interleaved with dataflow analysis. We demonstrate that this iterative disassembling strategy achieves better results than the state-of-the-art tool IDA Pro. {\textcopyright} 2008 Springer-Verlag.},
author = {Kinder, Johannes and Veith, Helmut},
doi = {10.1007/978-3-540-70545-1_40},
file = {:D$\backslash$:/Downloads/Kinder-Veith2008{\_}Chapter{\_}JakstabAStaticAnalysisPlatform (1).pdf:pdf},
isbn = {3540705430},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {423--427},
title = {{Jakstab: A static analysis platform for binaries - Tool paper}},
volume = {5123 LNCS},
year = {2008}
}
@article{DeClercq2017,
abstract = {CFI is a computer security technique that detects runtime attacks by monitoring a program's branching behavior. This work presents a detailed analysis of the security policies enforced by 21 recent hardware-based CFI architectures. The goal is to evaluate the security, limitations, hardware cost, performance, and practicality of using these policies. We show that many architectures are not suitable for widespread adoption, since they have practical issues, such as relying on accurate control flow model (which is difficult to obtain) or they implement policies which provide only limited security.},
archivePrefix = {arXiv},
arxivId = {1706.07257},
author = {de Clercq, Ruan and Verbauwhede, Ingrid},
eprint = {1706.07257},
file = {:D$\backslash$:/Downloads/1706.07257.pdf:pdf},
pages = {1--27},
title = {{A survey of Hardware-based Control Flow Integrity (CFI)}},
url = {http://arxiv.org/abs/1706.07257},
volume = {1},
year = {2017}
}
@article{Lee2019,
author = {Lee, Robert P and Markantonakis, Konstantinos and Akram, Raja Naeem},
doi = {10.1145/3284361},
file = {:D$\backslash$:/Downloads/Robert Lee PhD.pdf:pdf},
issn = {15399087},
journal = {ACM Transactions on Embedded Computing Systems},
keywords = {Hardware-Software Binding,Internet of Things,Platform Specific Execution,Secure Application Execution},
month = {apr},
number = {3},
pages = {1--21},
title = {{Ensuring Secure Application Execution and Platform-Specific Execution in Embedded Devices}},
url = {http://dl.acm.org/citation.cfm?doid=3323876.3284361},
volume = {18},
year = {2019}
}
@inproceedings{Dessouky2017,
abstract = {Attacks targeting software on embedded systems are becoming increasingly prevalent. Remote attestation is a mechanism that allows establishing trust in embedded devices. However, existing attestation schemes are either static and cannot detect control-flow attacks, or require instrumentation of software incurring high performance overheads. To overcome these limitations, we present LO-FAT, the first practical hardware-based approach to control-flow attestation. By leveraging existing processor hardware features and commonly-used IP blocks, our approach enables efficient control-flow attestation without requiring software instrumentation. We show that our proof-of-concept implementation based on a RISC-V SoC incurs no processor stalls and requires reasonable area overhead.},
address = {New York, New York, USA},
archivePrefix = {arXiv},
arxivId = {1706.03754},
author = {Dessouky, Ghada and Zeitouni, Shaza and Nyman, Thomas and Paverd, Andrew and Davi, Lucas and Koeberl, Patrick and Asokan, N. and Sadeghi, Ahmad-Reza},
booktitle = {Proceedings of the 54th Annual Design Automation Conference 2017 on - DAC '17},
doi = {10.1145/3061639.3062276},
eprint = {1706.03754},
file = {:D$\backslash$:/Downloads/1706.03754.pdf:pdf},
isbn = {9781450349277},
issn = {0738100X},
pages = {1--6},
publisher = {ACM Press},
title = {{LO-FAT}},
url = {http://dl.acm.org/citation.cfm?doid=3061639.3062276},
year = {2017}
}
@inproceedings{Abadi2005,
address = {New York, New York, USA},
author = {Abadi, Mart{\'{i}}n and Budiu, Mihai and Erlingsson, {\'{U}}lfar and Ligatti, Jay},
booktitle = {Proceedings of the 12th ACM conference on Computer and communications security - CCS '05},
doi = {10.1145/1102120.1102165},
file = {:D$\backslash$:/Downloads/Abadi et al.{\_}2005{\_}Control Flow Integrity.pdf:pdf},
isbn = {1595932267},
keywords = {binary rewriting,control-flow graph,inlined reference moni-,tors,vulnerabilities},
pages = {340},
publisher = {ACM Press},
title = {{Control-flow integrity}},
url = {http://portal.acm.org/citation.cfm?doid=1102120.1102165},
year = {2005}
}
@phdthesis{Maes2012,
author = {Maes, R},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Maes - 2012 - Physically Unclonable Functions Constructions, Properties and Applications (Fysisch onkloonbare functies constructies, eig.pdf:pdf},
isbn = {9789460185618},
keywords = {Ro,dissertation,doctoraat,kuleuven,phd,thesis},
number = {August},
school = {Katholieke Universiteit Leuven},
title = {{Physically Unclonable Functions: Constructions, Properties and Applications (Fysisch onkloonbare functies: constructies, eigenschappen en toepassingen)}},
url = {https://lirias.kuleuven.be/handle/123456789/353455},
year = {2012}
}
@phdthesis{Drimer2008,
abstract = {Volatile FPGAs, the dominant type of programmable logic devices, are used in space, military, automotive, and consumer electronics applications which require them to operate in a wide range of environments. The continuous growth in both their capability and capacity now requires significant resources to be invested in the designs that are created for them. This has brought increased interest in the security attributes of FPGAs; specifically, how well do they protect the information processed within it, how are designs protected during distribution, and how developers' ownership rights are protected while designs from multiple sources are combined. This survey establishes the foundations for discussing ``FPGA security'', examines a wide range of attacks and defenses along with the current state of industry offerings, and finally, outlines on-going research and latest developments.},
author = {Drimer, Saar},
booktitle = {University of Cambridge},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Drimer - 2008 - Volatile FPGA design security – a survey.pdf:pdf},
pages = {1--51},
school = {University of Cambridge},
title = {{Volatile FPGA design security – a survey}},
url = {http://www.cl.cam.ac.uk/{~}sd410/papers/fpga{\_}security.pdf},
year = {2008}
}
@techreport{Security2017,
author = {{Qualcomm Security}},
file = {:D$\backslash$:/Downloads/whitepaper-pointer-authentication-on-armv8-3.pdf:pdf},
number = {January},
title = {{Pointer Authentication on ARMv8 . 3}},
url = {https://www.qualcomm.com/media/documents/files/whitepaper-pointer-authentication-on-armv8-3.pdf},
year = {2017}
}
@article{Corporation2017,
abstract = {Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non‐infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. This document contains information on products, services and/or processes in development. All information provided here is subject to change without notice. Contact your Intel representative to obtain the latest forecast, schedule, specifications and roadmaps. The products and services described may contain defects or errors known as errata which may cause deviations from published specifications. Current characterized errata are available on request. Intel technologies' features and benefits depend on system configuration and may require enabled hardware, software or service activation. Performance varies depending on system configuration.},
author = {Corporation, Intel},
file = {:D$\backslash$:/Downloads/control-flow-enforcement-technology-preview.pdf:pdf},
journal = {Intel Specifications},
number = {June},
pages = {1--136},
title = {{Control-flow Enforcement Technology Preview}},
url = {https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf},
year = {2017}
}
@article{He2017,
abstract = {{\textcopyright} 2017 ACM. Code-reuse attack is a growing threat to computing systems as it can circumvent existing security defenses. Fortunately, control flow integrity (CFI) is promising in defending such attack. However, former implementations generally suffer from two major drawbacks: 1) complex pre-processing to obtain control flow graph; 2) high overhead. In this paper, we propose a cross-layer approach that employs basic block information inside the binary code and read-only data to enforce fine-grained control-flow integrity. Our approach demonstrates high applicability and thorough attack detection coverage without static analysis or recompilation. Meanwhile, it can effectively protect even striped programs, while incurring negligible 0.13{\%} performance overhead.},
author = {He, Wenjian and Das, Sanjeev and Zhang, Wei and Liu, Yang},
doi = {10.1145/3061639.3062291},
file = {:D$\backslash$:/Downloads/08060307.pdf:pdf},
isbn = {9781450349277},
issn = {0738100X},
journal = {Proceedings - Design Automation Conference},
pages = {1--6},
title = {{No-Jump-into-Basic-Block: Enforce Basic Block CFI on the Fly for Real-world Binaries}},
volume = {Part 12828},
year = {2017}
}
@incollection{Kinder2012,
abstract = {Unresolved indirect branch instructions are a major obstacle for statically reconstructing a control flow graph (CFG) from machine code. If static analysis cannot compute a precise set of possible targets for a branch, the necessary conservative over-approximation introduces a large amount of spurious edges, leading to even more imprecision and a degenerate CFG. In this paper, we propose to leverage under-approximation to handle this problem. We provide an abstract interpretation framework for control flow reconstruction that alternates between over- and under-approximation. Effectively, the framework imposes additional preconditions on the program on demand, allowing to avoid conservative over-approximation of indirect branches. We give an example instantiation of our framework using dynamically observed execution traces and constant propagation. We report preliminary experimental results confirming that our alternating analysis yields CFGs closer to the concrete CFG than pure over- or under-approximation.},
author = {Kinder, Johannes and Kravchenko, Dmitry},
booktitle = {Verification, Model Checking, and Abstract Interpretation},
doi = {10.1007/978-3-642-27940-9_18},
file = {:D$\backslash$:/Downloads/Kinder-Kravchenko2012{\_}Chapter{\_}AlternatingControlFlowReconstr.pdf:pdf},
pages = {267--282},
title = {{Alternating Control Flow Reconstruction}},
url = {http://link.springer.com/10.1007/978-3-642-27940-9{\_}18},
year = {2012}
}
@article{Carlini2015old,
author = {Carlini, Nicolas and Barresi, Antonio and Z{\"{u}}rich, E T H and Payer, Mathias and Wagner, David and Gross, Thomas R and Z{\"{u}}rich, E T H and Carlini, Nicolas and Barresi, Antonio and Wagner, David and Gross, Thomas R},
file = {:D$\backslash$:/Downloads/sec15-paper-carlini.pdf:pdf},
isbn = {9781931971232},
journal = {24Th USENIX Security Symposium (USENIX Security 15)},
pages = {161--176},
title = {{Control-Flow Bending: On the Effectiveness of Control-Flow Integrity}},
year = {2015}
}
@article{Burow,
author = {Burow, Nathan and Carr, Scott A. and Nash, Joseph and Larsen, Per and Franz, Michael and Brunthaler, Stefan and Payer, Mathias},
doi = {10.1145/3054924},
file = {:D$\backslash$:/Downloads/17CSUR.pdf:pdf},
issn = {03600300},
journal = {ACM Computing Surveys},
month = {apr},
number = {1},
pages = {1--33},
title = {{Control-Flow Integrity}},
url = {http://dl.acm.org/citation.cfm?doid=3058791.3054924},
volume = {50},
year = {2017}
}
@article{Li2011,
abstract = {x},
author = {Li, Yanlin and Mccune, Jonathan M and Perrig, Adrian},
doi = {10.1145/2046707.2046711},
file = {:D$\backslash$:/Downloads/li{\_}mccune{\_}perrig{\_}viper{\_}ccs2011.pdf:pdf},
isbn = {9781450309486},
issn = {09581669},
journal = {Proceedings of the ACM Conference on Computer and Communications Security (CCS)},
keywords = {firmware,integrity peripherals,proxy attack,software},
number = {October},
pages = {3--16},
pmid = {20669782},
title = {{VIPER : Verifying the Integrity of PERipherals' Firmware}},
url = {http://dl.acm.org/citation.cfm?id=2046711},
volume = {22},
year = {2011}
}
@article{Seshadri2007,
abstract = {We propose a primitive, called Pioneer, as a first step towards verifiable code execution on untrusted legacy hosts. Pioneer does not require any hardware support such as secure co-processors or CPU-architecture extensions. We implement Pioneer on an Intel Pentium IV Xeon processor. Pioneer can be used as a basic building block to build security systems. We demonstrate this by building a kernel rootkit detector. Copyright 2005 ACM.},
author = {Seshadri, Arvind and Luk, Mark and Shi, Elaine and Perrig, Adrian and {Van Doorn}, Leendert and Khosla, Pradeep},
doi = {10.1145/1095810.1095812},
file = {:D$\backslash$:/Downloads/pioneer.pdf:pdf},
isbn = {1595930795},
journal = {Proceedings of the 20th ACM Symposium on Operating Systems Principles, SOSP 2005},
keywords = {dynamic root of trust,rootkit detection,self-check-summing code,software-based code attestation,verifiable code execution},
pages = {1--16},
title = {{Pioneer: Verifying code integrity and enforcing untampered code execution on legacy systems}},
year = {2005}
}
@article{Seshadri2004,
abstract = {We expect a future where we are surrounded by embedded devices, ranging from Java-enabled cell phones to sensor networks and smart appliances. An adversary can compromise our privacy and safety by maliciously modifying the memory contents of these embedded devices. In this paper, we propose a softWare-based attestation technique (SWATT) to verify the memory contents of embedded devices and establish the absence of malicious changes to the memory contents. SWATT does not need physical access to the device's memory, yet provides memory content attestation similar to TCG or NGSCB without requiring secure hardware. SWATT can detect any change in memory contents with high probability, thus detecting viruses, unexpected configuration settings, and Trojan Horses. To circumvent SWATT, we expect that an attacker needs to change the hardware to hide memory content changes. We present an implementation of SWATT in off-the-shelf sensor network devices, which enables us to verify the contents of the program memory even while the sensor node is running. View full abstract},
author = {Seshadri, Arvind and Perrig, Adrian and {Van Doom}, Leendert and Khosla, Pradeep},
doi = {10.1109/SECPRI.2004.1301329},
file = {:D$\backslash$:/Downloads/swatt.pdf:pdf},
isbn = {0769521363},
journal = {Proceedings - IEEE Symposium on Security and Privacy},
pages = {272--282},
title = {{SWATT: SoftWare-based ATTestation for embedded devices}},
volume = {2004},
year = {2004}
}
@article{Forold,
author = {For, Ramework and Of, Rogramming and Of, Nternet},
doi = {10.1.1.639.8746},
file = {:D$\backslash$:/Downloads/smart.pdf:pdf},
title = {{SMART: Secure and Minimal Architecture for (Establishing a Dynamic) Root of Trust}}
}
@inproceedings{Abera2016,
abstract = {Remote attestation is a crucial security service particularly relevant to increasingly popular IoT (and other embedded) devices. It allows a trusted party (verifier) to learn the state of a remote, and potentially malware-infected, device (prover). Most existing approaches are static in nature and only check whether benign software is initially loaded on the prover. However, they are vulnerable to run-time attacks that hijack the application's control or data flow, e.g., via return-oriented programming or data-oriented exploits. As a concrete step towards more comprehensive run-time remote attestation, we present the design and implementation of Control- FLow ATtestation (C-FLAT) that enables remote attestation of an application's control-flow path, without requiring the source code. We describe a full prototype implementation of C-FLAT on Raspberry Pi using its ARM TrustZone hardware security extensions. We evaluate C-FLAT's performance using a real-world embedded (cyber-physical) application, and demonstrate its efficacy against control-flow hijacking attacks.},
address = {New York, New York, USA},
archivePrefix = {arXiv},
arxivId = {1605.07763},
author = {Abera, Tigist and Asokan, N. and Davi, Lucas and Ekberg, Jan-Erik and Nyman, Thomas and Paverd, Andrew and Sadeghi, Ahmad-Reza and Tsudik, Gene},
booktitle = {Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security - CCS'16},
doi = {10.1145/2976749.2978358},
eprint = {1605.07763},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Abera et al. - 2016 - C-FLAT Control-Flow Attestation for Embedded Systems Software.pdf:pdf},
isbn = {9781450341394},
issn = {15437221},
keywords = {control-flow attacks,embedded system security,remote attestation},
pages = {743--754},
pmid = {23776192},
publisher = {ACM Press},
title = {{C-FLAT: Control-Flow Attestation for Embedded Systems Software}},
url = {http://arxiv.org/abs/1605.07763},
year = {2016}
}
@misc{Wang2016a,
author = {Wang, Wei},
file = {:D$\backslash$:/Downloads/Non{\_}stack{\_}Buffer{\_}Overflow{\_}Pointer{\_}Subterfuge.pdf:pdf},
pages = {1--17},
title = {{Non-Stack Buffer Overflow and Pointer Subterfuge The Memory Layout of Process in Linux}},
url = {http://www.cs.virginia.edu/{~}ww6r/CS4630/lectures/Non{\_}stack{\_}Buffer{\_}Overflow{\_}Pointer{\_}Subterfuge.pdf},
urldate = {2019-08-18},
year = {2016}
}
@article{Lee2016,
abstract = {Embedded systems are small scale computing devices that are increasingly located in more of the items we use and own. The number of embedded systems in the world is increasing dramatically as the “internet of things” concept becomes more prevalent in the market. The value of the market for embedded systems is predicted to increase to being worth trillions of dollars by 2020. With great value in the embedded system market, there is a need for preventing unauthorised firmware tampering or product counterfeiting. Here is presen- ted a technique for binding software to hardware instances that uses hardware intrinsic security properties of the devices being protected. The proposed technique provides assurance to manufacturers that only they can perform their hardware and software binding and create their products. Also presen- ted is an FPGA implementation of the described scheme that binds the hardware and software together with only a 6.7{\%} increase in execution time. Thus, making it difficult for an attacker to either counterfeit the device or extract the (software) Intellectual Property. Keywords},
author = {Lee, Robert P. and Markantonakis, Konstantinos and Akram, Raja Naeem},
doi = {10.1145/2899015.2899029},
file = {:C$\backslash$:/Users/Luke/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Markantonakis, Akram - 2016 - Binding Hardware and Software to Prevent Firmware Modification and Device Counterfeiting.pdf:pdf},
isbn = {9781450342889},
journal = {Proceedings of the 2nd ACM International Workshop on Cyber-Physical System Security - CPSS '16},
keywords = {binding,counterfeiting,firm-,hardware,intrinsic,modification,puf,security,software,ware},
pages = {70--81},
title = {{Binding Hardware and Software to Prevent Firmware Modification and Device Counterfeiting}},
url = {http://dl.acm.org/citation.cfm?doid=2899015.2899029},
year = {2016}
}
@article{Kil2009,
abstract = {Remote attestation of system integrity is an essential part of trusted computing. However, current remote attestation techniques only provide integrity proofs of static properties of the system. To address this problem we present a novel remote dynamic attestation system named ReDAS (Remote Dynamic Attestation System) that provides integrity evidence for dynamic system properties. Such dynamic system properties represent the runtime behavior of the attested system, and enable an attester to prove its runtime integrity to a remote party. ReDAS currently provides two types of dynamic system properties for running applications: structural integrity and global data integrity. In this work, we present the challenges of remote dynamic attestation, provide an in-depth security analysis and introduce a first step towards providing a complete runtime dynamic attestation framework. Our prototype implementation and evaluation with real-world applications show that we can improve on current static attestation techniques with an average performance overhead of 8{\%}.},
author = {Kil, Chongkyung and Sezer, Emre C. and Azab, Ahmed M. and Ning, Peng and Zhang, Xiaolan},
doi = {10.1109/DSN.2009.5270348},
file = {:D$\backslash$:/Downloads/05270348.pdf:pdf},
isbn = {9781424444212},
journal = {Proceedings of the International Conference on Dependable Systems and Networks},
keywords = {Dynamic attestation,Remote attestation,Runtime integrity,System security,Trusted computing},
pages = {115--124},
publisher = {IEEE},
title = {{Remote attestation to dynamic system properties: Towards providing complete system integrity evidence}},
year = {2009}
}
@article{Seshadri,
abstract = {This paper presents SCUBA (Secure Code Update By Attestation), for detecting and recovering compromised nodes in sensor networks. The SCUBA protocol enables the design of a sensor network that can detect compromised nodes without false negatives, and},
author = {Seshadri, Arvind and Luk, Mark and Perrig, Adrian and Doorn, Leendert Van and Khosla, Pradeep},
file = {:D$\backslash$:/Downloads/seshadri{\_}luk{\_}perrig{\_}vanDoorn{\_}khosla{\_}scuba.pdf:pdf},
isbn = {1595935576},
keywords = {attestation,externally-verifiable code execution,secure code update,self-checksumming code,software-based},
title = {{SCUBA : Secure Code Update By Attestation in Sensor Networks}}
}
